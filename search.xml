<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>无源域适应</title>
      <link href="/academic_research/domain_adaption/SFDA_0/"/>
      <url>/academic_research/domain_adaption/SFDA_0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="论文1：Do-We-Really-Need-to-Access-the-Source-Data-Source-Hypothesis-Transfer-for-Unsupervised-Domain-Adaptation"><a href="#论文1：Do-We-Really-Need-to-Access-the-Source-Data-Source-Hypothesis-Transfer-for-Unsupervised-Domain-Adaptation" class="headerlink" title="论文1：Do We Really Need to Access the Source Data? Source Hypothesis Transfer for Unsupervised Domain Adaptation"></a>论文1：Do We Really Need to Access the Source Data? Source Hypothesis Transfer for Unsupervised Domain Adaptation</h1><p>文章题目是《我们真的需要访问源数据吗？ 无监督域适应的源假设迁移》，发表在ICML2020，目前citation 382。</p><p>code:<a href="https://github.com/tim-learn/SHOT">https://github.com/tim-learn/SHOT</a></p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>之前的无监督域适应的方法需要接入源域的数据进行适应，在分布式或者<font color='red'>数据不共享场景</font>会造成私有数据的泄露。</li></ul><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><ul><li>论文的假设是有标签的源域数据经过训练好的特征提取器，输出的特征和分类器的结果应该和无标签的目标域数据输出的特征是对齐的，分类器的结果是相似的；</li><li>为了实现特征对齐，从信息论的视角，文章利用<font color='red'>自熵最小化和网络输出类别比较平均两个方面进行约束，来使得信息最大化</font>；</li><li>为了防止分类器输出噪声结果的影响，文中还在特征层面，对目标域的特征输出通过<font color='red'>原型聚类生成伪标签</font>，来约束目标域的训练。</li></ul><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><img src="https://s1.ax1x.com/2022/12/26/zxsDYD.png" alt="zxsDYD.png" border="0" / loading="lazy"><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul><li><p>在有标签的源域数据上，训练一个特征表示器和分类器；</p></li><li><p>在无标签的目标域数据上，冻结分类器，用entropy loss和diversity loss约束目标域的特征调整backone参数；</p></li></ul><ul><li>更新伪标签。<br><br>利用softmax<font color='red'>对特征进行加权平均，再更新每一类的原型质心</font>。根据调整后的原型得到的特征，再经过分类器计算伪标签。</li></ul><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>训练源域的损失函数，使用带有label smoothing的交叉熵；<br><img src="https://s1.ax1x.com/2022/12/26/zxWJNq.png" alt="zxWJNq.png" border="0" / loading="lazy"></p><p>训练目标域的损失函数如下：</p><ul><li>使用分类器输出的K维向量进行自熵约束和互信息约束和伪标签交叉熵的约束。<br><br>自熵最小化可以使得输出的预测类别更加确定，每个类别中的所有样本特征的均值最小化可以保证每个类别在特征空间中比较均匀。</li></ul><img src="https://s1.ax1x.com/2022/12/26/zxfiGV.png" alt="zxfiGV.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxfQG6.png" alt="zxfQG6.png" border="0" / loading="lazy"><ul><li>伪标签$\hat{y}_t$尖使用原型聚类来确定。</li></ul><img src="https://s1.ax1x.com/2022/12/26/zxf8MD.png" alt="zxf8MD.png" border="0" / loading="lazy"><p>总的损失函数为</p><img src="https://s1.ax1x.com/2022/12/26/zxfNdA.png" alt="zxfNdA.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxfdit.png" alt="zxfdit.png" border="0" / loading="lazy"><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_39456088/article/details/117002227">https://blog.csdn.net/qq_39456088/article/details/117002227</a></p><h1 id="论文2：Domain-Adaptation-without-Source-Data"><a href="#论文2：Domain-Adaptation-without-Source-Data" class="headerlink" title="论文2：Domain Adaptation without Source Data"></a>论文2：Domain Adaptation without Source Data</h1><p>文章题目是《没有源域数据的域适应》，发表在TAI（IEEE Transactions on Artificial Intelligence）2021，目前citation 62。和论文1是同期工作，对于无源域适应(Source data-Free Domain Adaptation, SFDA)，论文故事讲的好。</p><p>code:<a href="https://github.com/youngryan1993/SFDA-SourceFreeDA">https://github.com/youngryan1993/SFDA-SourceFreeDA</a></p><h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>不同域之间会存在数据不共享或者信息敏感的问题，目标域只能获得预训练的源域模型，<font color='red'>无法获得其数据</font>。</li><li>论文观测到，在无标签的目标域上，不是所有数据都适合用于进行源域适应，只有在预训练的源域模型得到的<font color='red'>自熵值较低</font>的样本才是<font color='red'>可靠的</font>（熵值越小，不确定性越低），可用于目标域的训练。</li></ul><h2 id="Contributions-1"><a href="#Contributions-1" class="headerlink" title="Contributions"></a>Contributions</h2><ul><li>为了减少<font color='red'>源域适应时伪标签的不确定性</font>，文章从<font color='red'>度量学习</font>的视角出发，提出基于豪斯多夫距离的过滤来筛选出自信样本，并且该距离是自适应的。</li><li>训练目标域模型时，文章通过预训练的源域模型和根据距离过滤得到置信度较高的伪标签进行<font color='red'>双重约束</font>。</li></ul><h2 id="做法-1"><a href="#做法-1" class="headerlink" title="做法"></a>做法</h2><img src="https://s1.ax1x.com/2022/12/26/zxIkk9.png" alt="zxIkk9.png" border="0" / loading="lazy"><h2 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h2><img src="https://s1.ax1x.com/2022/12/26/zxIm6K.png" alt="zxIm6K.png" border="0" / loading="lazy"><h2 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h2><p>利用预训练的源域模型的主干网络$F_s$和分类器$C_s$去初始化目标域模型的主干网络$F_t$和两个分类器$C_t$、$C_{s2t}$。文中通过预训练模型的分类结果作为伪标签去约束目标域模型。此外，文中还通过不断更新自适应的原型记忆和每个目标域样本特征子集到原型子集的<a href="https://blog.51cto.com/u_15278213/5340925">豪斯多夫距离</a>进行度量。</p><ul><li><p><b>自适应的原型记忆(Adaptive prototype memory, APM)</b></p><p>选择目标域数据中每一类别，归一化自熵最小的样本作为一个集合，选择集合中最大的熵值作为定义多个原型$M_c$的阈值。由于计算一次原型开销比较大，文中设置100个steps周期计算更新APM。</p><img src="https://s1.ax1x.com/2022/12/26/zxo93t.png" alt="zxo93t.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxoPjf.png" alt="zxoPjf.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxoAHg.png" alt="zxoAHg.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxoVEQ.png" alt="zxoVEQ.png" border="0" / loading="lazy"></li><li><p><b>置信度的过滤出目标域的可靠样本（Confidence-base filtering, CD filtering）</b></p><ul><li><p>原型embedding和目标域样本特征之间的相似度为<br><img src="https://s1.ax1x.com/2022/12/26/zxoKg0.png" alt="zxoKg0.png" border="0" / loading="lazy"></a></p><p>通过极大似然估计找到当前目标域样本最相似的类别。</p><img src="https://s1.ax1x.com/2022/12/26/zxoJUJ.png" alt="zxoJUJ.png" border="0" / loading="lazy"></li><li><p>目标域样本特征子集$Q$和原型特征子集$p$之间使用豪斯多夫距离度量，并使用<a href="https://blog.csdn.net/qq_25018077/article/details/127097074">上确界和下确界</a>优化为最大最小值问题，进而<font color='red'>度量出原型$M_c$中最相似的类$M_{t1}$和第二相似的类$M_{t2}$</font>。</p><img src="https://s1.ax1x.com/2022/12/26/zxTSZF.png" alt="zxTSZF.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxT9IJ.png" alt="zxT9IJ.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/26/zxTFR1.png" alt="zxTFR1.png" border="0" / loading="lazy"><p>基于上述距离的定义，可以指定样本选择策略为</p><img src="https://s1.ax1x.com/2022/12/26/zxTJL8.png" alt="zxTJL8.png" border="0" / loading="lazy"></li></ul></li></ul><h2 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h2><p>预训练的源域模型进行伪标签的约束为</p><img src="https://s1.ax1x.com/2022/12/26/zxTrQ0.png" alt="zxTrQ0.png" border="0" / loading="lazy"><p>通过APM中的原型特征空间度量出置信样本的损失为</p><img src="https://s1.ax1x.com/2022/12/26/zxTyLT.png" alt="zxTyLT.png" border="0" / loading="lazy"><p>总的损失函数为</p><p><img src="https://s1.ax1x.com/2022/12/26/zxTceU.png" alt="zxTceU.png" border="0" / loading="lazy"></a></p><h1 id="论文3：Source-Free-Domain-Adaptation-via-Distribution-Estimation"><a href="#论文3：Source-Free-Domain-Adaptation-via-Distribution-Estimation" class="headerlink" title="论文3：Source-Free Domain Adaptation via Distribution Estimation"></a>论文3：Source-Free Domain Adaptation via Distribution Estimation</h1><p>文章题目是《通过分布估计进行无源域数据的域适应》，发表在CVPR 2022，目前citation 4。</p><p>code:无。</p><p>传统的域适应的方法是假设源域和目标域的数据都是可获得的。无源域适应（Source-Free Domain Adaption, SFDA）指在数据不共享的场合，可以通过源域的预训练模型和目标域的数据进行跨域知识迁移。</p><h2 id="Motivation-2"><a href="#Motivation-2" class="headerlink" title="Motivation"></a>Motivation</h2><ul><li>目前的SFDA的方法<font color='grey'>（SHOT:通过最大化互信息和最小化熵来隐式对齐两个域；G-SFDA:通过生成更多目标域的数据来学习目标域的分布；A2Net:通过引入新的分类器利用对抗学习来对齐两个域；SoFA:利用变分自编码器来建模目标域数据的分布。）</font>没有对齐源域和目标域的特征分布来进行域适应。</li><li>许多SFDA的做法是冻结源域的分类器，根据目标域的数据对齐分类器输出的伪标签。本文也是在此基础上，旨在探究更鲁棒的伪标签生成策略和两个域之间的特征对齐方法。</li></ul><h2 id="Contributions-2"><a href="#Contributions-2" class="headerlink" title="Contributions"></a>Contributions</h2><ul><li>对于通过源域预训练模型得到的目标域的特征，使用更鲁棒的伪标签策略（Spherical K-Means聚类）；</li><li>提出源域分布估计（Source Distribution  Estimation ， SDE）来逼近源域分布，<font color='red'>假设源域和目标域的特征的语义信息是一致的</font>，再从逼近的代理分布中采样出代理特征，来使得目标域进行和估计的源域分布进行对齐，从而适应源域模型的分类器。<font color='red'>用代理源域分布取代源域分布，把无源的问题转化为有源</font>。</li></ul><h2 id="做法-2"><a href="#做法-2" class="headerlink" title="做法"></a>做法</h2><img src="https://s1.ax1x.com/2022/12/27/zzPgv8.png" alt="zzPgv8.png" border="0" / loading="lazy"><h2 id="算法流程图-1"><a href="#算法流程图-1" class="headerlink" title="算法流程图"></a>算法流程图</h2><img src="https://s1.ax1x.com/2022/12/27/zzPOrF.png" alt="zzPOrF.png" border="0" / loading="lazy"><h2 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h2><ul><li><b>根据source anchors和spherical k-means clustering来获得鲁棒的伪标签</b><ul><li>目标域的数据经过预训练的源域模型后，对特征进行球形K-Means聚类（超球面利用余弦距离聚类），聚类中心作为source anchors，设置阈值$\tau$进行进行聚类迭代。<img src="https://s1.ax1x.com/2022/12/27/zzPxa9.png" alt="zzPxa9.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/27/zzPz5R.png" alt="zzPz5R.png" border="0" / loading="lazy"></li></ul></li></ul><ul><li><p><B>源域分布估计</b></p><ul><li><p>假设源域的特征服从“类条件多元高斯分布”，$f^s_{i,k}∼N^s_k(μ^s_k,Σ^s_k)$。利用一个代理分布$N^{sur}_k(\hat{μ}^s_k,\hat{Σ}^s_k)$去逼近未知的源域特征分布；</p></li><li><p><b>估计代理分布的均值</b>。使用锚点和目标域的特征均值 $f^t_k$和锚点来估计$\hat{μ}^s_k$；</p><img src="https://s1.ax1x.com/2022/12/27/zzi2J1.png" alt="zzi2J1.png" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2022/12/27/zziRRx.png" alt="zziRRx.png" border="0" / loading="lazy"></li><li><p><b>估计代理分布的方差</b>。<font color='red'>假设源域和目标域的特征的语义信息是一致的</font>，可以利用目标域的统计特性配上采样范围$\gamma$进行估计源域的方差。</p><img src="https://s1.ax1x.com/2022/12/27/zzFUTH.png" alt="zzFUTH.png" border="0" / loading="lazy"><p>得到代理分布算是模拟源域特征的分布。</p><img src="https://s1.ax1x.com/2022/12/27/zzF5pq.png" alt="zzF5pq.png" border="0" / loading="lazy"></li></ul></li></ul><ul><li><p><b>无源域适应</b></p><ul><li><p>从代理分布中采样出源域数据的特征，把无源域适应问题转化为传统的DA问题。</p></li><li><p>使用<a href="https://www.zhihu.com/question/265417875?sort=created">MMD</a><font color='grey'>(Maximum Mean Discrepancy, <a href="https://zhuanlan.zhihu.com/p/163839117">MMD</a>，度量两个分布在再生希尔伯特空间的距离。MMD的基本思想就是，如果两个随机变量的任意阶都相同的话，那么两个分布就是一致的。而当两个分布不相同的话，那么使得两个分布之间差距最大的那个矩应该被用来作为度量两个分布的标准。)</font>作为约束拉近代理源域的特征分布和目标域的特征分布的距离。$k_1$和$k_2$属于总类别中子类别的任意两个类，$f^{sur}$表示代理分布的特征。$n_b$为随机从代理源域分布中采样出$n_b$个特征。</p><img src="https://s1.ax1x.com/2022/12/27/zzkkAH.png" alt="zzkkAH.png" border="0" / loading="lazy"></li><li><p>通过对比域差异（Contrastive Domain Discrepancy, CDD)方法来<font color='red'>显式对齐</font>目标域特征的分布和估计源域的分布，即最小化类内域差异，最大化类间域差异。</p><img src="https://s1.ax1x.com/2023/01/01/pSCgvkj.png" alt="pSCgvkj.png" border="0" / loading="lazy"></li></ul></li></ul><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/singxsy/article/details/124988441">DA-5-Source-Free Domain Adaptation via Distribution Estimation_无CCFA就不改名的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> academic_research </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode_and_JianZhi日常复习</title>
      <link href="/personal_learning/leetcode/leetcode_JianZhi/"/>
      <url>/personal_learning/leetcode/leetcode_JianZhi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p><b>最优子结构</b>：子问题的最优结果推导出更大规模问题的结果。并且子问题之间必须相互独立。</p><p><b>重叠的子问题</b>：通过子问题的重叠性，实现从base case的状态转移。</p><p><font color='red'>遇到求最值的题目，往动态规划方向靠。</font></p><p>明确状态=&gt;dp数组的物理意义=&gt;明确状态转移=&gt;明确base case。动态规划就是从最简单的base case，通过状态的链式反应不断地向后推导。</p><span id="more"></span><h2 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h2><p>给你两个单词 word1和word2，请返回将 word1转换成word2所使用的最少操作数。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符<br>输入：word1 = “horse”, word2 = “ros”<br>输出：3<br>解释：<br>horse -&gt; rorse (将 ‘h’ 替换为 ‘r’)<br>rorse -&gt; rose (删除 ‘r’)<br>rose -&gt; ros (删除 ‘e’)</p><h3 id="递归自顶向下的解法"><a href="#递归自顶向下的解法" class="headerlink" title="递归自顶向下的解法"></a>递归自顶向下的解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归自顶向下的解法</span></span><br><span class="line"><span class="comment">// 备忘录记录重复结果</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(<span class="built_in">string</span> word1, <span class="built_in">string</span> word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = word1.size(), n = word2.size();</span><br><span class="line">    memo.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(word1, m - <span class="number">1</span>, word2, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">string</span> word1, <span class="keyword">int</span> i, <span class="built_in">string</span> word2, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、base case</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">-1</span>)    <span class="keyword">return</span> j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">-1</span>)    <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 字符相同，无需任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (word1[i] == word2[j])</span><br><span class="line">        memo[i][j] =  dp(word1, i - <span class="number">1</span>, word2, j - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 字符不同，进行增删改中次数最少的操作</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        memo[i][j] = min(dp(word1, i, word2, j - <span class="number">1</span>) + <span class="number">1</span>, </span><br><span class="line">        min(dp(word1, i - <span class="number">1</span>, word2, j) + <span class="number">1</span>,</span><br><span class="line">        dp(word1, i - <span class="number">1</span>, word2, j - <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM78-打家劫舍-单路打"><a href="#BM78-打家劫舍-单路打" class="headerlink" title="BM78 打家劫舍(单路打)"></a>BM78 打家劫舍(单路打)</h2><p>你是一个经验丰富的小偷，准备偷沿街的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家；如果偷了第二家，那么就不能偷第一家和第三家。<br>给定一个整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。<br>数据范围：数组长度满足$1≤n≤2×10^5$，数组中每个值满足$1≤num[i]≤5000$</p><p>输入：[1,2,3,4]<br>返回值：6</p><p>说明：最优方案是偷第 2，4 个房间   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    n=nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第1间不偷</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第1间偷</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);s</span><br><span class="line">        dp[i][<span class="number">1</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM79-打家劫舍-循环路偷"><a href="#BM79-打家劫舍-循环路偷" class="headerlink" title="BM79 打家劫舍(循环路偷)"></a>BM79 打家劫舍(循环路偷)</h2><p>你是一个经验丰富的小偷，准备偷沿湖的一排房间，每个房间都存有一定的现金，为了防止被发现，你不能偷相邻的两家，即，如果偷了第一家，就不能再偷第二家，如果偷了第二家，那么就不能偷第一家和第三家。沿湖的房间组成一个闭合的圆形，即第一个房间和最后一个房间视为相邻。<br>给定一个长度为n的整数数组nums，数组中的元素表示每个房间存有的现金数额，请你计算在不被发现的前提下最多的偷窃金额。</p><p>数据范围：数组长度满足$1≤n≤2×10^5$，数组中每个值满足$1≤nums[i]≤5000$<br>输入：[1,3,6]<br>返回值：6<br>说明：由于 1 和 3 是相邻的，因此最优方案是偷第 3 个房间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    n=nums.size();</span><br><span class="line">    <span class="comment">// 偷第一间，不偷最后一间</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp1</span><span class="params">(n<span class="number">-1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    dp1[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    dp1[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp1[<span class="number">1</span>][<span class="number">0</span>]=dp1[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    dp1[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        dp1[i][<span class="number">0</span>]=max(dp1[i<span class="number">-1</span>][<span class="number">0</span>], dp1[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp1[i][<span class="number">1</span>]=dp1[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max1 = max(dp1[n<span class="number">-2</span>][<span class="number">0</span>], dp1[n<span class="number">-2</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不偷第一间</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp2</span><span class="params">(n<span class="number">-1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">-1</span>))</span></span>;</span><br><span class="line">    dp2[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp2[<span class="number">0</span>][<span class="number">1</span>]=nums[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n<span class="number">-1</span>;i++) &#123;</span><br><span class="line">        dp2[i][<span class="number">0</span>]=max(dp2[i<span class="number">-1</span>][<span class="number">0</span>], dp2[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp2[i][<span class="number">1</span>]=dp2[i<span class="number">-1</span>][<span class="number">0</span>]+nums[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> max2=max(dp2[n<span class="number">-2</span>][<span class="number">0</span>], dp2[n<span class="number">-2</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(max1, max2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="地下城游戏"><a href="#地下城游戏" class="headerlink" title="地下城游戏"></a>地下城游戏</h2><p>一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。<br>骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。</p><p>有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。<br>为了尽快到达公主，骑士决定每次只向右或向下移动一步。</p><p>编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。<br>例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。</p><p>| -2 (K) |-3 | 3 |<br>| -5 | -10 | 1 |<br>| 10 | 30 | -5 (P) |</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从结果作为base case出发的dp</span></span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span> </span>&#123;</span><br><span class="line">    m = dungeon.size();</span><br><span class="line">    n = dungeon[<span class="number">0</span>].size();</span><br><span class="line">    memo.resize(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(dungeon, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1、dp状态和dp的物理意义：dp(i, j)——从位置(i,j)到右下角位置最少需要多少生命值</span></span><br><span class="line"><span class="comment">// 2、状态转移方程：dp(i, j) = min(dp(i, j + 1), dp(i + 1, j)) - grid[i, j]</span></span><br><span class="line"><span class="comment">// 3、base case是结果</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == m || j == n)      <span class="keyword">return</span> INT_MAX;</span><br><span class="line">    <span class="keyword">if</span> (i == m - <span class="number">1</span> &amp;&amp; j == n - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> (dungeon[i][j] &lt;= <span class="number">0</span> ? -dungeon[i][j] + <span class="number">1</span>:<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] != <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = min(dp(dungeon, i + <span class="number">1</span>, j), </span><br><span class="line">    dp(dungeon, i, j + <span class="number">1</span>)) - dungeon[i][j];</span><br><span class="line">    memo[i][j] = res &lt;= <span class="number">0</span> ? <span class="number">1</span>:res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ14-剪绳子"><a href="#JZ14-剪绳子" class="headerlink" title="JZ14 剪绳子"></a>JZ14 剪绳子</h2><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n&gt;1 并且 m&gt;1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m]。请问 k[1]×k[2]×…×k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18。<br>数据范围：$2≤n≤60$<br>进阶：空间复杂度 $O(1)$，时间复杂度 $O(n)$<br>输入：8<br>返回值：18<br>说明：<br>8 = 2+3+3, 2×3×3=18 </p><p> dp[i]：长度为i的绳子可以被剪出的最大乘积是dp[i]。 dp[i] = max(dp[i], j*dp[i-j]);</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>, dp[<span class="number">2</span>] = <span class="number">2</span>, dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            dp[i] = max(dp[i], j*dp[i-j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h2><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。<br>测试用例的答案是一个 32-位 整数。<br>子数组 是数组的连续子序列。<br>输入: nums = [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于负数的存在，当出现负数时，需要交替计算最大值和最小值</span></span><br><span class="line"><span class="comment">// 维护一个最大值的变量即可</span></span><br><span class="line"><span class="keyword">int</span> imax=<span class="number">1</span>, imin=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> res=INT_MIN;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            swap(imax, imin);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        imax = max(nums[i], imax*nums[i]);</span><br><span class="line">        imin = min(nums[i], imin*nums[i]);</span><br><span class="line"></span><br><span class="line">        res = max(imax, res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ42-连续子数组的最大和"><a href="#JZ42-连续子数组的最大和" class="headerlink" title="JZ42 连续子数组的最大和"></a>JZ42 连续子数组的最大和</h2><p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，子数组最小长度为1。求所有子数组的和的最大值。<br>数据范围:$1 &lt;= n &lt;= 2×10^5, -100 &lt;= a[i] &lt;= 100$<br>要求:时间复杂度为 $O(n)$，空间复杂度为 $O(n)$<br>输入：[1,-2,3,10,-4,7,2,-5]<br>返回值：18<br>说明：经分析可知，输入数组的子数组[3,10,-4,7,2]可以求得最大和为18。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dp数组含义：dp[i]表示第i个下标结尾时，前面的i个子数组和的最大值</span></span><br><span class="line">    <span class="comment">// 状态：下标为i-1时的前面子数组和的最大值</span></span><br><span class="line">    <span class="comment">// 选择：下一步是选择array[i]，还是选择dp[i-1]</span></span><br><span class="line">    <span class="comment">// 维护一个最大值变量</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="built_in">array</span>.size(), INT_MIN)</span></span>;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max_num = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="built_in">array</span>.size(); i++) &#123;</span><br><span class="line">        dp[i] = max(<span class="built_in">array</span>[i], dp[i<span class="number">-1</span>]+<span class="built_in">array</span>[i]);</span><br><span class="line">        max_num = max(max_num, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_num;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ85-连续子数组的最大和-二"><a href="#JZ85-连续子数组的最大和-二" class="headerlink" title="JZ85 连续子数组的最大和(二)"></a>JZ85 连续子数组的最大和(二)</h2><p>输入一个长度为n的整型数组array，数组中的一个或连续多个整数组成一个子数组，找到一个具有最大和的连续子数组。<br>1.子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组<br>2.如果存在多个最大和的连续子数组，那么返回其中长度最长的，该题数据保证这个最长的只存在一个<br>3.该题定义的子数组的最小长度为1，不存在为空的子数组，即不存在[]是某个数组的子数组<br>4.返回的数组不计入空间复杂度计算</p><p>数据范围:<br>$1&lt;=n&lt;=10^5$<br>$−100&lt;=a[i]&lt;=100$</p><p>要求:时间复杂度$O(n)$，空间复杂度$O(n)$<br>进阶:时间复杂度$O(n)$，空间复杂度$O(1)$</p><p><font color='red'><b>思路：</b></p><ul><li>定义dp[i]:以第i个下标结尾时，前面的i个子数组和的最大值；</li><li>定义左右指针从0出发找到当前下标最大值的区间子数组；</li><li>定义res的左右指针维护最大的左右指针区间；</li><li>最后遍历res的左右指针得到结果。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">array</span>.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res_l = <span class="number">0</span>, res_r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_res = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        right++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dp[i<span class="number">-1</span>] + <span class="built_in">array</span>[i] &lt; <span class="built_in">array</span>[i]) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">            left = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="built_in">array</span>[i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (dp[i] &gt; max_res || (dp[i] == max_res </span><br><span class="line">        &amp;&amp; right - left + <span class="number">1</span> &gt; res_l - res_r + <span class="number">1</span>)) &#123;</span><br><span class="line">            max_res = dp[i];</span><br><span class="line">            res_l = left;</span><br><span class="line">            res_r = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res_l; i &lt;= res_r; i++) &#123;</span><br><span class="line">        res.emplace_back(<span class="built_in">array</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM66-最长公共子串"><a href="#BM66-最长公共子串" class="headerlink" title="BM66 最长公共子串"></a>BM66 最长公共子串</h2><p>给定两个字符串str1和str2,输出两个字符串的最长公共子串<br>题目保证str1和str2的最长公共子串存在且唯一。 </p><p>数据范围：1≤∣str1∣,∣str2∣≤5000<br>要求：空间复杂度$O(n^2)$，时间复杂度$O(n^2)$<br><font color='red'><b>思路：</b></p><ul><li>dp[i][j]表示str2的第j个字符结尾的时候，str1的第i个字符结尾的最长子串的长度；</li><li>如果两个字符相等，则最长长度+1，否则置为0；</li><li>统计最大长度以及最大长度的结束位置。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LCS</span><span class="params">(<span class="built_in">string</span> str1, <span class="built_in">string</span> str2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m=str1.size(), n=str2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">int</span> end=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> max_res=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (max_res &lt; dp[i][j]) &#123;</span><br><span class="line">                max_res=dp[i][j];</span><br><span class="line">                end=i<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> str1.substr(end-max_res+<span class="number">1</span>, max_res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM65-最长公共子序列-二"><a href="#BM65-最长公共子序列-二" class="headerlink" title="BM65 最长公共子序列(二)"></a>BM65 最长公共子序列(二)</h2><p>给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回”-1”。目前给出的数据，仅仅会存在一个最长的公共子序列</p><p>数据范围：$0≤∣str1∣,∣str2∣≤2000$<br>要求：空间复杂度$O(n^2)$，时间复杂度$O(n^2)$<br>输入：”1A2C3D4B56”,”B1D23A456A”<br>返回值：”123456”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：</span></span><br><span class="line"><span class="comment">// 先记下最大的长度</span></span><br><span class="line"><span class="comment">// 通过最大长度反推字符串</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LCS</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">    n=s1.size();</span><br><span class="line">    m=s2.size();</span><br><span class="line">    <span class="comment">// dp[i][j]：表示第i个字符结尾的最大长度</span></span><br><span class="line">    dp.resize(n+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(m+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 反推结果</span></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n,j=m;dp[i][j]&gt;=<span class="number">1</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            res += s1[i<span class="number">-1</span>];</span><br><span class="line">            i--;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j<span class="number">-1</span>] &gt;= dp[i<span class="number">-1</span>][j]) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    reverse(res.begin(), res.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.empty()?<span class="string">&quot;-1&quot;</span>:res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="BM95-分糖果问题"><a href="#BM95-分糖果问题" class="headerlink" title="BM95 分糖果问题"></a>BM95 分糖果问题</h3><p>一群孩子做游戏，现在请你根据游戏得分来发糖果，要求如下：<br>1.每个孩子不管得分多少，起码分到一个糖果。<br>2.任意两个相邻的孩子之间，得分较多的孩子必须拿多一些糖果。(若相同则无此限制)</p><p>给定一个数组 arr 代表得分数组，请返回最少需要多少糖果。<br>要求: 时间复杂度为$O(n)$ 空间复杂度为$O(n)$<br>数据范围：$1≤n≤100000, 1≤a_i≤1000$<br>输入：[1,1,2]<br>返回值：4<br>说明：最优分配方案为1,1,2 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    n=arr.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 从左王右遍历，找出左边的分数高，</span></span><br><span class="line">    <span class="comment">// 遇到分数高的糖果数+1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i]&gt;arr[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            nums[i]=nums[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> total_res=nums[n<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 从右往左遍历，找出左边的分数高，</span></span><br><span class="line">    <span class="comment">// 左边的糖果数少的样本进行更新</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i]&gt;arr[i+<span class="number">1</span>] &amp;&amp; nums[i]&lt;=nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            nums[i] = nums[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total_res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total_res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">getline(<span class="built_in">cin</span>, str);</span><br><span class="line"><span class="keyword">int</span> t=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.size();i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str[i]==<span class="string">&#x27;,&#x27;</span>) &#123;</span><br><span class="line">        arr.emplace_back(t);</span><br><span class="line">        t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    t=t*<span class="number">10</span>+(str[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">arr.emplace_back(t);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// for (int i=0;i&lt;arr.size();i++) &#123;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; arr[i] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; candy(arr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><h4 id="BM80-买卖股票-买卖一次"><a href="#BM80-买卖股票-买卖一次" class="headerlink" title="BM80 买卖股票(买卖一次)"></a>BM80 买卖股票(买卖一次)</h4><p>假设你有一个数组prices，长度为n，其中prices[i]是股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益<br>1.你可以买入一次股票和卖出一次股票，并非每天都可以买入或卖出一次，总共只能买入和卖出一次，且买入必须在卖出的前面的某一天<br>2.如果不能获取到任何利润，请返回0<br>3.假设买入卖出均无手续费<br>数据范围：$0≤val≤10^5, 0≤val≤10^4$<br>要求：空间复杂度$O(1)$，时间复杂度$O(n)$</p><p>输入：[8,9,2,5,4,7,1]<br>返回值：5<br>说明：在第3天(股票价格 = 2)的时候买入，在第6天(股票价格 = 7)的时候卖出，最大利润 = 7-2 = 5 ，不能选择在第2天买入，第3天卖出，这样就亏损7了；同时，你也不能在买入前卖出股票。 </p><p><font color='red'><b>思路：</b></p><ul><li>维护一个购买的变量使得它的值最小；</li><li>维护一个总收益最大。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=prices.size();</span><br><span class="line">    <span class="keyword">int</span> buy=prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; buy) &#123;</span><br><span class="line">            buy = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res=max(res, prices[i]-buy);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BM81-买卖股票-买卖无限次"><a href="#BM81-买卖股票-买卖无限次" class="headerlink" title="BM81 买卖股票(买卖无限次)"></a>BM81 买卖股票(买卖无限次)</h4><p>假设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p><ol><li>你可以多次买卖该只股票，但是再次购买前必须卖出之前的股票</li><li>如果不能获取收益，请返回0</li><li>假设买入卖出均无手续费</li></ol><p>数据范围：$1≤n≤1×10^5, 1≤prices[i]≤10^4$</p><p>要求：空间复杂度$O(n)$，时间复杂度$O(n)$<br>进阶：空间复杂度$O(1)$，时间复杂度$O(n)$</p><p>输入：[8,9,2,5,4,7,1]<br>返回值：7<br>说明：<br>在第1天(股票价格=8)买入，第2天(股票价格=9)卖出，获利9-8=1<br>在第3天(股票价格=2)买入，第4天(股票价格=5)卖出，获利5-2=3<br>在第5天(股票价格=4)买入，第6天(股票价格=7)卖出，获利7-4=3<br>总获利1+3+3=7，返回7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    n=prices.size();</span><br><span class="line">    <span class="comment">// dp[i][0]:表示第i天没有股票的收益；</span></span><br><span class="line">    <span class="comment">// dp[i][1]:表示第i天有股票的收益；</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 第1天无股票的收益是0；</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第1天有股票的收益是-price[i]；</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="BM82-买卖股票-最多买卖两次"><a href="#BM82-买卖股票-最多买卖两次" class="headerlink" title="BM82 买卖股票(最多买卖两次)"></a>BM82 买卖股票(最多买卖两次)</h4><p>设你有一个数组prices，长度为n，其中prices[i]是某只股票在第i天的价格，请根据这个价格数组，返回买卖股票能获得的最大收益</p><ol><li>你最多可以对该股票有两笔交易操作，一笔交易代表着一次买入与一次卖出，但是再次购买前必须卖出之前的股票</li><li>如果不能获取收益，请返回0</li><li>假设买入卖出均无手续费</li></ol><p>数据范围：$1≤n≤10^5$，股票的价格满足$1≤val≤10^4$</p><p>要求: 空间复杂度$O(n)$，时间复杂度$O(n)$<br>进阶：空间复杂度$O(1)$，时间复杂度$O(n)$</p><p>输入：[8,9,3,5,1,3]<br>返回值：4<br>说明：第三天(股票价格=3)买进，第四天(股票价格=5)卖出，收益为2<br>第五天(股票价格=1)买进，第六天(股票价格=3)卖出，收益为2<br>总收益为4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    n=prices.size();</span><br><span class="line">    <span class="comment">// 注意：股票价格最高有10^4</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">-10000</span>))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>]=-prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>]=dp[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">        dp[i][<span class="number">1</span>]=max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>]=max(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]);</span><br><span class="line">        dp[i][<span class="number">3</span>]=max(dp[i<span class="number">-1</span>][<span class="number">3</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">        dp[i][<span class="number">4</span>]=max(dp[i<span class="number">-1</span>][<span class="number">4</span>], dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max(dp[n<span class="number">-1</span>][<span class="number">2</span>], max(<span class="number">0</span>, dp[n<span class="number">-1</span>][<span class="number">4</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区间调度问题"><a href="#区间调度问题" class="headerlink" title="区间调度问题"></a>区间调度问题</h3><p>贪心算法可以认为是动态规划算法的一个<b>特例</b>，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质）。</p><p>贪心选择性质：<font color='red'>每一步都做出一个局部最优的选择，最终的结果就是全局最优。</font>只有一部分问题拥有这个性质。</p><p>思路：<b>给你输入若干时间区间，让你计算同一时刻「最多」有几个区间重叠</b>。</p><ul><li>x_end或者x_start按升序排序；</li><li>统计后面区间个数和关系，更新x_end或者x_start。</li></ul><h4 id="无重叠区间（右端点升序）"><a href="#无重叠区间（右端点升序）" class="headerlink" title="无重叠区间（右端点升序）"></a>无重叠区间（右端点升序）</h4><p>给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。</p><p>输入: intervals = [[1,2],[2,3],[3,4],[1,3]]<br>输出: 1<br>解释: 移除 [1,3] 后，剩下的区间没有重叠。</p><p><font color='red'><b>思路：</b></p><ul><li>按右端点进行升序排列；</li><li>统计有几个相互不交叉的区间；</li><li>总区间长度减去相互不交叉的区间个数。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找至多有几个区间互不重叠</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 寻找至多有几个区间互不重叠，要将end按升序排列</span></span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> x_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 至少有一个区间不重叠</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = interval[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            x_end = interval[<span class="number">1</span>];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到至少要移除几个区间</span></span><br><span class="line">    <span class="keyword">return</span> intervals.size() - cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用最少数量的箭引爆气球（右端点升序）"><a href="#用最少数量的箭引爆气球（右端点升序）" class="headerlink" title="用最少数量的箭引爆气球（右端点升序）"></a>用最少数量的箭引爆气球（右端点升序）</h4><p>有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。</p><p>一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。</p><p>给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。<br>输入：points = [[1,2],[2,3],[3,4],[4,5]]<br>输出：2<br>解释：气球可以用2支箭来爆破:</p><ul><li>在x = 2处发射箭，击破气球[1,2]和[2,3]。</li><li>在x = 4处射出箭，击破气球[3,4]和[4,5]。</li></ul><p><font color='red'><b>思路：</b></p><ul><li>该问题可转化为至多有几个不相交的子区间；</li><li>按照右端点升序排列好；</li><li>统计相互不相交的区间的个数。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该问题可转化为至多有几个不重叠的区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">    sort(points.begin(), points.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x_end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;point:points) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = point[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (start &gt; x_end) &#123;</span><br><span class="line">            x_end = point[<span class="number">1</span>];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视频拼接（左端点升序-左端点相等右端点降序）"><a href="#视频拼接（左端点升序-左端点相等右端点降序）" class="headerlink" title="视频拼接（左端点升序+左端点相等右端点降序）"></a>视频拼接（左端点升序+左端点相等右端点降序）</h4><p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 time 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。使用数组 clips 描述所有的视频片段，其中 clips[i] = [starti, endi] 表示：某个视频片段开始于 starti 并于 endi 结束。</p><p>甚至可以对这些片段自由地再剪辑：<br>例如，片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。<br>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, time]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。</p><p>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10<br>输出：3<br>解释：<br>选中 [0,2], [8,10], [1,9] 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。<br>现在手上的片段为 [0,2] + [2,8] + [8,10]，而这些覆盖了整场比赛 [0, 10]。</p><p><font color='red'><b>思路：</b></p><ul><li>先对序列进行左端点升序排序，如果左端点相等则右端点降序排序；</li><li>将当前的右端点curEnd和区间的右端点比较，不断更新记录最大的nextEnd右端点；</li><li>更新当前的端点curEnd以及统计最长序列的出现次数；</li><li>判断当前的端点curEnd的值是否大于等于总时长。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> a[<span class="number">0</span>] == b[<span class="number">0</span>] ? a[<span class="number">1</span>] &gt; b[<span class="number">1</span>]:a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">videoStitching</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; clips, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    sort(clips.begin(), clips.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, n = clips.size();</span><br><span class="line">    <span class="keyword">int</span> curEnd = <span class="number">0</span>, nextEnd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; curEnd &gt;= clips[i][<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="comment">// 贪心下一个区间的最大长度</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; n &amp;&amp; curEnd &gt;= clips[i][<span class="number">0</span>]) &#123;</span><br><span class="line">            nextEnd = max(nextEnd, clips[i][<span class="number">1</span>]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">        curEnd = nextEnd;</span><br><span class="line">        <span class="keyword">if</span> (curEnd &gt;= time) &#123;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h4><p>区间问题的思路：</p><ul><li>对区间的每个起点进行升序排序（起点相同时，终点进行降序排序）；</li><li>根据排序后的区间进行画图，找出相邻区间被覆盖，相交，不相交的端点进行解题。</li></ul><h5 id="删掉被覆盖的区间"><a href="#删掉被覆盖的区间" class="headerlink" title="删掉被覆盖的区间"></a>删掉被覆盖的区间</h5><p>给你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p><p>只有当 c &lt;= a 且 b &lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。</p><p>在完成所有删除操作后，请你返回列表中剩余区间的数目。<br>你一个区间列表，请你删除列表中被其他区间所覆盖的区间。</p><p>只有当 c &lt;= a 且 b &lt;= d 时，我们才认为区间 [a,b) 被区间 [c,d) 覆盖。</p><p>在完成所有删除操作后，请你返回列表中剩余区间的数目。<br>1 &lt;= intervals.length &lt;= 1000<br>0 &lt;= intervals[i][0] &lt; intervals[i][1] &lt;= 10^5<br>对于所有的 i != j：intervals[i] != intervals[j]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; o1, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o1[<span class="number">1</span>] &gt; o2[<span class="number">1</span>] : o1[<span class="number">0</span>] &lt; o2[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeCoveredIntervals</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), cmp());</span><br><span class="line">        <span class="keyword">int</span> left = intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">interval</span><span class="params">(intervals[i])</span></span>;</span><br><span class="line">            <span class="comment">// 该区间被上一个区间覆盖</span></span><br><span class="line">            <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt;= left &amp;&amp; interval[<span class="number">1</span>] &lt;= right) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该区间和上一个区间相交</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt;= left &amp;&amp; interval[<span class="number">0</span>] &lt;= right) &#123;</span><br><span class="line">                right = interval[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该区间和上一个区间无交集</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (interval[<span class="number">0</span>] &gt; right) &#123;</span><br><span class="line">                left = interval[<span class="number">0</span>];</span><br><span class="line">                right = interval[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> intervals.size() - res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h5><p>对区间的起点进行升序排序后，找出相交区间的终点的最大端点进行更新即可。</p><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。<br>输入：intervals = [[1,3],[2,6],[8,10],[15,18]]<br>输出：[[1,6],[8,10],[15,18]]<br>解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> A[<span class="number">0</span>] &lt; B[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.size()==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    res.emplace_back(intervals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;intervals.size();i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (res.back()[<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">            res.back()[<span class="number">1</span>] = max(res.back()[<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res.emplace_back(intervals[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="区间的交集"><a href="#区间的交集" class="headerlink" title="区间的交集"></a>区间的交集</h5><p>给定两个由一些闭区间组成的列表，firstList 和 secondList ，其中 firstList[i] = [starti, endi] 而 secondList[j] = [startj, endj] 。每个区间列表都是成对不相交的，并且已经排序。<br>返回这两个区间列表的交集。<br>形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b 。</p><p>两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">intervalIntersection</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; firstList, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; secondList)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; firstList.size() &amp;&amp; j &lt; secondList.size()) &#123;</span><br><span class="line">        temp.clear();</span><br><span class="line">        <span class="keyword">int</span> a1 = firstList[i][<span class="number">0</span>], a2 = firstList[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> b1 = secondList[j][<span class="number">0</span>], b2 = secondList[j][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a2&gt;b1 || a1&gt;b2的逆否命题</span></span><br><span class="line">        <span class="keyword">if</span> (a2 &gt;= b1 &amp;&amp; a1 &lt;= b2) &#123;</span><br><span class="line">            temp.emplace_back(max(a1,  b1));</span><br><span class="line">            temp.emplace_back(min(a2,  b2));</span><br><span class="line">            res.emplace_back(temp);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (b2 &gt; a2) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="会议室I（左端点升序）"><a href="#会议室I（左端点升序）" class="headerlink" title="会议室I（左端点升序）"></a>会议室I（左端点升序）</h4><p>给定一系列的会议时间间隔，包括起始和结束时间[[s1,e1]，[s2,e2]，…(si &lt; ei)，确定一个人是否可以参加所有会议。<br>(0,8),(8,10)在8这一时刻不冲突</p><p>输入: intervals = [(5,8),(9,15)]<br>输出: true<br>解释:这两个时间段不会冲突</p><p><font color='red'><b>思路：</b></p><ul><li>题目本质是看任意相邻的两个区间是否有重叠；</li><li>将序列的左端点进行升序排列；</li><li>判断相邻的两个区间是否有重叠即可。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> Interval &amp; a, <span class="keyword">const</span> Interval &amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.start &lt; b.start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 求任意两个区间是否有交叉。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canAttendMeetings</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intervals.size() == <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    sort(intervals.begin(), intervals.end(), cmp);</span><br><span class="line">    <span class="keyword">int</span> x_end = intervals[<span class="number">0</span>].end;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> start = intervals[i].start;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= x_end) &#123;</span><br><span class="line">            x_end = intervals[i].end;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="会议室II（扫描线法）"><a href="#会议室II（扫描线法）" class="headerlink" title="会议室II（扫描线法）"></a>会议室II（扫描线法）</h4><p>给定一系列的会议时间间隔intervals，包括起始和结束时间[[s1,e1],[s2,e2],…] (si &lt; ei)，找到所需的最小的会议室数量。<br>(0,8),(8,10)在8这一时刻不冲突<br>输入: intervals = [(0,30),(5,10),(15,20)]<br>输出: 2<br>解释:<br>需要两个会议室<br>会议室1:(0,30)<br>会议室2:(5,10),(15,20)</p><p><font color='red'><b>思路：</b></p><ul><li>题目的本质是求解同一时刻，最多有几个区间相交；</li><li>单独取出各个会议的左右端点进行升序排序；</li><li>利用双指针的扫描线法分别扫描左右端点，如果比右端点大，则计数加1，否则计数减一；</li><li>维护一个最大值的变量。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(<span class="built_in">vector</span>&lt;Interval&gt; &amp;intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">start</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">end</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        start[i] = intervals[i].start;</span><br><span class="line">        end[i] = intervals[i].end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(start.begin(), start.end());</span><br><span class="line">    sort(end.begin(), end.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (start[i] &lt; end[j]) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="跳跃游戏I"><a href="#跳跃游戏I" class="headerlink" title="跳跃游戏I"></a>跳跃游戏I</h3><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。<br>输入：nums = [2,3,1,1,4]<br>输出：true<br>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p><p><font color='red'><b>思路：</b></p><ul><li>题目的本质是最大化每一次跳跃的最大长度；</li><li>维护每次跳跃最远的距离；</li><li>如果当前位置大于跳跃最远的位置，则表示无法到达最后一个下标。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fartherest = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 1、贪心每一次跳的位置，每一次要跳的足够远，</span></span><br><span class="line">        <span class="comment">// 维护每个位置的可跳跃的最大长度</span></span><br><span class="line">        fartherest = max(fartherest, i + nums[i]);</span><br><span class="line">        <span class="comment">// 2、跳不过0值的时候不能达到最后一个下标</span></span><br><span class="line">        <span class="keyword">if</span> (fartherest &lt;= i) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏II"><a href="#跳跃游戏II" class="headerlink" title="跳跃游戏II"></a>跳跃游戏II</h3><p>给你一个非负整数数组 nums ，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。</p><p>假设你总是可以到达数组的最后一个位置。</p><p>输入: nums = [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><h4 id="dp数组解法"><a href="#dp数组解法" class="headerlink" title="dp数组解法"></a>dp数组解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="comment">// dp数组：从0跳到i的最少步数为dp[i]</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 当前位置超过i的位置时才更新dp数组</span></span><br><span class="line">            <span class="keyword">if</span> (j + nums[j] &gt;= i)</span><br><span class="line">                dp[i] = min(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dp函数解法"><a href="#dp函数解法" class="headerlink" title="dp函数解法"></a>dp函数解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    memo.resize(nums.size(), nums.size());</span><br><span class="line">    <span class="keyword">return</span> dp(nums, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (cur &gt;= nums.size() - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理重复子问题</span></span><br><span class="line">    <span class="keyword">if</span> (memo[cur] != nums.size())</span><br><span class="line">        <span class="keyword">return</span> memo[cur];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> steps = nums[cur];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= steps; i++) &#123;</span><br><span class="line">        <span class="comment">// 存在更小的跳跃次数则更新</span></span><br><span class="line">        memo[cur] = min(memo[cur], dp(nums, cur + i) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[cur];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fartherest = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录这次起跳的右边界，表示起跳点到右边界的任何一点的step都等于1</span></span><br><span class="line">    <span class="keyword">int</span> end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        fartherest = max(fartherest, i + nums[i]);</span><br><span class="line">        <span class="comment">// 如果到达右边界，则进行下一次起跳，记录下一次的右边界是多少</span></span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            step++;</span><br><span class="line">            end = fartherest;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ71-跳台阶扩展问题"><a href="#JZ71-跳台阶扩展问题" class="headerlink" title="JZ71 跳台阶扩展问题"></a>JZ71 跳台阶扩展问题</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶(n为正整数)总共有多少种跳法。<br>数据范围：$1≤n≤20$<br>进阶：空间复杂度 $O(1)$， 时间复杂度$O(1)$<br><b>解题关键：每个台阶的方案数是前一个台阶的2倍数。</b></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(number+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++) &#123;</span><br><span class="line">        dp[i] = <span class="number">2</span> * dp[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[number];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ19-正则表达式匹配"><a href="#JZ19-正则表达式匹配" class="headerlink" title="JZ19 正则表达式匹配"></a>JZ19 正则表达式匹配</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code> 和 <code>&#39;*&#39;</code> 的正则表达式匹配。</p><p><code>&#39;.&#39;</code>：匹配任意单个字符<br><code>&#39;*&#39;</code>：匹配零个或多个前面的那一个元素<br>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><p>输入：s = “aa”, p = “a*”<br>输出：true<br>解释：因为 <code>&#39;*&#39;</code> 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 <code>&#39;a&#39;</code>。因此，字符串 <code>&quot;aa&quot;</code> 可被视为 <code>&#39;a&#39;</code> 重复了一次。</p><h3 id="dp数组解法-1"><a href="#dp数组解法-1" class="headerlink" title="dp数组解法"></a>dp数组解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="built_in">string</span> str, <span class="built_in">string</span> pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = str.size(), n2 = pattern.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; <span class="title">dp</span><span class="params">(n1+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n2+<span class="number">1</span>, <span class="literal">false</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = (i == <span class="number">0</span> ? <span class="literal">true</span>:<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pattern[j<span class="number">-1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (pattern[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span> ||</span><br><span class="line">                     str[i<span class="number">-1</span>] == pattern[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                        dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; </span><br><span class="line">                    (pattern[j<span class="number">-2</span>] == str[i<span class="number">-1</span>] </span><br><span class="line">                    || pattern[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">                        dp[i][j] = (dp[i<span class="number">-1</span>][j] || dp[i][j<span class="number">-2</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dp函数解法-1"><a href="#dp函数解法-1" class="headerlink" title="dp函数解法"></a>dp函数解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="keyword">bool</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMatch</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> p)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    m = s.size();</span><br><span class="line">    n = p.size();</span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dp</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> i, <span class="built_in">string</span> p, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (j == n)</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断模式串是否是a*b*c*的形式</span></span><br><span class="line">        <span class="keyword">for</span> (;j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消除重叠的子问题</span></span><br><span class="line">    <span class="keyword">if</span> (memo.count(<span class="built_in">make_pair</span>(i, j))) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="built_in">make_pair</span>(i, j)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配0个或多个字符串</span></span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>) || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 两两匹配</span></span><br><span class="line">            res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// *匹配0个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[<span class="built_in">make_pair</span>(i, j)] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><p>输入：nums = [10,9,2,5,3,7,101,18]<br>输出：4<br>解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。<br>$1 &lt;= nums.length &lt;= 2500$<br>$-104 &lt;= nums[i] &lt;= 104$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DP数组的物理意义：以num[i]为结尾的子序列的长度</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 状态转移：num[i-1]的子序列的长度计算</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h2><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p><p>说明：每次只能向下或者向右移动一步。<br>$m == grid.length$<br>$n == grid[i].length$<br>$1 &lt;= m, n &lt;= 200$<br>$0 &lt;= grid[i][j] &lt;= 100$<br>此题直接用DFS会超时，采用二维DP比较简单。</p><h3 id="dp数组解法-2"><a href="#dp数组解法-2" class="headerlink" title="dp数组解法"></a>dp数组解法</h3><p>明确状态=&gt;DP数组的物理意义=&gt;base case=&gt;状态转移</p><ul><li>初始化第0行和第0列的某个位置的最短路径；</li><li>状态dp[i][j]：走到第i行和第j列的最短路径；</li><li>选择：下一步时选择dp[i-1][j]还是dp[i][j-1]来加上grid[i][j]。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp[][]数组的物理意义：从(0,0)走到位置(i,j)的最短路径</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n))</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j], </span><br><span class="line">            dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自由之路"><a href="#自由之路" class="headerlink" title="自由之路"></a>自由之路</h2><p>电子游戏“辐射4”中，任务 “通向自由” 要求玩家到达名为 “Freedom Trail Ring” 的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。</p><p>最初，ring 的第一个字符与 12:00 方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。</p><p>旋转 ring 拼出 key 字符 key[i] 的阶段中：</p><p>您可以将 ring 顺时针或逆时针旋转 一个位置 ，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。<br>如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。 </p><p>输入: ring = “godding”, key = “gd”<br>输出: 4<br>解释:<br> 对于 key 的第一个字符 ‘g’，已经在正确的位置, 我们只需要1步来拼写这个字符。<br> 对于 key 的第二个字符 ‘d’，我们需要逆时针旋转 ring “godding” 2步使它变成 “ddinggo”。<br> 当然, 我们还需要1步进行拼写。<br> 因此最终的输出是 4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; s_to_index;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRotateSteps</span><span class="params">(<span class="built_in">string</span> ring, <span class="built_in">string</span> key)</span> </span>&#123;</span><br><span class="line">    memo.resize(ring.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(key.size(), <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ring.size(); i++) &#123;</span><br><span class="line">        s_to_index[ring[i]].emplace_back(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(ring, <span class="number">0</span>, key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1、状态：圆盘指针所指的位置和当前的输入字符</span></span><br><span class="line"><span class="comment">// 2、dp的物理意义：当圆盘指针指向ring[i]时，</span></span><br><span class="line"><span class="comment">// 输入字符串key[j..]的最少操作数为dp(ring, i, key, j)</span></span><br><span class="line"><span class="comment">// 3、base case</span></span><br><span class="line"><span class="comment">// 4、选择：该往顺时针走还是逆时针走</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="built_in">string</span> ring, <span class="keyword">int</span> i, <span class="built_in">string</span> key, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (j == key.size())    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo[i][j] != <span class="number">0</span>)    <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> k: s_to_index[key[j]]) &#123;</span><br><span class="line">        <span class="keyword">int</span> delta = <span class="built_in">abs</span>(k - i);</span><br><span class="line">        <span class="keyword">int</span> n = ring.size();</span><br><span class="line">        <span class="comment">// 选择顺时针还是逆时针</span></span><br><span class="line">        delta = min(delta, n - delta);</span><br><span class="line">        <span class="comment">// 将指针拨到ring[k]，继续输入key[j+1...]</span></span><br><span class="line">        <span class="keyword">int</span> subProblem = dp(ring, k, key, j+<span class="number">1</span>);</span><br><span class="line">        res = min(res, subProblem + <span class="number">1</span> + delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[i][j] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM64-最小花费爬楼梯"><a href="#BM64-最小花费爬楼梯" class="headerlink" title="BM64 最小花费爬楼梯"></a>BM64 最小花费爬楼梯</h2><p>给定一个整数数组<code>cost</code>，其中<code>cost[i]</code>是从楼梯第i个台阶向上爬需要支付的费用，下标从0开始。一旦你支付此费用，即可选择向上爬一个或者两个台阶。<br>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。<br>数据范围：数组长度满足$1≤n≤10^5$，数组中的值满足$1≤cost≤10^4$<br>输入：[2,5,20]<br>返回值：5<br>说明：你将从下标为1的台阶开始，支付5 ，向上爬两个台阶，到达楼梯顶部。总花费为5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">    n=cost.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;i++) &#123;</span><br><span class="line">        <span class="comment">// 当前的状态可由上一级走一步或者上两级走两步得到</span></span><br><span class="line">        dp[i]=min(dp[i<span class="number">-1</span>]+cost[i<span class="number">-1</span>], dp[i<span class="number">-2</span>]+cost[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="BM22-比较版本号"><a href="#BM22-比较版本号" class="headerlink" title="BM22 比较版本号"></a>BM22 比较版本号</h2><p>比较规则：<br>一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如”0.1”和”0.01”的版本号是相等的<br>二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，”1.1”的版本号小于”1.1.1”。因为”1.1”的版本号相当于”1.1.0”，第3位修订号的下标为0，小于1<br>三. <code>version1</code>&gt;<code>version2</code> 返回1，如果<code>version1</code>&lt;<code>version2</code>返回-1，不然返回0.</p><p>数据范围：<br>1 &lt;= version1.length, version2.length &lt;= 1000<br><code>version1</code>和<code>version2</code>的修订号不会超过int的表达范围，即不超过32位整数的范围</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="built_in">string</span> version1, <span class="built_in">string</span> version2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1=version1.size(), len2=version2.size();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>, j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;len1 || j&lt;len2) &#123;</span><br><span class="line">        <span class="comment">// 比较小数点之间的数字</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num1=<span class="number">0</span>, num2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (version1[i]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; i&lt;len1) &#123;</span><br><span class="line">            num1=num1*<span class="number">10</span> + (version1[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (version2[j]!=<span class="string">&#x27;.&#x27;</span> &amp;&amp; j&lt;len2) &#123;</span><br><span class="line">            num2=num2*<span class="number">10</span> +(version2[j]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (num1&gt;num2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num1&lt;num2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口问题"><a href="#滑动窗口问题" class="headerlink" title="滑动窗口问题"></a>滑动窗口问题</h2><h3 id="最长无重复子串"><a href="#最长无重复子串" class="headerlink" title="最长无重复子串"></a>最长无重复子串</h3><p>给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。<br>输入: s = “abcabcbb”<br>输出: 3<br>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解法：滑动窗口+统计字符个数</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">    n=s.size();</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; n) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1=s[right];</span><br><span class="line">        <span class="keyword">if</span> (!window.count(c1) || window[c1] == <span class="number">0</span>) &#123;</span><br><span class="line">            window[c1]++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> c2=s[left];</span><br><span class="line">            window[c2]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = max(res, right-left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并两个有序的数组"><a href="#合并两个有序的数组" class="headerlink" title="合并两个有序的数组"></a>合并两个有序的数组</h2><p>给出一个有序的整数数组 A 和有序的整数数组 B ，请将数组 B 合并到数组 A 中，变成一个有序的升序数组<br>数据范围：$0≤n,m≤100$，$|A_i| &lt;=100，|B_i| &lt;= 100$<br>​<br>注意：<br>1.保证 A 数组有足够的空间存放 B 数组的元素， A 和 B 中初始的元素数目分别为 m 和 n，A的数组空间大小为 m+n<br>2.不要返回合并的数组，将数组 B 的数据合并到 A 里面就好了，且后台会自动将合并后的数组 A 的内容打印出来，所以也不需要自己打印<br>3.A 数组在[0,m-1]的范围也是有序的<br>输入：[4,5,6],[1,2,3]<br>返回值：[1,2,3,4,5,6]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：使用3个指针，一个指向A的最大值，一个指向B的最大值，</span></span><br><span class="line"><span class="comment">// 一个指向辅助数组的末尾，从后往前添加</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> m, <span class="keyword">int</span> B[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=m<span class="number">-1</span>, j=n<span class="number">-1</span>, k=m+n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt; B[j]) &#123;</span><br><span class="line">            A[k]=A[i];</span><br><span class="line">            i--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            A[k]=B[j];</span><br><span class="line">            j--;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (j&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        A[k]=B[j];</span><br><span class="line">        j--;</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。<br>你可以按任意顺序返回答案。</p><p>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><h3 id="哈希表解法"><a href="#哈希表解法" class="headerlink" title="哈希表解法"></a>哈希表解法</h3><p>时间O(n)，空间O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.count(nums[i])) &#123;</span><br><span class="line">            res.emplace_back(memo[nums[i]]);</span><br><span class="line">            res.emplace_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            memo[target - nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM53-缺失的第一个正整数"><a href="#BM53-缺失的第一个正整数" class="headerlink" title="BM53 缺失的第一个正整数"></a>BM53 缺失的第一个正整数</h2><p>给定一个未排序的整数数组nums，请你找出其中没有出现的最小的正整数<br>进阶： 空间复杂度$O(1)$，时间复杂度$O(n)$</p><p>数据范围:<br>$-2^31&lt;=nums[i]&lt;=2^31-1$<br>$0&lt;=len(nums)&lt;=5*10^5$<br>输入：[-2,3,4,1,5]<br>返回值：2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberDisappeared</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    n=nums.size();</span><br><span class="line">    <span class="comment">// 记录当前数组的哈希情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">        memo[nums[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从正整数1开始寻找，直到找不到某个res为止</span></span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (memo.find(res)!=memo.end()) &#123;</span><br><span class="line">        res++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h2><h3 id="排序-双指针法"><a href="#排序-双指针法" class="headerlink" title="排序+双指针法"></a>排序+双指针法</h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>输入：nums = [-1,0,1,2,-1,-4]<br>输出：[[-1,-1,2],[-1,0,1]]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解题思路：</span></span><br><span class="line"><span class="comment">// 1. 三数求和首先讲序列进行排序，然后从第一个数字出发，</span></span><br><span class="line"><span class="comment">// 固定第一个数字，把题目当成两数之和问题进行求解。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">threeSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i]) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.push_back(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">                <span class="comment">// 避免统计到重复的元素</span></span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left<span class="number">-1</span>])  </span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right+<span class="number">1</span>])  </span><br><span class="line">                    right--;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ51-数组中的逆序对"><a href="#JZ51-数组中的逆序对" class="headerlink" title="JZ51 数组中的逆序对"></a>JZ51 数组中的逆序对</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007<br>数据范围：对于50%的数据, size≤10^4<br>对于100%的数据, size≤10^5<br>数组中所有数字的值满足0≤val≤1000000</p><p>要求：空间复杂度O(n)，时间复杂度O(nlogn)<br>输入描述：<br>题目保证输入的数组中没有的相同的数字</p><p>输入：[1,2,3,4,5,6,7,0]<br>返回值：7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//停止划分</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//取中间</span></span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>; </span><br><span class="line">    <span class="comment">//左右划分合并</span></span><br><span class="line">    <span class="keyword">int</span> res = mergeSort(left, mid, data, temp) + mergeSort(mid + <span class="number">1</span>, right, data, temp); </span><br><span class="line">    <span class="comment">//防止溢出</span></span><br><span class="line">    res %= mod;  </span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; k++)</span><br><span class="line">        temp[k] = data[k];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = left; k &lt;= right; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == mid + <span class="number">1</span>)</span><br><span class="line">            data[k] = temp[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == right + <span class="number">1</span> || temp[i] &lt;= temp[j])</span><br><span class="line">            data[k] = temp[i++];</span><br><span class="line">        <span class="comment">//左边比右边大，答案增加</span></span><br><span class="line">        <span class="keyword">else</span>&#123; </span><br><span class="line">            data[k] = temp[j++];</span><br><span class="line">            <span class="comment">//统计逆序对</span></span><br><span class="line">            res += mid - i + <span class="number">1</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = data.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> mergeSort(<span class="number">0</span>, n - <span class="number">1</span>, data, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM97-旋转数组"><a href="#BM97-旋转数组" class="headerlink" title="BM97 旋转数组"></a>BM97 旋转数组</h2><p>一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移$M（ M &gt;=0）$个位置，即将A中的数据由$（A_0 A_1 ……A_{N-1} ）$变换为$（A_{N-M} …… A_{N-1} A_0 A_1 ……A_{N-M-1} ）$（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？<br>数据范围：$0&lt;n≤100，0≤m≤1000$<br>进阶：空间复杂度$O(1)$，时间复杂度$O(n)$<br>输入：6,2,[1,2,3,4,5,6]<br>返回值：[5,6,1,2,3,4]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：3次翻转数组，第一次整体翻转，第二次m部分翻转，第三次n-m部分翻转</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a)</span> </span>&#123;</span><br><span class="line">    m %= n;</span><br><span class="line">    reverse(a.begin(), a.end()); </span><br><span class="line">    reverse(a.begin(), a.begin()+m);</span><br><span class="line">    reverse(a.begin()+m, a.end());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="JZ58-左旋字符串"><a href="#JZ58-左旋字符串" class="headerlink" title="JZ58 左旋字符串"></a>JZ58 左旋字符串</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列  S ，请你把其循环左移 K 位后的序列输出。例如，字符序列 S = ”abcXYZdef” , 要求输出循环左移 3 位后的结果，即 “XYZdefabc”</p><p>数据范围：输入的字符串长度满足 0≤len≤100, 0≤n≤100<br>进阶：空间复杂度O(n) ，时间复杂度O(n)<br>“abcXYZdef”,3<br>“XYZdefabc”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">LeftRotateString</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>)    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> move = n % str.size();</span><br><span class="line">    <span class="built_in">stringstream</span> ss1, ss2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; move) &#123;</span><br><span class="line">            ss1 &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ss2 &lt;&lt; str[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ss2.str() + ss1.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。<br>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。</p><p><font color='red'><b>思路：</b></p><ul><li>枚举每个字符，以每个字符为中心，或者以该字符和下一个字符为中心，向左右拓展进行长度统计；</li><li>记录下长的回文子串的长度。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l, r;</span><br><span class="line"><span class="keyword">int</span> start=<span class="number">0</span>, end=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expandAroundCenter</span><span class="params">(<span class="built_in">string</span>&amp; s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    l = left+<span class="number">1</span>;</span><br><span class="line">    r = right<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录下长的回文子串的长度</span></span><br><span class="line">    <span class="keyword">if</span> (r - l &gt; end - start) &#123;</span><br><span class="line">        start = l;</span><br><span class="line">        end = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举每个字符，以每个字符为中心，</span></span><br><span class="line"><span class="comment">// 或者以该字符和当前的字符为中心，向左右拓展进行长度统计</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();i++) &#123;</span><br><span class="line">        expandAroundCenter(s, i, i);</span><br><span class="line">        expandAroundCenter(s, i, i+<span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substr(start, end-start+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="JZ6-从尾到头打印链表"><a href="#JZ6-从尾到头打印链表" class="headerlink" title="JZ6 从尾到头打印链表"></a>JZ6 从尾到头打印链表</h2><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p><p>输入：head = [1,3,2]<br>输出：[2,3,1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)    <span class="keyword">return</span> res;</span><br><span class="line">    reversePrint(head-&gt;next);</span><br><span class="line">    res.emplace_back(head-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ24-反转链表"><a href="#JZ24-反转链表" class="headerlink" title="JZ24 反转链表"></a>JZ24 反转链表</h2><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">       ListNode *pre = <span class="literal">nullptr</span>, *cur=head, *next = <span class="literal">nullptr</span>;</span><br><span class="line">       <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">           next = cur-&gt;next;</span><br><span class="line">           cur-&gt;next = pre;</span><br><span class="line">           pre = cur;</span><br><span class="line">           cur = next;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad case</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)    <span class="keyword">return</span> head;</span><br><span class="line">    ListNode *last = reverseList(head-&gt;next);</span><br><span class="line">    <span class="comment">// 第一个元素和后面全部都反转的链表</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM2-链表内指定区间反转"><a href="#BM2-链表内指定区间反转" class="headerlink" title="BM2 链表内指定区间反转"></a>BM2 链表内指定区间反转</h2><p>将一个节点数为<code>size</code>链表<code>m</code>位置到<code>n</code>位置之间的区间反转，要求时间复杂度$O(n)$，空间复杂度$O(1)$。<br>例如：<br>给出的链表为1→2→3→4→5→NULL, m=2，n=4<br>返回1→4→3→2→5→NULL</p><p>数据范围： 链表长度0&lt;size≤1000，0&lt;m≤n≤size，链表中每个节点的值满足 |val|≤1000<br>要求：时间复杂度$O(n)$，空间复杂度$O(n)$<br>进阶：时间复杂度$O(n)$，空间复杂度$O(1)$</p><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = reverseBetween(head-&gt;next, m<span class="number">-1</span>, n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode *successor=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>) &#123;</span><br><span class="line">        successor=head-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* last = reverseN(head-&gt;next, n<span class="number">-1</span>);</span><br><span class="line">    head-&gt;next-&gt;next=head;</span><br><span class="line">    head-&gt;next=successor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h2><p>升序 排列并返回 排序后的链表。(归并排序的思想)</p><p>4-&gt;2-&gt;1-&gt;3 =&gt; 1-&gt;2-&gt;3-&gt;4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)   <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* head1 = head;</span><br><span class="line">        ListNode* head2 = split(head);</span><br><span class="line"></span><br><span class="line">        head1 = sortList(head1);</span><br><span class="line">        head2 = sortList(head2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快慢指针返回中间节点</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">split</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head, *fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* second = slow-&gt;next;</span><br><span class="line">        <span class="comment">// 断连接</span></span><br><span class="line">        slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个链表</span></span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode*head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (head1 != <span class="literal">nullptr</span> &amp;&amp; head2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (head1-&gt;val &gt; head2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = head2;</span><br><span class="line">                head2 = head2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = head1;</span><br><span class="line">                head1 = head1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将两个节点连接起来</span></span><br><span class="line">        cur-&gt;next = (head2 == <span class="literal">nullptr</span> ? head1 : head2);</span><br><span class="line">        ListNode* ret = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        dummy = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="BM3-链表中的节点每k个一组翻转"><a href="#BM3-链表中的节点每k个一组翻转" class="headerlink" title="BM3 链表中的节点每k个一组翻转"></a>BM3 链表中的节点每k个一组翻转</h2><p>将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表<br>如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样<br>你不能更改节点中的值，只能更改节点本身。</p><p>数据范围：0≤n≤2000，1≤k≤2000 ，链表中每个元素都满足0≤val≤1000<br>要求空间复杂度$O(1)$，时间复杂度$O(n)$<br>例如：<br>给定的链表是1→2→3→4→5<br>对于<code>k=2</code>, 你应该返回2→1→4→3→5<br>对于<code>k=3</code>, 你应该返回3→2→1→4→5</p><p><font color='red'><b>思路：</b></p><ul><li>按照k进行分组，k个为一组的组内元素反转链表，否则返回表头；</li><li>将头接到递归的下一组的头上。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *tail=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;k; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        tail=tail-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *temp, *pre=head, *cur=head;</span><br><span class="line">    <span class="keyword">while</span> (cur != tail) &#123;</span><br><span class="line">        temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    head-&gt;next = reverseKGroup(tail, k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h2><h3 id="JZ52-两个链表的第一个公共结点"><a href="#JZ52-两个链表的第一个公共结点" class="headerlink" title="JZ52  两个链表的第一个公共结点"></a>JZ52  两个链表的第一个公共结点</h3><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">LC160. 相交链表</a></p><p>输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p><p>数据范围：n≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)<br>输入：{1},{2,3},{}<br>返回值：{}</p><p>说明：2个链表没有公共节点 ,返回null，后台打印{}     </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">    ListNode *p1 = pHead1, *p2 = pHead2;</span><br><span class="line"><span class="comment">// 遇到空则互换线路，否则继续走</span></span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">        <span class="comment">//             if (p1 == nullptr) &#123;</span></span><br><span class="line">        <span class="comment">//                 p1 = pHead2;</span></span><br><span class="line">        <span class="comment">//             &#125;  </span></span><br><span class="line">        <span class="comment">//             else&#123;</span></span><br><span class="line">        <span class="comment">//                 p1 = p1-&gt;next;</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//             if (p2 == nullptr) &#123;</span></span><br><span class="line">        <span class="comment">//                 p2 = pHead1;</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//             else &#123;</span></span><br><span class="line">        <span class="comment">//                 p2 = p2-&gt;next;</span></span><br><span class="line">        <span class="comment">//             &#125;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        p1 = (p1 == <span class="literal">nullptr</span>)?pHead2:p1-&gt;next;</span><br><span class="line">        p2 = (p2 == <span class="literal">nullptr</span>)?pHead1:p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="环形链表I"><a href="#环形链表I" class="headerlink" title="环形链表I"></a>环形链表I</h3><p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ23-链表中环的入口结点"><a href="#JZ23-链表中环的入口结点" class="headerlink" title="JZ23 链表中环的入口结点"></a>JZ23 链表中环的入口结点</h3><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">LC142. 环形链表 II</a></p><p>给一个长度为n链表，若其中包含环，请找出该链表的环的入口结点，否则，返回null。<br>数据范围：n≤10000，1&lt;=结点值&lt;=10000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>输入描述：输入分为2段，第一段是入环前的链表部分，第二段是链表环的部分，后台会根据第二段是否为空将这两段组装成一个无环或者有环单链表<br>返回值描述：返回链表的环的入口结点即可，我们后台程序会打印这个结点对应的结点值；若没有，则返回对应编程语言的空结点即可。<br>输入：{1,2},{3,4,5}<br>返回值：3<br>说明：返回环形链表入口结点，我们后台程序会打印该环形链表入口结点对应的结点值，即3   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、双指针从头结点出发</span></span><br><span class="line">    ListNode *slow=pHead, *fast=pHead;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="comment">// 2、找到第一次相遇的位置</span></span><br><span class="line">        <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、判断是否有环</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4、有环则从原点出发同步走</span></span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ22-链表中倒数最后k个结点"><a href="#JZ22-链表中倒数最后k个结点" class="headerlink" title="JZ22 链表中倒数最后k个结点"></a>JZ22 链表中倒数最后k个结点</h3><p>输入一个长度为 n 的链表，设链表中的元素的值为 ai，返回该链表中倒数第k个节点。<br>如果该链表长度小于k，请返回一个长度为 0 的链表。<br>数据范围：0≤n≤10^5, 0≤ai≤10^9, 0≤k≤10<br>进阶：空间复杂度 O(1)，时间复杂度 O(n)<br>输入：{1,2,3,4,5},2<br>返回值：{4,5}<br>说明：返回倒数第2个节点4，系统会打印后面所有的节点来比较。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针：快指针先走k步，慢指针才出发，两者同步，当快指针到终点的位置，慢指针的位置就是待求位置</span></span><br><span class="line"><span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pHead, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode *slow=pHead, *fast=pHead;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="comment">// 还没走到k步，快指针已经到头了，直接返回空</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表的倒数第-N-个结点"><a href="#删除链表的倒数第-N-个结点" class="headerlink" title="删除链表的倒数第 N 个结点"></a>删除链表的倒数第 N 个结点</h3><p>给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。<br>输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *fast=head, *slow=dummy;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM14-链表的奇偶重排"><a href="#BM14-链表的奇偶重排" class="headerlink" title="BM14 链表的奇偶重排"></a>BM14 链表的奇偶重排</h2><p>给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。<br>注意是节点的编号而非节点的数值。</p><p>数据范围：节点数量满足0≤n≤10^5，节点中的值都满足0≤val≤1000<br>要求：空间复杂度$O(n)$，时间复杂度$O(n)$</p><p><font color='red'><b>思路：</b></p><ul><li>利用odd指针指向奇数位，even指针指向偶数位；</li><li>两个指针依次走动即可。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *odd=head, *even=head-&gt;next, *evenHead=head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (even!=<span class="literal">nullptr</span> &amp;&amp; even-&gt;next!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        odd-&gt;next=even-&gt;next;</span><br><span class="line">        odd=odd-&gt;next;</span><br><span class="line">        even-&gt;next=odd-&gt;next;</span><br><span class="line">        even=even-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    odd-&gt;next=evenHead;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ35-复杂链表的复制"><a href="#JZ35-复杂链表的复制" class="headerlink" title="JZ35 复杂链表的复制"></a>JZ35 复杂链表的复制</h2><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]<br>输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用哈希表建立原链表和新链表的关系</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; memo;</span><br><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node *dummy = <span class="keyword">new</span> Node(<span class="number">-1</span>), *p=head;</span><br><span class="line">    dummy-&gt;next = p;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        memo[p] = <span class="keyword">new</span> Node(p-&gt;val);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p = head;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        memo[p]-&gt;next = memo[p-&gt;next];</span><br><span class="line">        memo[p]-&gt;random = memo[p-&gt;random];</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[dummy-&gt;next];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ25-合并两个排序的链表"><a href="#JZ25-合并两个排序的链表" class="headerlink" title="JZ25 合并两个排序的链表"></a>JZ25 合并两个排序的链表</h2><p>输入两个递增的链表，单个链表的长度为n，合并这两个链表并使新链表中的节点仍然是递增排序的。<br>数据范围：10000≤n≤1000，−1000≤节点值≤1000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)</p><p>如输入{1,3,5},{2,4,6}时，合并后的链表为{1,2,3,4,5,6}<br>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]</p><p><font color='red'><b>思路：</b></p><ul><li>先定义表头；</li><li>比较两个链表的值，值小的接到新链表上。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用两个指针指向两个链表遍历即可</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *p1 = pHead1, *p2 = pHead2;</span><br><span class="line">    ListNode *p = dummy;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p1-&gt;val &lt; p2-&gt;val) &#123;</span><br><span class="line">            p-&gt;next = p1;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p-&gt;next = p2;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p-&gt;next = p2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并K个升序链表"><a href="#合并K个升序链表" class="headerlink" title="合并K个升序链表"></a>合并K个升序链表</h2><p>给你一个链表数组，每个链表都已经按升序排列。<br>请你将所有链表合并到一个升序链表中，返回合并后的链表。<br>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p><p>利用最小堆解决不同数组中链表的排序关系。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、定义表头</span></span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    <span class="comment">// 2、定义最小堆</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, cmp&gt; pq;</span><br><span class="line">    <span class="comment">// 3、把每个list的头指针入优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">            pq.push(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4、合并有序链表</span></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        ListNode *node = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        p-&gt;next = node;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            pq.push(node-&gt;next);</span><br><span class="line">        &#125; </span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ76-删除链表中重复的结点"><a href="#JZ76-删除链表中重复的结点" class="headerlink" title="JZ76 删除链表中重复的结点"></a>JZ76 删除链表中重复的结点</h2><p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">LC82. 删除排序链表中的重复元素 II</a></p><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5  处理后为 1-&gt;2-&gt;5<br>数据范围：链表长度满足0≤n≤1000  ，链表中的值满足1≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)<br>输入：{1,2,3,3,4,4,5}<br>返回值：{1,2,5}</p><h3 id="哈希表解法-1"><a href="#哈希表解法-1" class="headerlink" title="哈希表解法"></a>哈希表解法</h3><p>ListNode* deleteDuplication(ListNode* pHead) {<br>    // 哈希表法：不管有序无序都可以做，记录结点出现的次数，删去次数小于1的结点<br>    ListNode *dummy = new ListNode(-1), *p = pHead;<br>    dummy-&gt;next = pHead;<br>    unordered_map&lt;int, int&gt; memo;<br>    while (p != nullptr) {<br>        memo[p-&gt;val]++;<br>        p = p-&gt;next;<br>    }</p><pre><code>p = dummy;while (p-&gt;next != nullptr) &#123;    if (memo[p-&gt;next-&gt;val] &gt; 1) &#123;        p-&gt;next = p-&gt;next-&gt;next;    &#125;    else &#123;        p = p-&gt;next;    &#125;&#125;return dummy-&gt;next;</code></pre><p>}</p><h3 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h3><p>// 直接比较相邻的元素是否相等<br>ListNode* deleteDuplication(ListNode* pHead) {<br>    ListNode *dummy = new ListNode(-1), *p = dummy;<br>    dummy-&gt;next = pHead;<br>    while (p-&gt;next != nullptr &amp;&amp; p-&gt;next-&gt;next != nullptr) {<br>        if (p-&gt;next-&gt;val == p-&gt;next-&gt;next-&gt;val) {<br>            int temp = p-&gt;next-&gt;val;<br>            while (p-&gt;next != nullptr &amp;&amp; temp == p-&gt;next-&gt;val) {<br>                p-&gt;next = p-&gt;next-&gt;next;<br>            }<br>        }<br>        else {<br>            p = p-&gt;next;<br>        }<br>    }</p><pre><code>return dummy-&gt;next;</code></pre><p>}</p><h2 id="JZ18-删除链表的节点"><a href="#JZ18-删除链表的节点" class="headerlink" title="JZ18 删除链表的节点"></a>JZ18 删除链表的节点</h2><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。<br>1.此题对比原题有改动<br>2.题目保证链表中节点的值互不相同<br>3.该题只会输出返回的链表和结果做对比，所以若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点<br>数据范围:<br>0&lt;=链表节点值&lt;=10000<br>0&lt;=链表长度&lt;=10000<br>输入：{2,5,1,9},5<br>返回值：{2,1,9}<br>说明：<br>给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 2 -&gt; 1 -&gt; 9   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM11-链表相加-二"><a href="#BM11-链表相加-二" class="headerlink" title="BM11 链表相加(二)"></a>BM11 链表相加(二)</h2><p>假设链表中每一个节点的值都在<code>0-9</code>之间，那么链表整体就可以代表一个整数。<br>给定两个这种链表，请生成代表两个整数相加值的结果链表。<br>数据范围：0≤n,m≤1000000，链表任意值0≤val≤9<br>要求：空间复杂度$O(n)$，时间复杂度$O(n)$</p><p>例如：链表1为 9-&gt;3-&gt;7，链表2为 6-&gt;3，最后生成新的结果链表为1-&gt;0-&gt;0-&gt;0。</p><p><font color='red'><b>思路：</b></p><ul><li>先反转链表；</li><li>同时遍历两个链表进行求值和进位数；</li><li>把值添加入链表。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">addInList</span><span class="params">(ListNode* head1, ListNode* head2)</span> </span>&#123;</span><br><span class="line">    ListNode *p1=reverseList(head1), *p2=reverseList(head2);</span><br><span class="line">    ListNode *newHead=<span class="keyword">new</span> ListNode(<span class="number">-1</span>), *p=newHead;</span><br><span class="line">    <span class="keyword">int</span> val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> c_in=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1!=<span class="literal">nullptr</span> || p2!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (p1!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            val+=p1-&gt;val;</span><br><span class="line">            p1=p1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p2!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            val+=p2-&gt;val;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        val+=c_in;</span><br><span class="line">        c_in=val / <span class="number">10</span>;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(val%<span class="number">10</span>);</span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (c_in != <span class="number">0</span>) &#123;</span><br><span class="line">        ListNode *node=<span class="keyword">new</span> ListNode(c_in);</span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode *res=reverseList(newHead-&gt;next);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *last=reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next=head;</span><br><span class="line">    head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM15-删除有序链表中重复的元素-I"><a href="#BM15-删除有序链表中重复的元素-I" class="headerlink" title="BM15 删除有序链表中重复的元素-I"></a>BM15 删除有序链表中重复的元素-I</h2><p>删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次<br>例如：<br>给出的链表为1→1→2,返回1→2.<br>给出的链表为1→1→2→3→3,返回1→2→3.</p><p>数据范围：链表长度满足0≤n≤100，链表中任意节点的值满足∣val∣≤100<br>进阶：空间复杂度$O(1)$，时间复杂度$O(n)$<br><font color='red'><b>思路：</b></p><ul><li>定义两个指针，一个停留在当前位置，直到下一个值不同的元素才指过去；</li><li>遇到不一样的值时，更新两个指针的位置；</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode *p1=head, *p2=head;</span><br><span class="line">    <span class="keyword">while</span> (p2!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p2 != <span class="literal">nullptr</span> &amp;&amp; p1-&gt;val == p2-&gt;val) &#123;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1-&gt;next=p2;</span><br><span class="line">        p1=p1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="BM16-删除有序链表中重复的元素-II"><a href="#BM16-删除有序链表中重复的元素-II" class="headerlink" title="BM16 删除有序链表中重复的元素-II"></a>BM16 删除有序链表中重复的元素-II</h2><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为1→2→3→3→4→4→5, 返回1→2→5.<br>给出的链表为1→1→1→2→3, 返回2→3.</p><p>数据范围：链表长度0≤n≤10000，链表中的值满足 |val|≤1000<br>要求：空间复杂度$O(n)$，时间复杂度$O(n)$<br>进阶：空间复杂度$O(1)$，时间复杂度$O(n)$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *dummy=<span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    dummy-&gt;next=head;</span><br><span class="line">    ListNode *p2=dummy;</span><br><span class="line">    <span class="keyword">while</span> (p2-&gt;next!=<span class="literal">nullptr</span> &amp;&amp; p2-&gt;next-&gt;next!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p2-&gt;next-&gt;val == p2-&gt;next-&gt;next-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp=p2-&gt;next-&gt;val;</span><br><span class="line">            <span class="keyword">while</span> (p2-&gt;next!=<span class="literal">nullptr</span>  &amp;&amp; p2-&gt;next-&gt;val == temp) &#123;</span><br><span class="line">                p2-&gt;next=p2-&gt;next-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p2=p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZII26-重排链表"><a href="#JZII26-重排链表" class="headerlink" title="JZII26 重排链表"></a>JZII26 重排链表</h2><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：<br> L0 → L1 → … → Ln-1 → Ln <br>请将其重新排列后变为：<br>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>输入: head = [1,2,3,4,5]<br>输出: [1,5,2,4,3]</p><p>链表的长度范围为 [1, 5 * 10^4]<br>1 &lt;= node.val &lt;= 1000</p><p>该题由寻找链表的中点，反转链表，合并两个链表三道简单题目组成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode *mid = findMid(head);</span><br><span class="line">    ListNode *list1 = head, *list2 = mid-&gt;next;</span><br><span class="line">    mid-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    list2 = reverseList(list2);</span><br><span class="line"></span><br><span class="line">    mergeList(list1, list2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">findMid</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    ListNode *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>)    <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    ListNode *last = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将后半段反转后的链表和前半段链表进行合并</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeList</span><span class="params">(ListNode *list1, ListNode *list2)</span> </span>&#123;</span><br><span class="line">    ListNode *list1_temp, *list2_temp;</span><br><span class="line">    <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        list1_temp = list1-&gt;next;</span><br><span class="line">        list2_temp = list2-&gt;next;</span><br><span class="line"></span><br><span class="line">        list1-&gt;next = list2;</span><br><span class="line">        list2-&gt;next = list1_temp;</span><br><span class="line"></span><br><span class="line">        list1 = list1_temp;</span><br><span class="line">        list2 = list2_temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>二叉树建树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    </span><br><span class="line">    TreeNode():val(<span class="number">0</span>), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x):val(x)&#123;&#125;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x, TreeNode *left, TreeNode *right):val(x), left(left), right(right)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h2><p>遍历过程：根-&gt;左-&gt;右。</p><h3 id="递归法-2"><a href="#递归法-2" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    preorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    res.emplace_back(root-&gt;val);</span><br><span class="line">    preorder(root-&gt;left);</span><br><span class="line">    preorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;TreeNode *&gt; s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="comment">// 遍历的顺序和入栈的顺序相反，入栈首先是根进再出栈，</span></span><br><span class="line">    <span class="comment">// 然后再是右节点进，左节点进，再开始出栈。</span></span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line"></span><br><span class="line">        TreeNode *node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        res.emplace_back(node-&gt;val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h2><p>遍历过程：左-&gt;根-&gt;右。</p><h3 id="递归法-3"><a href="#递归法-3" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    inorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    inorder(root-&gt;left);</span><br><span class="line">    res.emplace_back(root-&gt;val);</span><br><span class="line">    inorder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归法-1"><a href="#非递归法-1" class="headerlink" title="非递归法"></a>非递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 1、先往左边走到底</span></span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、根节点出栈、同时判断右节点下是否有左子树</span></span><br><span class="line">        TreeNode *node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        res.emplace_back(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            root = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的后序遍历"><a href="#二叉树的后序遍历" class="headerlink" title="二叉树的后序遍历"></a>二叉树的后序遍历</h2><p>遍历过程：左-&gt;右-&gt;根。</p><h3 id="递归法-4"><a href="#递归法-4" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    postorder(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    postorder(root-&gt;left);</span><br><span class="line">    postorder(root-&gt;right);</span><br><span class="line">    res.emplace_back(root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归法-2"><a href="#非递归法-2" class="headerlink" title="非递归法"></a>非递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(root);</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        TreeNode *node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="comment">// 如果当前根右孩子已经被访问过，就不会再访问了</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right == <span class="literal">nullptr</span> || node-&gt;right == prev) &#123;</span><br><span class="line">            res.emplace_back(node-&gt;val);</span><br><span class="line">            prev = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s.push(node);</span><br><span class="line">            root = node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ55-二叉树的最大深度"><a href="#JZ55-二叉树的最大深度" class="headerlink" title="JZ55 二叉树的最大深度"></a>JZ55 二叉树的最大深度</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度，根节点的深度视为 1 。</p><p>数据范围：节点的数量满足0≤n≤100 ，节点上的值满足0≤val≤100<br>进阶：空间复杂度 O(1) ，时间复杂度 O(n)<br>输入：{1,2,3,4,5,#,6,#,#,7}<br>返回值：4</p><h3 id="递归法-5"><a href="#递归法-5" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="层次遍历法"><a href="#层次遍历法" class="headerlink" title="层次遍历法"></a>层次遍历法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层次遍历写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)    q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)    q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>相同前缀的字符串集中在 Trie 树中的一个子树。前缀树一般用来高效操作字符串。Tire树的本质是二叉树衍生出来的多叉树。</p><p>Trie() 初始化前缀树对象。<br>void insert(String word) 向前缀树中插入字符串word。<br>boolean search(String word) 如果字符串word在前缀树中，返回true（即，在检索之前已经插入）；否则，返回false。<br>boolean startsWith(String prefix) 如果之前已经插入的字符串word的前缀之一为prefix，返回true；否则，返回false。</p><p>输入<br>[“Trie”, “insert”, “search”, “search”, “startsWith”, “insert”, “search”]<br>[[], [“apple”], [“apple”], [“app”], [“app”], [“app”], [“app”]]<br>输出<br>[null, null, true, false, true, null, true]</p><p>解释<br>Trie trie = new Trie();<br>trie.insert(“apple”);<br>trie.search(“apple”);   // 返回 True<br>trie.search(“app”);     // 返回 False<br>trie.startsWith(“app”); // 返回 True<br>trie.insert(“app”);<br>trie.search(“app”);     // 返回 True</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 指向子结点的指针数组</span></span><br><span class="line">    <span class="comment">// 该节点是否是字符串的结尾</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Trie*&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回带有前缀树的末端节点</span></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch:prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Trie():children(<span class="number">26</span>), isEnd(<span class="literal">false</span>)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch:word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> Trie();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>-&gt;searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(<span class="built_in">string</span> prefix)</span> </span>&#123;</span><br><span class="line">        Trie *node = <span class="keyword">this</span>-&gt;searchPrefix(prefix);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ37-序列化二叉树"><a href="#JZ37-序列化二叉树" class="headerlink" title="JZ37 序列化二叉树"></a>JZ37 序列化二叉树</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树，不对序列化之后的字符串进行约束，但要求能够根据序列化之后的字符串重新构造出一棵与原二叉树相同的树。<br>二叉树的序列化(Serialize)是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树等遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#）</p><p>二叉树的反序列化(Deserialize)是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。<br>输入：{1,2,3,#,#,6,7}<br>返回值：{1,2,3,#,#,6,7}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;   </span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    SerializeFunction(root, res);</span><br><span class="line">    <span class="keyword">char</span> *charRes = <span class="keyword">new</span> <span class="keyword">char</span>[res.size() + <span class="number">1</span>];</span><br><span class="line">    charRes[res.size() - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">strcpy</span>(charRes, res.c_str());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> charRes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SerializeFunction</span><span class="params">(TreeNode *root, <span class="built_in">string</span>&amp; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        res += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res += to_string(root-&gt;val) + <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">    <span class="comment">// res += &#x27;,&#x27;;</span></span><br><span class="line">    SerializeFunction(root-&gt;left, res);</span><br><span class="line">    SerializeFunction(root-&gt;right, res);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">DeserializeFunction</span><span class="params">(<span class="keyword">char</span> **str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (**str == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        (*str)++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数字转换</span></span><br><span class="line">    <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (**str != <span class="string">&#x27;,&#x27;</span> &amp;&amp; **str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// char只能存一位，所以没遇到&quot;,&quot;前，按个十百位排</span></span><br><span class="line">        val = val * <span class="number">10</span> + **str - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        (*str)++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">    <span class="keyword">if</span> (**str == <span class="string">&#x27;\0&#x27;</span>)    <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span>    (*str)++;</span><br><span class="line">    </span><br><span class="line">    root-&gt;left = DeserializeFunction(str);</span><br><span class="line">    root-&gt;right = DeserializeFunction(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (*str == <span class="string">&#x27;#&#x27;</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *res = DeserializeFunction(&amp;str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZJ82-二叉树中和为某一值的路径-一"><a href="#ZJ82-二叉树中和为某一值的路径-一" class="headerlink" title="ZJ82 二叉树中和为某一值的路径(一)"></a>ZJ82 二叉树中和为某一值的路径(一)</h2><p>给定一个二叉树root和一个值 sum ，判断是否有从根节点到叶子节点的节点值之和等于 sum 的路径。<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n<br>给出如下的二叉树，sum=22，<br>返回true，因为存在一条路径25→4→11→2的节点值之和为 22</p><p>数据范围：<br>1.树上的节点数满足0≤n≤10000<br>2.每 个节点的值都满足 ∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>进阶：空间复杂度 O(树的高度)，时间复杂度O(n)</p><h3 id="递归法-6"><a href="#递归法-6" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 查看是否是叶节点</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; sum - root-&gt;val == <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root-&gt;left, sum - root-&gt;val) || hasPathSum(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ34-二叉树中和为某一值的路径-二"><a href="#JZ34-二叉树中和为某一值的路径-二" class="headerlink" title="JZ34 二叉树中和为某一值的路径(二)"></a>JZ34 二叉树中和为某一值的路径(二)</h2><p>输入一颗二叉树的根节点root和一个整数expectNumber，找出二叉树中结点值的和为expectNumber的所有路径。<br>1.该题路径定义为从树的根结点开始往下一直到叶子结点所经过的结点<br>2.叶子节点是指没有子节点的节点<br>3.路径只能从父节点到子节点，不能从子节点到父节点<br>4.总节点数目为n<br>如二叉树root为{10,5,12,4,7},expectNumber为22则合法路径有[[10,5,7],[10,12]]</p><p>数据范围:<br>树中节点总数在范围 [0, 5000] 内<br>-1000 &lt;= 节点值 &lt;= 1000<br>-1000 &lt;= expectNumber &lt;= 1000</p><h3 id="回溯解法"><a href="#回溯解法" class="headerlink" title="回溯解法"></a>回溯解法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">FindPath</span><span class="params">(TreeNode* root,<span class="keyword">int</span> expectNumber)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backTrack(root, path, expectNumber);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(TreeNode *root, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> expectNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; expectNumber - root-&gt;val == <span class="number">0</span>) &#123;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        path.pop_back();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    path.emplace_back(root-&gt;val);</span><br><span class="line">    backTrack(root-&gt;left, path, expectNumber - root-&gt;val);</span><br><span class="line">    backTrack(root-&gt;right, path, expectNumber - root-&gt;val);</span><br><span class="line">    path.pop_back();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ77-按之字形顺序打印二叉树"><a href="#JZ77-按之字形顺序打印二叉树" class="headerlink" title="JZ77  按之字形顺序打印二叉树"></a>JZ77  按之字形顺序打印二叉树</h2><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br>数据范围：0≤n≤1500,树上每个节点的val满足 ∣val∣&lt;=1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)<br>输入：{1,2,3,#,#,4,5}<br>返回值：[[1],[3,2],[4,5]]</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">Print</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(pRoot);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line"></span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            path.emplace_back(node-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (depth % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            res.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            reverse(path.begin(), path.end());</span><br><span class="line">            res.emplace_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ54-二叉搜索树的第k个节点"><a href="#JZ54-二叉搜索树的第k个节点" class="headerlink" title="JZ54  二叉搜索树的第k个节点"></a><strong>JZ54</strong>  二叉搜索树的第k个节点</h2><p>给定一棵结点数为n 二叉搜索树，请找出其中的第 k 小的TreeNode结点值。<br>1.返回第k小的节点值即可<br>2.不能查找的情况，如二叉树为空，则返回-1，或者k大于n等等，也返回-1<br>3.保证n个节点的值不一样<br>数据范围：0≤n≤1000, 0≤k≤1000，树上每个结点的值满足0≤val≤1000<br>进阶：空间复杂度 O(n)，时间复杂度 O(n)<br>输入：{5,3,7,2,4,6,8},3<br>返回值：4</p><h3 id="递归做法"><a href="#递归做法" class="headerlink" title="递归做法"></a>递归做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proot == <span class="literal">nullptr</span> || k == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    inOrder(proot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k &gt; res.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    res.emplace_back(root-&gt;val);</span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归用栈"><a href="#非递归用栈" class="headerlink" title="非递归用栈"></a>非递归用栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">KthNode</span><span class="params">(TreeNode* proot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">while</span> (!s.empty() || proot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (proot != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.push(proot);</span><br><span class="line">            proot = proot-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cnt++;</span><br><span class="line">        TreeNode *p = s.top();</span><br><span class="line">        <span class="keyword">if</span> (cnt == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        s.pop();</span><br><span class="line">        proot = p-&gt;right;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM32-合并二叉树"><a href="#BM32-合并二叉树" class="headerlink" title="BM32 合并二叉树"></a>BM32 合并二叉树</h2><p>已知两颗二叉树，将它们合并成一颗二叉树。合并规则是：都存在的结点，就将结点值加起来，否则空的位置就由另一个树的结点来代替。<br>数据范围：树上节点数量满足$0≤n≤500$，树上节点的值一定在32位整型范围内。<br>进阶：空间复杂度$O(1)$，时间复杂度$O(n)$<br>输入：{1,3,2,5},{2,1,3,#,4,#,7}<br>返回值：{3,4,5,5,4,#,7}</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t2==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode *root=<span class="keyword">new</span> TreeNode(t1-&gt;val+t2-&gt;val);</span><br><span class="line">    root-&gt;left=mergeTrees(t1-&gt;left, t2-&gt;left);</span><br><span class="line">    root-&gt;right=mergeTrees(t1-&gt;right, t2-&gt;right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ7-重建二叉树"><a href="#JZ7-重建二叉树" class="headerlink" title="JZ7 重建二叉树"></a>JZ7 重建二叉树</h2><p>给定节点数为 n 的二叉树的前序遍历和中序遍历结果，请重建出该二叉树并返回它的头结点。<br>数据范围：n≤2000，节点的值−10000≤val≤10000<br>要求：空间复杂度O(n)，时间复杂度O(n)<br>输入：[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]<br>返回值：[1,2,4,7,3,5,6,8],[4,7,2,1,5,3,8,6]</p><h3 id="递归做法-1"><a href="#递归做法-1" class="headerlink" title="递归做法"></a>递归做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据前序和中序重建二叉树</span></span><br><span class="line"><span class="comment">// 递归做法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、根据前序在中序里面找到根节点的下标</span></span><br><span class="line">    <span class="keyword">if</span> (pre.size() == <span class="number">0</span> || vin.size() == <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vin.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vin[i] == root-&gt;val)&#123;</span><br><span class="line">            index = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、递归构建左子树</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_new_pre</span><span class="params">(pre.begin()+<span class="number">1</span>, pre.begin()+<span class="number">1</span>+index)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">left_new_vin</span><span class="params">(vin.begin(), vin.begin()+index)</span></span>;</span><br><span class="line">    root-&gt;left = reConstructBinaryTree(left_new_pre, left_new_vin);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、递归构建右子树</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_new_pre</span><span class="params">(pre.begin()+index+<span class="number">1</span>, pre.end())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">right_new_vin</span><span class="params">(vin.begin()+index+<span class="number">1</span>, vin.end())</span></span>;</span><br><span class="line">    root-&gt;right =reConstructBinaryTree(right_new_pre, right_new_vin);    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归做法"><a href="#非递归做法" class="headerlink" title="非递归做法"></a>非递归做法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的做法</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre.size() == <span class="number">0</span> || vin.size() == <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="comment">// 两个指针遍历先序和中序列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>, j=<span class="number">0</span>; i &lt; pre.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 如果不相等说明左节点还可以添加</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val != vin[j]) &#123;</span><br><span class="line">            s.push(cur);</span><br><span class="line">            cur-&gt;left = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果相等，说明需要弹出栈顶元素添加右节点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top()-&gt;val == vin[j]) &#123;</span><br><span class="line">                cur = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cur-&gt;right = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ26-树的子结构"><a href="#JZ26-树的子结构" class="headerlink" title="JZ26 树的子结构"></a>JZ26 树的子结构</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（我们约定空树不是任意一个树的子结构）<br>假如给定A为{8,8,7,9,2,#,#,#,#,4,7}，B为{8,9,2}，2个树的结构如下，可以看出B是A的子结构<br>数据范围:<br>0 &lt;= A的节点个数 &lt;= 10000<br>0 &lt;= B的节点个数 &lt;= 10000<br>输入：{8,8,7,9,2,#,#,#,#,4,7},{8,9,2}<br>返回值：true</p><h3 id="前序遍历法"><a href="#前序遍历法" class="headerlink" title="前序遍历法"></a>前序遍历法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode *root1, TreeNode *root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> &amp;&amp; root2 != <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> || root2 == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val != root2-&gt;val)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recur(root1-&gt;left, root2-&gt;left) &amp;&amp; recur(root1-&gt;right, root2-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前序位置处理逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad case</span></span><br><span class="line">    <span class="keyword">if</span> (pRoot2 == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">nullptr</span> &amp;&amp; pRoot2 != <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot1 == <span class="literal">nullptr</span> || pRoot2 == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">bool</span> flag1 = recur(pRoot1, pRoot2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> flag2 = HasSubtree(pRoot1-&gt;left, pRoot2);</span><br><span class="line">    <span class="keyword">bool</span> flag3 = HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag1 || flag2 || flag3;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ27-二叉树的镜像"><a href="#JZ27-二叉树的镜像" class="headerlink" title="JZ27 二叉树的镜像"></a>JZ27 二叉树的镜像</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。<br>数据范围：二叉树的节点数0≤n≤1000 ， 二叉树每个节点的值0≤val≤1000<br>要求： 空间复杂度 O(n)。</p><h3 id="后序递归法"><a href="#后序递归法" class="headerlink" title="后序递归法"></a>后序递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    TreeNode *left = Mirror(pRoot-&gt;left);</span><br><span class="line">    TreeNode *right = Mirror(pRoot-&gt;right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在后序位置处理递归的逻辑</span></span><br><span class="line">    pRoot-&gt;left = right;</span><br><span class="line">    pRoot-&gt;right = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归用栈-1"><a href="#非递归用栈-1" class="headerlink" title="非递归用栈"></a>非递归用栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">Mirror</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        TreeNode *node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)    s.push(node-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)    s.push(node-&gt;right);</span><br><span class="line"></span><br><span class="line">        TreeNode *temp = node-&gt;left;</span><br><span class="line">        node-&gt;left = node-&gt;right;</span><br><span class="line">        node-&gt;right = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM31-对称的二叉树"><a href="#BM31-对称的二叉树" class="headerlink" title="BM31 对称的二叉树"></a>BM31 对称的二叉树</h2><p>给定一棵二叉树，判断其是否是自身的镜像（即：是否对称）<br>数据范围：节点数满足0≤n≤1000，节点上的值满足∣val∣≤1000<br>要求：空间复杂度 O(n)，时间复杂度 O(n)<br>备注：你可以用递归和迭代两种方法解决这个问题<br>输入：{1,2,2,3,4,4,3}<br>返回值：true</p><p>如果二叉树是对称的，那么按照”根-左-右”的顺序和按照”根-右-左”的顺序返回的值是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recur(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recur</span><span class="params">(TreeNode *root1, TreeNode *root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">nullptr</span> || root2 == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root1-&gt;val != root2-&gt;val)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> recur(root1-&gt;left, root2-&gt;right) &amp;&amp; recur(root1-&gt;right, root2-&gt;left);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ32-从上往下打印二叉树"><a href="#JZ32-从上往下打印二叉树" class="headerlink" title="JZ32 从上往下打印二叉树"></a>JZ32 从上往下打印二叉树</h2><p>不分行从上往下打印出二叉树的每个节点，同层节点从左至右打印。例如输入{8,6,10,#,#,2,1}，如以下图中的示例二叉树，则依次打印8,6,10,2,1(空节点不打印，跳过)，请你将打印的结果存放到一个数组里面，返回。<br>数据范围:<br>0&lt;=节点总数&lt;=1000<br>-1000&lt;=节点值&lt;=1000<br>输入：{8,6,10,#,#,2,1}<br>返回值：[8,6,10,2,1]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode *node = q.front();</span><br><span class="line">            res.emplace_back(node-&gt;val);</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>)    q.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>)    q.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM34-判断是不是二叉搜索树"><a href="#BM34-判断是不是二叉搜索树" class="headerlink" title="BM34 判断是不是二叉搜索树"></a>BM34 判断是不是二叉搜索树</h2><p>给定一个二叉树根节点，请你判断这棵树是不是二叉搜索树。<br>二叉搜索树满足每个节点的左子树上的所有节点均严格小于当前节点且右子树上的所有节点均严格大于当前节点。<br>数据范围：节点数量满足$1≤n≤10^4$，节点上的值满足$-2^{31}≤val≤2^31-1$<br>输入：{2,1,3}<br>返回值：true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中序遍历一遍即可</span></span><br><span class="line"><span class="keyword">long</span> pre=INT_MIN;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> left=isValidBST(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val&lt;=pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pre=root-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新最值</span></span><br><span class="line">    <span class="keyword">bool</span> right=isValidBST(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (!right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ79-判断是不是平衡二叉树"><a href="#JZ79-判断是不是平衡二叉树" class="headerlink" title="JZ79 判断是不是平衡二叉树"></a>JZ79 判断是不是平衡二叉树</h2><p>输入一棵节点数为 n 二叉树，判断该二叉树是否是平衡二叉树。<br>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树<br>平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<br>注：我们约定空树是平衡二叉树。<br>数据范围：n≤100,树上节点的val值满足0≤n≤1000<br>要求：空间复杂度O(1)，时间复杂度 O(n)</p><h3 id="自顶向下"><a href="#自顶向下" class="headerlink" title="自顶向下"></a>自顶向下</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> left = maxDepth(pRoot-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = maxDepth(pRoot-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(left-right) &gt; <span class="number">1</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IsBalanced_Solution(pRoot-&gt;left) &amp;&amp;</span><br><span class="line">     IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自底向上"><a href="#自底向上" class="headerlink" title="自底向上"></a>自底向上</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从最底的叶子结点开始，计算该结点的高度。</span></span><br><span class="line"><span class="comment">// 若该结点不平衡，则直接返回-1，不用继续计算其他结点高度，否则返回其高度；</span></span><br><span class="line"><span class="comment">// 若自底向上的过程中一直都是平衡的，则最终的树是平衡的。</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getDepth(pRoot) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = getDepth(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> right = getDepth(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">-1</span> || <span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM35-判断是不是完全二叉树"><a href="#BM35-判断是不是完全二叉树" class="headerlink" title="BM35 判断是不是完全二叉树"></a>BM35 判断是不是完全二叉树</h2><p>给定一个二叉树，确定他是否是一个完全二叉树。<br>完全二叉树的定义：若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）<br>数据范围：节点数满足$1≤n≤100$<br>输入：{1,2,3,4,5,#,6}<br>返回值：false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：层次遍历，标记出现空结点的位置即可</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isCompleteTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz=q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            TreeNode *node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node==<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                flag=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h2><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。<br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br><font color='red'><b>思路：</b></p><ul><li>递归左右子树；</li><li>两种情况：<ul><li>1、要么左右子树都包含p和q结点；</li><li>2、要么p和q结点只在左子树或只在右子树。</li></ul></li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">TreeNode *res;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归左右子树</span></span><br><span class="line">    <span class="keyword">bool</span> lChild = dfs(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">bool</span> rChild = dfs(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两种情况：</span></span><br><span class="line">    <span class="comment">// 1、要么左右子树都包含p和q结点；</span></span><br><span class="line">    <span class="comment">// 2、要么p和q结点只在左子树或只在右子树。</span></span><br><span class="line">    <span class="keyword">if</span> ((lChild &amp;&amp; rChild) || </span><br><span class="line">    ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) </span><br><span class="line">    &amp;&amp; (lChild || rChild))) &#123;</span><br><span class="line">        res = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lChild || rChild || </span><br><span class="line">    (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, </span></span></span><br><span class="line"><span class="function"><span class="params">                            TreeNode* q)</span> </span>&#123;</span><br><span class="line">    dfs(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="JZ68-二叉搜索树的最近公共祖先"><a href="#JZ68-二叉搜索树的最近公共祖先" class="headerlink" title="JZ68 二叉搜索树的最近公共祖先"></a>JZ68 二叉搜索树的最近公共祖先</h2><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。<br>1.对于该题的最近的公共祖先定义:对于有根树T的两个节点p、q，最近公共祖先LCA(T,p,q)表示一个节点x，满足x是p和q的祖先且x的深度尽可能大。在这里，一个节点也可以是它自己的祖先.<br>2.二叉搜索树是若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值<br>3.所有节点的值都是唯一的。<br>4.p、q 为不同节点且均存在于给定的二叉搜索树中。<br>数据范围:<br>3&lt;=节点总数&lt;=10000<br>0&lt;=节点值&lt;=10000</p><p>输入：{7,1,12,0,4,11,14,#,#,3,5},1,12<br>返回值：7<br>说明：节点1 和 节点12的最近公共祖先是7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、从根节点出发，找到p和q两个结点的路径</span></span><br><span class="line"><span class="comment">// 2、遍历两个路径，找到最后一个相同的元素，就是最近的公共祖先结点</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findPath</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;val != val) &#123;</span><br><span class="line">        path.emplace_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.emplace_back(root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path1 = findPath(root, p);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path2 = findPath(root, q);</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path1.size() &amp;&amp; i &lt; path2.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path1[i] == path2[i]) &#123;</span><br><span class="line">            res = path1[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM41-输出二叉树的右视图"><a href="#BM41-输出二叉树的右视图" class="headerlink" title="BM41 输出二叉树的右视图"></a>BM41 输出二叉树的右视图</h2><p>请根据二叉树的前序遍历，中序遍历恢复二叉树，并打印出二叉树的右视图<br>数据范围：$0≤n≤10000$<br>要求： 空间复杂度$O(n)$，时间复杂度$O(n)$</p><p>输入：[1,2,4,5,3],[4,2,5,1,3]<br>返回值：[1,3,5]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用哈希表来记录中序的位置关系，统计长度来建树</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; xianxu, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; zhongxu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xianxu.size()==<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;zhongxu.size(); i++) &#123;</span><br><span class="line">        memo[zhongxu[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 建树</span></span><br><span class="line">    TreeNode *root=buildTree(xianxu, <span class="number">0</span>, zhongxu.size()<span class="number">-1</span>, zhongxu, <span class="number">0</span>, zhongxu.size()<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 层次遍历</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> sz=q.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sz;i++) &#123;</span><br><span class="line">            TreeNode *node=q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">                q.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (i==sz<span class="number">-1</span>) &#123;</span><br><span class="line">                res.emplace_back(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; xianxu, <span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; zhongxu, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad case</span></span><br><span class="line">    <span class="keyword">if</span> (l1&gt;r1 || l2&gt;r2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> inIndex=memo[xianxu[l1]];</span><br><span class="line">    <span class="keyword">int</span> leftsize=inIndex-l2, rightsize=r2-inIndex;</span><br><span class="line">    TreeNode *root=<span class="keyword">new</span> TreeNode(xianxu[l1]);</span><br><span class="line">    </span><br><span class="line">    root-&gt;left=buildTree(xianxu, l1+<span class="number">1</span>, l1+leftsize, zhongxu, l2, inIndex<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right=buildTree(xianxu, l1+<span class="number">1</span>+leftsize, r1, zhongxu, inIndex+<span class="number">1</span>, r2);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h1><h2 id="JZ4-二维数组中的查找"><a href="#JZ4-二维数组中的查找" class="headerlink" title="JZ4 二维数组中的查找"></a>JZ4 二维数组中的查找</h2><p>在一个二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>[<br>[1,2,8,9],<br>[2,4,9,12],<br>[4,7,10,13],<br>[6,8,11,15]<br>]<br>给定 target = 7，返回 true。<br>给定 target = 3，返回 false。<br>数据范围：矩阵的长宽满足0≤n,m≤500，矩阵中的值满足0≤val≤10^9<br>进阶：空间复杂度O(1)，时间复杂度O(n+m)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于矩阵，按副对角线进行二分，从元素左下遍历到右上的位置；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">array</span>.size() == <span class="number">0</span> || <span class="built_in">array</span>[<span class="number">0</span>].size() == <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="built_in">array</span>.size(), n = <span class="built_in">array</span>[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; target)    i--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &lt; target) j++;</span><br><span class="line">        <span class="keyword">else</span>    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM19-寻找峰值"><a href="#BM19-寻找峰值" class="headerlink" title="BM19 寻找峰值"></a>BM19 寻找峰值</h2><p>给定一个长度为n的数组nums，请你找到峰值并返回其索引。数组可能包含多个峰值，在这种情况下，返回任何一个所在位置即可。<br>1.峰值元素是指其值严格大于左右相邻值的元素。严格大于即不能有等于<br>2.假设 nums[-1] = nums[n] = −∞<br>3.对于所有有效的 i 都有 nums[i] != nums[i + 1]<br>4.你可以使用O(logN)的时间复杂度实现此问题吗？</p><p>数据范围：1≤nums.length≤2×10^5<br>-2^{31}&lt;= nums[i] &lt;= 2^{31}-1<br>如输入[2,4,1,2,7,8,4]时，会形成两个山峰，一个是索引为1，峰值为4的山峰，另一个是索引为5，峰值为8的山峰。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left=<span class="number">0</span>, right=nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(right-left)/<span class="number">2</span>+left;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid]&gt;nums[mid+<span class="number">1</span>]) &#123;</span><br><span class="line">            right=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ11-旋转数组的最小数字"><a href="#JZ11-旋转数组的最小数字" class="headerlink" title="JZ11 旋转数组的最小数字"></a>JZ11 旋转数组的最小数字</h2><p>有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。</p><p>数据范围：1≤n≤10000，数组中任意元素的值:0≤val≤10000<br>要求：空间复杂度：O(1)，时间复杂度：O(logn)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = rotateArray.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 旋转点在[mid+1, high]之间</span></span><br><span class="line">        <span class="keyword">if</span> (rotateArray[mid] &gt; rotateArray[high]) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 旋转点在[low, mid]之间</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rotateArray[mid] &lt; rotateArray[high]) &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> rotateArray[low];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数学技巧"><a href="#数学技巧" class="headerlink" title="数学技巧"></a>数学技巧</h1><h2 id="厄拉多塞筛法"><a href="#厄拉多塞筛法" class="headerlink" title="厄拉多塞筛法"></a>厄拉多塞筛法</h2><ul><li>如果一个数<code>n</code>是质数，它只需要满足在<code>[2,sqrt(n))</code>的范围内是质数即可。</li><li>如果一个数<code>x</code>是质数，则对应的<code>2x</code>，<code>3x</code>…必定不是质数。</li></ul><h3 id="计数质数"><a href="#计数质数" class="headerlink" title="计数质数"></a>计数质数</h3><p>给定整数 n ，返回 所有小于非负整数 n 的质数的数量 。<br>输入：n = 10<br>输出：4<br>解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 方法二：改进的厄拉多塞筛法</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> j = i * i; j &lt; n; j+=i) &#123;</span><br><span class="line">                isPrime[j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i])</span><br><span class="line">            cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用或操作 `|` 和空格将英文字符转换为小写</span></span><br><span class="line">(<span class="string">&#x27;a&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">(<span class="string">&#x27;A&#x27;</span> | <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// 利用与操作 `&amp;` 和空格将英文字符转换为大写</span></span><br><span class="line">(<span class="string">&#x27;b&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br><span class="line">(<span class="string">&#x27;B&#x27;</span> &amp; <span class="string">&#x27;_&#x27;</span>) = <span class="string">&#x27;B&#x27;</span></span><br><span class="line"><span class="comment">// 利用异或操作 `^` 和空格将英文字符大小写互换</span></span><br><span class="line">(<span class="string">&#x27;d&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;D&#x27;</span></span><br><span class="line">(<span class="string">&#x27;D&#x27;</span> ^ <span class="string">&#x27; &#x27;</span>) = <span class="string">&#x27;d&#x27;</span></span><br><span class="line"><span class="comment">// 判断两个数是否异号</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">-1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> f = ((x^y) &lt; <span class="number">0</span>);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">bool</span> f = ((x^y) &lt; <span class="number">0</span>);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="n-amp-n-1"><a href="#n-amp-n-1" class="headerlink" title="n &amp; (n-1)"></a>n &amp; (n-1)</h2><p>作用是消除数字 <code>n</code> 的二进制表示中的位置最后的 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="number">4</span>&amp;<span class="number">3</span>);<span class="comment">// 0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="number">6</span>&amp;<span class="number">5</span>);<span class="comment">// !=0</span></span><br></pre></td></tr></table></figure><h3 id="位1的个数"><a href="#位1的个数" class="headerlink" title="位1的个数"></a>位1的个数</h3><p>输入：00000000000000000000000000001011<br>输出：3<br>解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 ‘1’。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="comment">// if (n == 0)  return 0;</span></span><br><span class="line">    <span class="comment">// n = (n&amp;(n - 1));</span></span><br><span class="line">    <span class="comment">// return (hammingWeight(n) + 1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代法 </span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        n = n &amp; (n<span class="number">-1</span>);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断一个数是不是-2-的指数"><a href="#判断一个数是不是-2-的指数" class="headerlink" title="判断一个数是不是 2 的指数"></a>判断一个数是不是 2 的指数</h3><p>输入：n = 16<br>输出：true<br>解释：24 = 16<br>你能够不使用循环/递归解决此问题吗？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果一个数是2的指数，则它的二进制表示中只有一个1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="a-a-0"><a href="#a-a-0" class="headerlink" title="a ^ a = 0"></a>a ^ a = 0</h2><p>一个数和它本身做异或运算结果为 0，即 <code>a ^ a = 0</code>；一个数和 0 做异或运算的结果为它本身，即 <code>a ^ 0 = a</code>。</p><h3 id="查找只出现一次的元素"><a href="#查找只出现一次的元素" class="headerlink" title="查找只出现一次的元素"></a>查找只出现一次的元素</h3><p>输入: [4,1,2,1,2]<br>输出: 4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">        res ^= num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找缺失的元素"><a href="#寻找缺失的元素" class="headerlink" title="寻找缺失的元素"></a>寻找缺失的元素</h3><p>只要把所有的元素和索引做异或运算，成对儿的数字都会消为 0，只有这个落单的元素会剩下。</p><p>输入：nums = [3,0,1]<br>输出：2<br>解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    res ^= n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res ^= (nums[i]^i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速乘-快速幂"><a href="#快速乘-快速幂" class="headerlink" title="快速乘+快速幂"></a>快速乘+快速幂</h2><h3 id="JZ83-剪绳子II"><a href="#JZ83-剪绳子II" class="headerlink" title="JZ83 剪绳子II"></a>JZ83 剪绳子II</h3><p>给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n &gt; 1 并且 m &gt; 1 ， m &lt;= n ），每段绳子的长度记为 k[1],…,k[m] 。请问 k[1]×k[2]×…×k[m] 可能的最大乘积是多少？例如，当绳子的长度是 8 时，我们把它剪成长度分别为 2、3、3 的三段，此时得到的最大乘积是 18 。</p><p>由于答案过大，请对 998244353 取模。<br>数据范围：2≤n≤10^14<br>进阶：空间复杂度 O(1)， 时间复杂度 O(logn)<br>输入：4<br>返回值：4<br>说明：拆分成 2 个长度为 2 的绳子，2×2=4 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fast</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    x %= mod;</span><br><span class="line">    y %= mod;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            res += x;</span><br><span class="line">            <span class="keyword">if</span> (res &gt;= mod) &#123;</span><br><span class="line">                res %= mod;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        x = x &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mod) &#123;</span><br><span class="line">            x %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Pow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">long</span> <span class="keyword">long</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            res =fast(res, x);</span><br><span class="line">        &#125;</span><br><span class="line">        x = fast(x, x);</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= mod) &#123;</span><br><span class="line">            x %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        y = y &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Pow(<span class="number">3</span>, number / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (number % <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fast(<span class="number">4</span>, Pow(<span class="number">3</span>, (number<span class="number">-4</span>)/<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fast(<span class="number">2</span>, Pow(<span class="number">3</span>, (number - <span class="number">2</span>)/<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阶乘操作"><a href="#阶乘操作" class="headerlink" title="阶乘操作"></a>阶乘操作</h2><h3 id="阶乘后的零"><a href="#阶乘后的零" class="headerlink" title="阶乘后的零"></a>阶乘后的零</h3><p>给定一个整数 n ，返回 n! 结果中尾随零的数量。<br>输入：n = 5<br>输出：1<br>解释：5! = 120 ，有一个尾随 0</p><p>该题目可以转化为<code>n!</code>中含有多少个5的倍数。</p><p><code>5!&lt;=1, 25!&lt;=5×1+1, 125&lt;=5×(5+1)+1=5×5+5+1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n!中含有多少个5的倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> base = <span class="number">5</span>; base &lt;=n; base*=<span class="number">5</span>) &#123;</span><br><span class="line">        cnt += n/base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阶乘后的K个零"><a href="#阶乘后的K个零" class="headerlink" title="阶乘后的K个零"></a>阶乘后的K个零</h3><p>二分法+阶乘后的零统计。</p><p>输入：k = 0<br>输出：5<br>解释：0!, 1!, 2!, 3!, 和 4! 均符合 k = 0 的条件。<br>0 &lt;= k &lt;= 10^9</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">preimageSizeFZF</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; findLeft(k) &lt;&lt; &quot;  &quot; &lt;&lt; findRight(k) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> (findRight(k) - findLeft(k));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findLeft</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> low = <span class="number">0</span>, high = LONG_MAX, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (countZero(mid) &lt; k) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里不减去1因为减去1后可能该处的值属于边界内的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (countZero(mid) &gt; k) &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRight</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> low = <span class="number">0</span>, high = LONG_MAX, mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (countZero(mid) &lt; k) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (countZero(mid) &gt; k) &#123;</span><br><span class="line">            high = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 加1是为了寻找右边界</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">countZero</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> base = <span class="number">5</span>; base &lt;=n; base*=<span class="number">5</span>) &#123;</span><br><span class="line">        cnt += n/base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="水塘抽样"><a href="#水塘抽样" class="headerlink" title="水塘抽样"></a>水塘抽样</h2><p>题目特点：给一个未知长度<code>n</code>的序列，如何在其中随机地选择 <code>k</code> 个元素？其中每个样本被选中的概率时一样的。</p><p>只选一个元素：<strong>当你遇到第 <code>i</code> 个元素时，以 <code>1/i</code> 的概率更新结果就可以保证结果是平均随机。</strong></p><p>即第<code>i</code>个元素被选中的概率为<code>1/n</code>。</p><p>选<code>k</code>个元素：<b>当你遇到第 <code>i</code> 个元素时，以 <code>k/i</code> 的概率更新结果就可以保证结果是平均随机。</b></p><p>即第<code>i</code>个元素被选中的概率为<code>k/n</code>。</p><p>做法：随机选择区间 <code>[0,i)</code> 内的一个整数，如果其等于 0，则将返回值置为该元素。</p><h3 id="链表随机节点"><a href="#链表随机节点" class="headerlink" title="链表随机节点"></a>链表随机节点</h3><p>给你一个单链表，随机选择链表的一个节点，并返回相应的节点值。每个节点 被选中的概率一样。<br>输入<br>[“Solution”, “getRandom”, “getRandom”, “getRandom”, “getRandom”, “getRandom”]<br>[[[1, 2, 3]], [], [], [], [], []]<br>输出<br>[null, 1, 3, 2, 2, 3]</p><p>解释<br>Solution solution = new Solution([1, 2, 3]);<br>solution.getRandom(); // 返回 1<br>solution.getRandom(); // 返回 3<br>solution.getRandom(); // 返回 2<br>solution.getRandom(); // 返回 2<br>solution.getRandom(); // 返回 3<br>// getRandom() 方法应随机返回 1、2、3中的一个，每个元素被返回的概率相等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Solution(ListNode* head) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;head = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode *p = <span class="keyword">this</span>-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="comment">// 可以理解成随机生成[0, i)之间的数，数字是0的概率是1/i</span></span><br><span class="line">         <span class="keyword">int</span> j = rand() % i;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">            res = p-&gt;val;</span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机数索引"><a href="#随机数索引" class="headerlink" title="随机数索引"></a>随机数索引</h3><p>给你一个可能含有 重复元素 的整数数组 nums ，请你随机输出给定的目标数字 target 的索引。你可以假设给定的数字一定存在于数组中。<br>输入<br>[“Solution”, “pick”, “pick”, “pick”]<br>[[[1, 2, 3, 3, 3]], [3], [1], [3]]<br>输出<br>[null, 4, 0, 2]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums): nums(nums) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == target) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">int</span> j = rand()%cnt;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h2><p>巴什博奕：<b>n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。</b></p><p>结论：如果 n 是（m+1）的倍数，那么 先手者就必输。证明如下。</p><p>令$n=k(m+1)+x$，只要先手者每次保持物品数量是(m+1)的整数倍，最后造成的局面一定是对于后手者，只剩下m+1个物品，此时无论后手者怎么选，先手者都能赢。</p><h3 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h3><p>你和你的朋友，两个人一起玩 Nim 游戏：</p><p>桌子上有一堆石头。<br>你们轮流进行自己的回合， 你作为先手 。<br>每一回合，轮到的人拿掉 1 - 3 块石头。<br>拿掉最后一块石头的人就是获胜者。<br>假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。<br>你和你的朋友，两个人一起玩 Nim 游戏：<br>输入：n = 4<br>输出：false </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canWinNim</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 巴什博弈的结论：只要物品数n是(m+1)的整数倍，那么先手者必输。</span></span><br><span class="line">       <span class="keyword">return</span> (n%<span class="number">4</span> != <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="脑筋急转弯"><a href="#脑筋急转弯" class="headerlink" title="脑筋急转弯"></a>脑筋急转弯</h2><h3 id="灯泡开关"><a href="#灯泡开关" class="headerlink" title="灯泡开关"></a>灯泡开关</h3><p>初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭第二个。<br>第三轮，你每三个灯泡就切换第三个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换第 i 个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。<br>找出并返回 n 轮后有多少个亮着的灯泡</p><p>输入：n = 3<br>输出：1<br>解释：<br>初始时, 灯泡状态 [关闭, 关闭, 关闭].<br>第一轮后, 灯泡状态 [开启, 开启, 开启].<br>第二轮后, 灯泡状态 [开启, 关闭, 开启].<br>第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 亮着的灯泡数必定是奇数的反转次数</span></span><br><span class="line"><span class="comment">// 第i个灯泡的反转次数等于它所有因子的数量</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) <span class="built_in">sqrt</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="约瑟夫环问题"><a href="#约瑟夫环问题" class="headerlink" title="约瑟夫环问题"></a>约瑟夫环问题</h2><h3 id="JZ62-孩子们的游戏-圆圈中最后剩下的数"><a href="#JZ62-孩子们的游戏-圆圈中最后剩下的数" class="headerlink" title="JZ62 孩子们的游戏(圆圈中最后剩下的数)"></a>JZ62 孩子们的游戏(圆圈中最后剩下的数)</h3><p>有个游戏是这样的：首先，让 n 个小朋友们围成一个大圈，小朋友们的编号是0~n-1。然后，随机指定一个数 m ，让编号为0的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续0… m-1报数….这样下去….直到剩下最后一个小朋友，可以不用表演，并且拿到牛客礼品，请你试着想下，哪个小朋友会得到这份礼品呢?<br>数据范围：1≤n≤5000，1≤m≤10000<br>要求：空间复杂度 O(1)，时间复杂度 O(n)<br>输入：5,3<br>返回值：3</p><h4 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上一个被抬走的人的编号是</span></span><br><span class="line">    <span class="keyword">int</span> x = LastRemaining_Solution(n - <span class="number">1</span>, m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (x + m) % n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        x = (x+m) % i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="特殊数据结构"><a href="#特殊数据结构" class="headerlink" title="特殊数据结构"></a>特殊数据结构</h1><h2 id="最大栈"><a href="#最大栈" class="headerlink" title="最大栈"></a>最大栈</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于pair, tuple这样的数据类型。</span></span><br><span class="line"><span class="comment">// 1.pair:</span></span><br><span class="line"><span class="comment">// 大根堆：</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq0;</span><br><span class="line"><span class="comment">// 小根堆：按照pair的first排序，再按照second排序</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; pq1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.tuple:</span></span><br><span class="line"><span class="comment">// 默认是使用大根堆</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; tp0;</span><br><span class="line"><span class="comment">// 小根堆，按照tuple的0元素排，再按照1元素排，最后按2元素排</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;,greater&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; tp1;</span><br><span class="line"><span class="comment">// 大根堆</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;,less&lt;tuple&lt;<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; tp2;</span><br></pre></td></tr></table></figure><h3 id="最大频率栈"><a href="#最大频率栈" class="headerlink" title="最大频率栈"></a>最大频率栈</h3><p>设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。</p><p>实现 FreqStack 类:<br>FreqStack() 构造一个空的堆栈。<br>void push(int val) 将一个整数 val 压入栈顶。<br>int pop() 删除并返回堆栈中出现频率最高的元素。<br>如果出现频率最高的元素不只一个，则移除并返回最接近栈顶的元素。</p><p>输入：<br>[“FreqStack”,”push”,”push”,”push”,”push”,”push”,”push”,”pop”,”pop”,”pop”,”pop”],<br>[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<br>输出：[null,null,null,null,null,null,null,5,7,5,4]<br>解释：<br>FreqStack = new FreqStack();<br>freqStack.push (5);//堆栈为 [5]<br>freqStack.push (7);//堆栈是 [5,7]<br>freqStack.push (5);//堆栈是 [5,7,5]<br>freqStack.push (7);//堆栈是 [5,7,5,7]<br>freqStack.push (4);//堆栈是 [5,7,5,7,4]<br>freqStack.push (5);//堆栈是 [5,7,5,7,4,5]<br>freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,5,7,4]。<br>freqStack.pop ();//返回 7 ，因为 5 和 7 出现频率最高，但7最接近顶部。堆栈变成 [5,7,5,4]。<br>freqStack.pop ();//返回 5 ，因为 5 出现频率最高。堆栈变成 [5,7,4]。<br>freqStack.pop ();//返回 4 ，因为 4, 5 和 7 出现频率最高，但 4 是最接近顶部的。堆栈变成 [5,7]。</p><p>0 &lt;= val &lt;= 109<br>push 和 pop 的操作数不大于 2 * 104。<br>输入保证在调用 pop 之前堆栈中至少有一个元素。</p><h4 id="优先队列-哈希表"><a href="#优先队列-哈希表" class="headerlink" title="优先队列+哈希表"></a>优先队列+哈希表</h4><p>优先队列C++默认是大顶堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：优先队列+哈希表</span></span><br><span class="line"><span class="comment">// 优先队列控制栈内元素有序</span></span><br><span class="line"><span class="comment">// 哈希表控制频率最高的元素优先输出</span></span><br><span class="line"><span class="comment">// tuple: freq, index, val</span></span><br><span class="line"><span class="comment">// tuple解释：先按照出现的频率排序，再按照出现的先后索引排序，最后才是进栈的值</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pq;   </span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; val2freq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index;</span><br><span class="line">FreqStack():index(<span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = val2freq[val]++;</span><br><span class="line">    index++;</span><br><span class="line">    pq.emplace(tuple(freq, index, val));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 队头元素出栈</span></span><br><span class="line">    <span class="keyword">int</span> val = get&lt;<span class="number">2</span>&gt;(pq.top());</span><br><span class="line">    pq.pop();</span><br><span class="line">    val2freq[val]--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个哈希表"><a href="#两个哈希表" class="headerlink" title="两个哈希表"></a>两个哈希表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二种解法：两个哈希表</span></span><br><span class="line"><span class="comment">// 哈希表1：记录出现值和出现的频率</span></span><br><span class="line"><span class="comment">// 哈希表2：记录当前频率和该频率下的栈</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; val2freq;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&gt; freq2val;</span><br><span class="line"><span class="keyword">int</span> maxFreq = <span class="number">-1</span>;</span><br><span class="line">FreqStack() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> freq = val2freq[val]++;</span><br><span class="line">    freq2val[freq].push(val);</span><br><span class="line">    maxFreq = max(maxFreq, freq);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val = freq2val[maxFreq].top();</span><br><span class="line">    freq2val[maxFreq].pop();</span><br><span class="line">    val2freq[val]--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freq2val[maxFreq].empty()) &#123;</span><br><span class="line">        maxFreq--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ49-丑数"><a href="#JZ49-丑数" class="headerlink" title="JZ49 丑数"></a>JZ49 丑数</h2><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 n个丑数。<br>数据范围：0≤n≤2000<br>要求：空间复杂度 O(n)， 时间复杂度 O(n)</p><p>输入：7<br>返回值：8</p><p>利用最小堆记录每个丑数，利用哈希表来防止有重复的丑数入最小堆。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; f = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">long</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt;, greater&lt;<span class="keyword">long</span>&gt;&gt; pq;</span><br><span class="line">    memo[<span class="number">1</span>]++;</span><br><span class="line">    pq.emplace(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">while</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        res = pq.top();</span><br><span class="line">        pq.pop();</span><br><span class="line">        index--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!memo.count(res*f[j])) &#123;</span><br><span class="line">                memo[res*f[j]]++;</span><br><span class="line">                pq.emplace(res*f[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM48-数据流中的中位数"><a href="#BM48-数据流中的中位数" class="headerlink" title="BM48 数据流中的中位数"></a>BM48 数据流中的中位数</h2><p>输入：[5,2,3,4,1,6,7,0,8]<br>返回值：”5.00 3.50 3.00 3.50 3.00 3.50 4.00 3.50 4.00 “<br>说明：<br>数据流里面不断吐出的是5,2,3…,则得到的平均数分别为5,(5+2)/2,3…    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是大顶堆，存着值较小的值</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; max_pq;</span><br><span class="line"><span class="comment">// 小顶堆，存着值大于大顶堆的值</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; min_pq;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    min_pq.push(num);</span><br><span class="line">    max_pq.push(min_pq.top());</span><br><span class="line">    min_pq.pop();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (max_pq.size() &gt; min_pq.size()) &#123;</span><br><span class="line">        min_pq.push(max_pq.top());</span><br><span class="line">        max_pq.pop();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (max_pq.size() == min_pq.size()) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">float</span>)(max_pq.top()+min_pq.top())/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max_pq.size()&gt;min_pq.size()?max_pq.top():min_pq.top();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>每次新元素入栈后，栈内的元素都保持有序（单调递增或单调递减）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 倒着往栈里放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 判定个子高矮</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123;</span><br><span class="line">            <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的 next great number</span></span><br><span class="line">        res[i] = s.empty() ? <span class="number">-1</span> : s.top();</span><br><span class="line">        s.push(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ul><li>从后往前处理；</li><li>什么时候出栈；</li><li>什么时候入栈。</li></ul><h3 id="下一个更大的元素I"><a href="#下一个更大的元素I" class="headerlink" title="下一个更大的元素I"></a>下一个更大的元素I</h3><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。<br>给你两个 没有重复元素 的数组 nums1 和 nums2 ，下标从 0 开始计数，其中nums1 是 nums2 的子集。</p><p>对于每个 0 &lt;= i &lt; nums1.length ，找出满足 nums1[i] == nums2[j] 的下标 j ，并且在 nums2 确定 nums2[j] 的 下一个更大元素 。如果不存在下一个更大元素，那么本次查询的答案是 -1 。<br>返回一个长度为 nums1.length 的数组 ans 作为答案，满足 ans[i] 是如上所述的 下一个更大元素 。</p><p>输入：nums1 = [4,1,2], nums2 = [1,3,4,2].<br>输出：[-1,3,-1]<br>解释：nums1 中每个值的下一个更大元素如下所述：</p><ul><li>4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li><li>1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。</li><li>2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。</li></ul><p>解法：单调栈+哈希表 =&gt; 时间：<code>O(n+m)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    res.resize(nums1.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.size(); i++) &#123;</span><br><span class="line">        m[nums1[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums2[i]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m.count(nums2[i])) &#123;</span><br><span class="line">            res[m[nums2[i]]] = s.empty()?<span class="number">-1</span>:s.top();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="下一个更大的元素II"><a href="#下一个更大的元素II" class="headerlink" title="下一个更大的元素II"></a>下一个更大的元素II</h3><p>输入: nums = [1,2,1]<br>输出: [2,-1,2]<br>解释: 第一个 1 的下一个更大的数是 2；<br>数字 2 找不到下一个更大的数；<br>第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    res.resize(nums.size());</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="comment">// 假设把数组翻倍，再取余即可</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % nums.size()])   </span><br><span class="line">            s.pop();</span><br><span class="line">        <span class="comment">// if (i &lt; nums.size())</span></span><br><span class="line">        <span class="comment">//     res[i] = s.empty()?-1:s.top();</span></span><br><span class="line">        res[i % nums.size()] = s.empty()?<span class="number">-1</span>:s.top();</span><br><span class="line">        s.push(nums[i % nums.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指在第 i 天之后，才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>输入: temperatures = [73,74,75,71,69,72,76,73]<br>输出: [1,1,4,2,1,1,0,0]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">    res.resize(temperatures.size());</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = temperatures.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; temperatures[i] &gt;= temperatures[s.top()]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = s.empty()?<span class="number">0</span>:s.top() - i;</span><br><span class="line">        s.push(i);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移掉-K-位数字"><a href="#移掉-K-位数字" class="headerlink" title="移掉 K 位数字"></a>移掉 K 位数字</h3><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。<br>输入：num = “10200”, k = 1<br>输出：”200”<br>解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p><p><a href="https://leetcode.cn/problems/remove-duplicate-letters/solution/yi-zhao-chi-bian-li-kou-si-dao-ti-ma-ma-zai-ye-b-4/">讲解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈</span></span><br><span class="line"><span class="comment">// 1、当前的元素比前一个小，前一个元素则丢弃，k--;</span></span><br><span class="line"><span class="comment">// 2、若遍历到最后k!=0，说明该序列是由小到大递增的，所以丢弃后k位。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; s;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; ch:num) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.back() &gt; ch &amp;&amp; k != <span class="number">0</span>) &#123;</span><br><span class="line">                s.pop_back();</span><br><span class="line">                k--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s.emplace_back(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历到最后k&gt;0，则丢弃后k位</span></span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s.pop_back();</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排除第一个数字是0（前导零）</span></span><br><span class="line">  <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">bool</span> isLeadingZero = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch:s) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            isLeadingZero = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isLeadingZero == <span class="literal">false</span>)</span><br><span class="line">            res += ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == <span class="string">&quot;&quot;</span> ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line"></span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="去除重复字母（不同字符的最小子序列）"><a href="#去除重复字母（不同字符的最小子序列）" class="headerlink" title="去除重复字母（不同字符的最小子序列）"></a>去除重复字母（不同字符的最小子序列）</h3><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。<br>输入：s = “cbacdcbc”<br>输出：”acdb”<br>1 &lt;= s.length &lt;= 104<br>s 由小写英文字母组成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表+单调栈</span></span><br><span class="line"><span class="comment">// 时间：O(N)</span></span><br><span class="line"><span class="comment">// 空间：O(N) </span></span><br><span class="line"><span class="comment">// 1、一个哈希表记录元素待删除的个数</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; val2freq;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeDuplicateLetters</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;ch:s) &#123;</span><br><span class="line">        val2freq[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2、利用单调栈控制对字符的删除，当栈顶元素的使用次数为0时，该元素不能出栈</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; visit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> &amp;ch:s) &#123;</span><br><span class="line">        <span class="comment">// 当前栈中有元素和ch一样则跳过</span></span><br><span class="line">        <span class="keyword">if</span> (!visit.count(ch)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty() &amp;&amp; <span class="built_in">stack</span>.back() &gt; ch &amp;&amp; val2freq[<span class="built_in">stack</span>.back()] != <span class="number">0</span>) &#123;</span><br><span class="line">                visit.erase(<span class="built_in">stack</span>.back());</span><br><span class="line">                <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">stack</span>.emplace_back(ch);</span><br><span class="line">            visit.emplace(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        val2freq[ch]--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span>&amp; ch:<span class="built_in">stack</span>) &#123;</span><br><span class="line">        res += ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JZ33-二叉搜索树的后序遍历序列"><a href="#JZ33-二叉搜索树的后序遍历序列" class="headerlink" title="JZ33 二叉搜索树的后序遍历序列"></a>JZ33 二叉搜索树的后序遍历序列</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则返回 true ,否则返回 false 。假设输入的数组的任意两个数字都互不相同。<br>数据范围：节点数量0≤n≤1000 ，节点上的值满足 1≤val≤10^5，保证节点上的值各不相同<br>要求：空间复杂度 O(n)，时间时间复杂度 O(n^2)</p><p>输入：[5,7,6,9,11,10,8]<br>返回值：true</p><p>判断数组中部分元素是否恒大于或者恒小于某一部分的值，考虑单调栈。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单调栈的解法</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// bad case</span></span><br><span class="line">    <span class="keyword">if</span> (sequence.size() == <span class="number">0</span>)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">int</span> root = INT_MAX;</span><br><span class="line">    <span class="comment">// 按照根-右子树-左子树的顺序访问 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sequence.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 查看右子树后面的左子树元素是否大于root</span></span><br><span class="line">        <span class="keyword">if</span> (sequence[i] &gt; root)    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &gt; sequence[i]) &#123;</span><br><span class="line">            root = s.top();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(sequence[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h1><p>队列中的元素会保持单调递增或单调递减的顺序。C++一般使用双向队列deque来实现。deque的API如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line">    <span class="comment">// 在队头插入元素 n</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_front</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// 在队尾插入元素 n</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    <span class="comment">// 在队头删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 在队尾删除元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_back</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回队头元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">front</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 返回队尾元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h2><p>输入：nums = [1,3,-1,-3,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MonotonicQueue</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 尾部小于n的给出队</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty() &amp;&amp; q.back() &lt; n) </span><br><span class="line">                q.pop_back();</span><br><span class="line">            q.push_back(n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队头元素是最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> q.front();</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 待出队元素是否还在队列中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!q.empty() &amp;&amp; q.front() == n)</span><br><span class="line">                q.pop_front();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    MonotonicQueue window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; k - <span class="number">1</span>) &#123;</span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            window.push(nums[i]);</span><br><span class="line">            res.emplace_back(window.max());</span><br><span class="line">            window.pop(nums[i - k + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列和栈互转"><a href="#队列和栈互转" class="headerlink" title="队列和栈互转"></a>队列和栈互转</h1><h2 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h2><p>[JZ9 用两个栈实现队列]</p><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：<br>输入：<br>[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 1, 1, false]</p><p>解释：<br>MyQueue myQueue = new MyQueue();<br>myQueue.push(1); // queue is: [1]<br>myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)<br>myQueue.peek(); // return 1<br>myQueue.pop(); // return 1, queue is [2]<br>myQueue.empty(); // return false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyQueue() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> val = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.empty()) &#123;</span><br><span class="line">                s2.push(s1.top());</span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s2.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.empty() &amp;&amp; s2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。<br>输入：<br>[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]<br>[[], [1], [2], [], [], []]<br>输出：<br>[null, null, null, 2, 2, false]</p><p>解释：<br>MyStack myStack = new MyStack();<br>myStack.push(1);<br>myStack.push(2);<br>myStack.top(); // 返回 2<br>myStack.pop(); // 返回 2<br>myStack.empty(); // 返回 False</p><p>思想：把值往后接上，保持一个队列为空，交换两个队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q1.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!q2.empty()) &#123;</span><br><span class="line">            q1.push(q2.front());</span><br><span class="line">            q2.pop();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; temp = q1;</span><br><span class="line">       q1 = q2;</span><br><span class="line">       q2 = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = q2.front();</span><br><span class="line">        q2.pop();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q2.front();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q2.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h2><p>JZ30 包含min函数的栈</p><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。<br>输入：<br>[“MinStack”,”push”,”push”,”push”,”getMin”,”pop”,”top”,”getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]</p><p>输出：<br>[null,null,null,null,-3,null,0,-2]</p><p>解释：<br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p><p>思路：用一个新的栈存放小于第一个元素的最小值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s_min;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MinStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        s.push(val);</span><br><span class="line">        <span class="keyword">if</span> (s_min.empty() || (s_min.top() &gt;= val)) &#123;</span><br><span class="line">            s_min.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.top() == s_min.top())</span><br><span class="line">            s_min.pop();</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="JZ-31栈的压入、弹出序列"><a href="#JZ-31栈的压入、弹出序列" class="headerlink" title="JZ 31栈的压入、弹出序列"></a>JZ 31栈的压入、弹出序列</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。<br>说明：<br>1、0&lt;=pushV.length == popV.length &lt;=1000<br>2、 -1000&lt;=pushV[i]&lt;=1000<br>3、pushV 的所有数字均不相同</p><p>输入：[1,2,3,4,5],[4,3,5,1,2]<br>返回值：false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; pushV.size() &amp;&amp; j &lt; popV.size() &amp;&amp; (s.empty() || s.top() != popV[j])) &#123;</span><br><span class="line"></span><br><span class="line">        s.push(pushV[i]);</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() == popV[j]) &#123;</span><br><span class="line">            <span class="comment">// cout &lt;&lt; s.top() &lt;&lt; &quot; &quot;;</span></span><br><span class="line">            s.pop();</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!s.empty())    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法（DFS）"><a href="#回溯法（DFS）" class="headerlink" title="回溯法（DFS）"></a>回溯法（DFS）</h1><h2 id="岛屿问题"><a href="#岛屿问题" class="headerlink" title="岛屿问题"></a>岛屿问题</h2><h3 id="飞地的数量"><a href="#飞地的数量" class="headerlink" title="飞地的数量"></a>飞地的数量</h3><p>给你一个大小为 m x n 的二进制矩阵 grid ，其中 0 表示一个海洋单元格、1 表示一个陆地单元格。<br>一次 移动 是指从一个陆地单元格走到另一个相邻（上、下、左、右）的陆地单元格或跨过 grid 的边界。<br>返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。</p><p>输入：grid = [[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>输出：3<br>解释：有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。</p><p><font color='red'><b>思路：</b></p><ul><li>题目的本质是回溯边界的岛屿；</li><li>淹没岛屿；</li><li>统计剩余的岛屿个数。</li></ul></font><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numEnclaves</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    m = grid.size();</span><br><span class="line">    n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">        dfs(grid, i, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">        dfs(grid, m<span class="number">-1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                res++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= m || j &gt;=n)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_i = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> next_j = j + dir[<span class="number">1</span>];</span><br><span class="line">        dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计封闭岛屿的数目"><a href="#统计封闭岛屿的数目" class="headerlink" title="统计封闭岛屿的数目"></a>统计封闭岛屿的数目</h3><p>二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。<br>请返回 封闭岛屿 的数目。</p><p>输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]<br>输出：2<br>解释：灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    m = grid.size();</span><br><span class="line">    n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        dfs(grid, i, <span class="number">0</span>);</span><br><span class="line">        dfs(grid, i, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        dfs(grid, <span class="number">0</span>, j);</span><br><span class="line">        dfs(grid, m<span class="number">-1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_i = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> next_j = j + dir[<span class="number">1</span>];</span><br><span class="line">        dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="JZII105-岛屿的最大面积"><a href="#JZII105-岛屿的最大面积" class="headerlink" title="JZII105 岛屿的最大面积"></a>JZII105 岛屿的最大面积</h3><p>给定一个由 0 和 1 组成的非空二维数组 grid ，用来表示海洋岛屿地图。<br>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。<br>找到给定的二维数组中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。</p><p>输入：[[1,1,0,0,0],[1,1,0,0,0],[0,0,0,1,1],[0,0,0,1,1]]<br>输出：4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    m = grid.size();</span><br><span class="line">    n = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                cnt=<span class="number">0</span>;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res = max(cnt, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt++;</span><br><span class="line">    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_i = i+dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> next_j = j+dir[<span class="number">1</span>];</span><br><span class="line">        dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统计子岛屿"><a href="#统计子岛屿" class="headerlink" title="统计子岛屿"></a>统计子岛屿</h3><p>给你两个<code>m x n</code>的二进制矩阵<code>grid1</code>和<code>grid2</code>，它们只包含<code>0</code>（表示水域）和<code>1</code>（表示陆地）。一个岛屿是由四个方向（水平或者竖直）上相邻的<code>1</code>组成的区域。任何矩阵以外的区域都视为水域。<br>如果<code>grid2</code>的一个岛屿，被<code>grid1</code>的一个岛屿完全包含，也就是说<code>grid2</code>中该岛屿的每一个格子都被<code>grid1</code>中同一个岛屿完全包含，那么我们称<code>grid2</code>中的这个岛屿为子岛屿。</p><p>请你返回<code>grid2</code>中子岛屿的数目。</p><p>输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]<br>输出：3<br>解释：如上图所示，左边为 grid1 ，右边为 grid2 。<br>grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countSubIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid1, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2)</span> </span>&#123;</span><br><span class="line">    m = grid2.size();</span><br><span class="line">    n = grid2[<span class="number">0</span>].size();</span><br><span class="line">    <span class="comment">// 把2中是陆地但是1中是海水的岛屿淹没掉</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid2[i][j] == <span class="number">1</span> &amp;&amp; grid1[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(grid2, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 剩下变成了统计子岛屿的数量问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid2[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(grid2, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid2, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid2[i][j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    grid2[i][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_i = i+dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> next_j = j+dir[<span class="number">1</span>];</span><br><span class="line">        dfs(grid2, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p>给你一个由<code>&#39;1&#39;</code>（陆地）和<code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。<br>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。<br>此外，你可以假设该网格的四条边均被水包围。</p><p>输入：grid = [<br>  [“1”,”1”,”1”,”1”,”0”],<br>  [“1”,”1”,”0”,”1”,”0”],<br>  [“1”,”1”,”0”,”0”,”0”],<br>  [“0”,”0”,”0”,”0”,”0”]<br>]<br>输出：1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> m, n;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    m=grid.size();</span><br><span class="line">    n=grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;=m || j&gt;=n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_i = i+dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> next_j = j+dir[<span class="number">1</span>];</span><br><span class="line">        dfs(grid, next_i, next_j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JZ12-矩阵中的路径"><a href="#JZ12-矩阵中的路径" class="headerlink" title="JZ12 矩阵中的路径"></a>JZ12 矩阵中的路径</h2><p>请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。<br>数据范围：0≤n,m≤20,1≤len≤25<br>输入：[[a,b,c,e],[s,f,c,s],[a,d,e,e]],”abcced”<br>返回值：true</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; visit;</span><br><span class="line"><span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; &gt;&amp; matrix, <span class="built_in">string</span> word)</span> </span>&#123;</span><br><span class="line">    visit.resize(matrix.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(matrix[<span class="number">0</span>].size()));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            dfs(matrix, word, i, j, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; matrix, <span class="built_in">string</span> word, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= matrix.size() || j &lt; <span class="number">0</span> || j &gt;= matrix[<span class="number">0</span>].size())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    f (visit[i][j] || matrix[i][j] != word[index])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visit[i][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; index &lt;&lt; &quot; &quot; &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">if</span> (index == word.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        res = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;dir:dirs) &#123;</span><br><span class="line">        <span class="keyword">int</span> next_i = i + dir[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> next_j = j + dir[<span class="number">1</span>];</span><br><span class="line">        dfs(matrix, word, next_i, next_j, index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    visit[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h2><p><font color='red'><b>思路：</b></p><ul><li>该问题是利用两次回溯进行括号匹配；</li><li>剪枝方法是右括号的个数要不大于左括号个数；</li><li>终止条件是<code>path</code>里左右括号的数量相同。</li></ul></font><p>输入：n = 3<br>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">  <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> left = n, right = n;</span><br><span class="line">      <span class="built_in">string</span> path;</span><br><span class="line">      backTrack(left, right, n, path);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n, <span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 结束条件</span></span><br><span class="line">      <span class="comment">// 1、左括号的数量&lt;=右括号的数量</span></span><br><span class="line">      <span class="comment">// 2、左右的剩余括号必须大于0</span></span><br><span class="line">      <span class="keyword">if</span> (left &gt; right || left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span>)    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (path.size() == <span class="number">2</span>*n) &#123;</span><br><span class="line">          res.emplace_back(path);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 做出选择</span></span><br><span class="line">      <span class="comment">// 选择左括号</span></span><br><span class="line">      path += <span class="string">&quot;(&quot;</span>;</span><br><span class="line">      backTrack(left - <span class="number">1</span>, right, n, path);</span><br><span class="line">      path.pop_back();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 选择右括号</span></span><br><span class="line">      path += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">      backTrack(left, right - <span class="number">1</span>, n, path);</span><br><span class="line">      path.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    backTrack(path, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">string</span>&amp; path, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == n &amp;&amp; right == n) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; n || right &gt; n)  <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    path += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    backTrack(path, left + <span class="number">1</span>, right, n);</span><br><span class="line">    path.pop_back();</span><br><span class="line">    path += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    backTrack(path, left, right + <span class="number">1</span>, n);</span><br><span class="line">    path.pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="子集-排列-组合问题"><a href="#子集-排列-组合问题" class="headerlink" title="子集/排列/组合问题"></a>子集/排列/组合问题</h2><p>1、穷举元素时，元素不能回头访问，即num[i]之后的元素不出现num[i]左边的元素，用depth深度进行递归；</p><p>2、穷举元素时，元素可以回头访问，num[i]之后的元素出现在num[i]左边的元素，用访问数组进行递归。</p><h3 id="元素不可复选"><a href="#元素不可复选" class="headerlink" title="元素不可复选"></a>元素不可复选</h3><h4 id="子集-数组中无重复"><a href="#子集-数组中无重复" class="headerlink" title="子集(数组中无重复)"></a>子集(数组中无重复)</h4><p>无重复元素，且元素不能回头访问。</p><p>输入：nums = [1,2,3]<br>输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backTrack(nums, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; nums.size())    <span class="keyword">return</span>;</span><br><span class="line">    res.emplace_back(path);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = depth; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.emplace_back(nums[i]);</span><br><span class="line">        backTrack(nums, path, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="子集-数组中有重复"><a href="#子集-数组中有重复" class="headerlink" title="子集(数组中有重复)"></a>子集(数组中有重复)</h4><p>有重复元素，且元素不能回头访问。</p><p>输入：nums = [1,2,2]<br>输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于子集I进行修改</span></span><br><span class="line">   <span class="comment">// 添加了排序和剪枝的逻辑</span></span><br><span class="line">   <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">   <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">subsetsWithDup</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 对于含重复元素的要进行排序</span></span><br><span class="line">       sort(nums.begin(), nums.end());</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">       backTrack(nums, path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 结束条件</span></span><br><span class="line">       <span class="keyword">if</span> (depth &gt; nums.size())    <span class="keyword">return</span>;</span><br><span class="line">       res.emplace_back(path);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = depth; i &lt; nums.size(); i++) &#123;</span><br><span class="line">           <span class="comment">// 排除非法选择</span></span><br><span class="line">           <span class="keyword">if</span> (i &gt; depth &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           <span class="comment">// 做出选择</span></span><br><span class="line">           path.emplace_back(nums[i]);</span><br><span class="line">           backTrack(nums, path, i + <span class="number">1</span>);</span><br><span class="line">           <span class="comment">// 撤销选择</span></span><br><span class="line">           path.pop_back();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="全排列-数组中无重复"><a href="#全排列-数组中无重复" class="headerlink" title="全排列(数组中无重复)"></a>全排列(数组中无重复)</h4><p><font color='red'><b>思路：</b></p><ul><li>该问题是无重复元素，且元素可以回头访问；</li><li>需要访问数组防止当前元素重复访问；</li><li>终止条件是<code>path</code>里面的个数和数组长度相等。</li></ul></font><p>输入：nums = [1,2,3]<br>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p>1 &lt;= nums.length &lt;= 6<br>-10 &lt;= nums[i] &lt;= 10<br>nums 中的所有整数 互不相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素无重复，不可多次选择</span></span><br><span class="line"><span class="keyword">int</span> visit[<span class="number">7</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permute</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backTrack(nums, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.size()) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 是否进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (visit[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做出选择</span></span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        path.emplace_back(nums[i]);</span><br><span class="line">        backTrack(nums, path);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全排列-数组中有重复"><a href="#全排列-数组中有重复" class="headerlink" title="全排列(数组中有重复)"></a>全排列(数组中有重复)</h4><p><font color='red'><b>思路：</b></p><ul><li>该问题是有重复元素，且元素可以回头访问；</li><li>需要访问数组防止当前元素重复访问，此外当前元素等于前一个元素并且前一个元素没有被访问时也不能访问该元素；</li><li>终止条件是<code>path</code>里面的个数和数组长度相等。</li></ul></font><p>输入：nums = [1,1,2]<br>输出：<br>[[1,1,2],<br> [1,2,1],<br> [2,1,1]]</p><p> 1 &lt;= nums.length &lt;= 8<br>-10 &lt;= nums[i] &lt;= 10</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visit[<span class="number">9</span>];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">permuteUnique</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backTrack(nums, path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == nums.size()) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 排除非法选择</span></span><br><span class="line">        <span class="keyword">if</span> (visit[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新增加选择条件，固定相同元素在排列中的相对位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (nums[i] == nums[i - <span class="number">1</span>]) &amp;&amp; !visit[i - <span class="number">1</span>]) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 做出选择</span></span><br><span class="line">        path.emplace_back(nums[i]);</span><br><span class="line">        visit[i] = <span class="number">1</span>;</span><br><span class="line">        backTrack(nums, path);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>无重复元素，且元素不能回头访问。</p><p>输入：n = 4, k = 2<br>输出：<br>[[2,4], [3,4], [2,3], [1,2], [1,3], [1,4],]<br>1 &lt;= n &lt;= 20<br>1 &lt;= k &lt;= n</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combine</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        nums[i - <span class="number">1</span>]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backTrack(nums, path, k, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> k, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = depth; i &lt; nums.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.emplace_back(nums[i]);</span><br><span class="line">        backTrack(nums, path, k, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素可重复选"><a href="#元素可重复选" class="headerlink" title="元素可重复选"></a>元素可重复选</h3><h4 id="组合的和-数组中无重复"><a href="#组合的和-数组中无重复" class="headerlink" title="组合的和(数组中无重复)"></a>组合的和(数组中无重复)</h4><p>无重复元素，且元素不可回头访问。</p><p>输入: candidates = [2,3,5], target = 8<br>输出: [[2,2,2,2],[2,3,3],[3,5]]<br>1 &lt;= candidates.length &lt;= 30<br>1 &lt;= candidates[i] &lt;= 200<br>candidate 中的每个元素都 互不相同<br>1 &lt;= target &lt;= 500</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 元素无重复但是可以重复选择</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    backTrack(candidates, path, target, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> target, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (pathSum &gt; target)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pathSum == target) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = depth; i &lt; candidates.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做选择</span></span><br><span class="line">        path.emplace_back(candidates[i]);</span><br><span class="line">        pathSum += candidates[i];</span><br><span class="line">        backTrack(candidates, path, target, i);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">        pathSum -= candidates[i];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合的和-数组中有重复"><a href="#组合的和-数组中有重复" class="headerlink" title="组合的和(数组中有重复)"></a>组合的和(数组中有重复)</h4><p>有重复元素，且元素不可回头访问。</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,<br>输出:<br>[[1,1,6], [1,2,5], [1,7], [2,6]]<br>1 &lt;= candidates.length &lt;= 100<br>1 &lt;= candidates[i] &lt;= 50<br>1 &lt;= target &lt;= 30</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元素有重复且不能重选</span></span><br><span class="line"><span class="comment">// 不能往前选，并且要去掉由于相同元素导致的重复解</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum2</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    sort(candidates.begin(), candidates.end());</span><br><span class="line">    backTrack(candidates, path, target, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> target, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pathSum &gt; target)   <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (pathSum == target) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = depth; i &lt; candidates.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 排除非法选择</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; depth &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 做出选择</span></span><br><span class="line">        path.emplace_back(candidates[i]);</span><br><span class="line">        pathSum += candidates[i];</span><br><span class="line">        backTrack(candidates, path, target, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        path.pop_back();</span><br><span class="line">        pathSum -= candidates[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组合的和III"><a href="#组合的和III" class="headerlink" title="组合的和III"></a>组合的和III</h4><p>无重复元素，且元素不可回头访问。</p><p>输入: k = 3, n = 9<br>输出: [[1,2,6], [1,3,5], [2,3,4]]<br>解释:<br>1 + 2 + 6 = 9<br>1 + 3 + 5 = 9<br>2 + 3 + 4 = 9<br>没有其他符合的组合了。<br>2 &lt;= k &lt;= 9<br>1 &lt;= n &lt;= 60</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">combinationSum3</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        nums[i - <span class="number">1</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    backTrack(nums, path, k, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backTrack</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (depth &gt; nums.size())    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (pathSum == n &amp;&amp; path.size() == k) &#123;</span><br><span class="line">        res.emplace_back(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = depth; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 做出选择</span></span><br><span class="line">        path.emplace_back(nums[i]);</span><br><span class="line">        pathSum += nums[i];</span><br><span class="line">        backTrack(nums, path, k, n, i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 撤销选择</span></span><br><span class="line">        pathSum -= nums[i];</span><br><span class="line">        path.pop_back();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h1><p>问题抽象成图，从一个点开始，向四周开始扩散。一般来说，写 BFS 算法都是用「队列」这种数据结构，每次将一个节点周围的所有节点加入队列。<B>BFS解决问题的本质就是让你在一幅「图」中找到从起点 <code>start</code> 到终点 <code>target</code> 的最近距离。</b></p><h2 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h2><p>给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 1、定义队列</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">       <span class="comment">// 2、取出长度</span></span><br><span class="line">        <span class="keyword">int</span> sz = q.size();</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            TreeNode *cur = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="comment">// 3、判断是否到达终点</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left == <span class="literal">nullptr</span> &amp;&amp; cur-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 4、相邻节点加入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left != <span class="literal">nullptr</span>)   q.push(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right != <span class="literal">nullptr</span>)   q.push(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>depth</code> 每增加一次，队列中的所有节点都向前迈一步，这保证了第一次到达终点的时候，走的步数是最少的。</p><p>如何把数字变成字符串？</p><p>char(i + ‘0’)即可。</p><h2 id="课程表（拓扑排序）"><a href="#课程表（拓扑排序）" class="headerlink" title="课程表（拓扑排序）"></a>课程表（拓扑排序）</h2><p>输入：numCourses = 2, prerequisites = [[1,0]]<br>输出：true<br>解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 1、建立邻接表</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; edges;</span><br><span class="line"><span class="comment">// 2、统计入度</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegrees;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    edges.resize(numCourses);</span><br><span class="line">    indegrees.resize(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; info : prerequisites) &#123;</span><br><span class="line">        edges[info[<span class="number">1</span>]].emplace_back(info[<span class="number">0</span>]);</span><br><span class="line">        indegrees[info[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3、BFS实现拓扑排序</span></span><br><span class="line">    <span class="keyword">int</span> visited = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        visited++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; v:edges[cur]) &#123;</span><br><span class="line">            indegrees[v]--;</span><br><span class="line">            <span class="keyword">if</span> (indegrees[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> visited == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h1><h2 id="字典序排数"><a href="#字典序排数" class="headerlink" title="字典序排数"></a>字典序排数</h2><p>输入：n = 13<br>输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]</p><h3 id="dfs遍历"><a href="#dfs遍历" class="headerlink" title="dfs遍历"></a>dfs遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 多叉树的遍历——使用dfs</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        dfs(i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前数小于n则添加入res</span></span><br><span class="line">    <span class="keyword">if</span> (num &gt; n)    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    res.emplace_back(num);</span><br><span class="line">    <span class="comment">// 遍历选择条件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num*<span class="number">10</span>; i &lt; (num*<span class="number">10</span>+<span class="number">10</span>) &amp;&amp; (i &lt;= n); i++) &#123;</span><br><span class="line">        dfs(i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$;</p><p>空间复杂度：$O(n)$。</p><h3 id="迭代法-2"><a href="#迭代法-2" class="headerlink" title="迭代法"></a>迭代法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">lexicalOrder</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代法，如果大于n或者遇到9为结尾，则返回上一个序，如14&gt;n，返回2，1999&gt;n，返回2</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (res.size() &lt; n) &#123;</span><br><span class="line">        <span class="comment">// 先把1，10，100，1000全入答案</span></span><br><span class="line">        <span class="keyword">while</span> (num &lt;= n) &#123;</span><br><span class="line">            res.emplace_back(num);</span><br><span class="line">            num *= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遇到19，1999或19999要返回2</span></span><br><span class="line">        <span class="keyword">while</span> (num &gt; n || num % <span class="number">10</span> == <span class="number">9</span>) &#123;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字典序的第K小数字"><a href="#字典序的第K小数字" class="headerlink" title="字典序的第K小数字"></a>字典序的第K小数字</h2><p>输入: n = 13, k = 2<br>输出: 10<br>解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。</p><p>$1 &lt;= k &lt;= n &lt;= 10^9$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> predix = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 2、指定当前的位置</span></span><br><span class="line">    <span class="keyword">long</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; k) &#123;</span><br><span class="line">        <span class="keyword">long</span> count = getCount(n, predix);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; &quot;count = &quot; &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// 3、如果k在当前前缀的范围内</span></span><br><span class="line">        <span class="keyword">if</span> (p + count &gt; k) &#123;</span><br><span class="line">            predix *= <span class="number">10</span>;</span><br><span class="line">            p++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、如果k不在当前前缀的范围内，举例n=13, k=10</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            predix++;</span><br><span class="line">            p += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> predix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、求出指定前缀下所有的节点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">(<span class="keyword">long</span> n, <span class="keyword">long</span> predix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> next = predix + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (predix &lt;= n) &#123;</span><br><span class="line">        count += (min(n+<span class="number">1</span>, next) - predix);</span><br><span class="line">        predix *= <span class="number">10</span>;</span><br><span class="line">        next *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(log^2(n))$;</p><p>空间复杂度：$O(1)$。</p><h1 id="高频系列"><a href="#高频系列" class="headerlink" title="高频系列"></a>高频系列</h1><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>本质就是二叉树的后序遍历。思想是把复杂的问题变成若干个小的子问题，递归求解子问题，再通过子问题的结果合并成原问题。</p><h3 id="为运算符表达式设置优先级"><a href="#为运算符表达式设置优先级" class="headerlink" title="为运算符表达式设置优先级"></a>为运算符表达式设置优先级</h3><p>给你一个由数字和运算符组成的字符串 expression ，按不同优先级组合数字和运算符，计算并返回所有可能组合的结果。你可以 按任意顺序 返回答案。<br>输入：expression = “2-1-1”<br>输出：[0,2]<br>解释：<br>((2-1)-1) = 0<br>(2-(1-1)) = 2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录重复子问题</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(<span class="built_in">string</span> expression)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (memo.count(expression)) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[expression];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (expression[i] == <span class="string">&#x27;+&#x27;</span> || expression[i] == <span class="string">&#x27;-&#x27;</span> || expression[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left = diffWaysToCompute(expression.substr(<span class="number">0</span>, i));</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; right = diffWaysToCompute(expression.substr(i + <span class="number">1</span>, expression.size() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后序位置开始治</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> l:left) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> r:right) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (expression[i] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                        res.emplace_back(l + r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (expression[i] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                        res.emplace_back(l - r);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (expression[i] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                        res.emplace_back(l * r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归结束条件</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; expression;</span><br><span class="line">    ss &gt;&gt; num;</span><br><span class="line">    <span class="keyword">if</span> (res.empty()) &#123;</span><br><span class="line">        res.emplace_back(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memo[expression] = res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="斗地主凑顺子"><a href="#斗地主凑顺子" class="headerlink" title="斗地主凑顺子"></a>斗地主凑顺子</h2><h3 id="分割数组为连续的子序列"><a href="#分割数组为连续的子序列" class="headerlink" title="分割数组为连续的子序列"></a>分割数组为连续的子序列</h3><p>给你一个按升序排序的整数数组 num（可能包含重复数字），请你将它们分割成一个或多个长度至少为 3 的子序列，其中每个子序列都由连续整数组成。</p><p>如果可以完成上述分割，则返回 true ；否则，返回 false 。</p><p>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 对于每一张牌。只有两种情况：</span></span><br><span class="line">    <span class="comment">// 1、从自身出发可以形成连续的3个子序列；</span></span><br><span class="line">    <span class="comment">// 2、接到上一张排的后面。</span></span><br><span class="line">    <span class="comment">// unordered_map&lt;int, int&gt; freq, need;</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; need;</span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;int&gt;&gt; res;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;num:nums) &#123;</span><br><span class="line">            freq[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (freq[num] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (need.count(num) &amp;&amp; need[num].size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                freq[num]--;</span><br><span class="line">                <span class="comment">// need[num]--;</span></span><br><span class="line">                <span class="comment">// need[num+1]++;</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq = need[num].back();</span><br><span class="line">                need[num].pop_back();</span><br><span class="line">                seq.emplace_back(num);</span><br><span class="line">                need[num+<span class="number">1</span>].emplace_back(seq);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (freq[num] &gt; <span class="number">0</span> &amp;&amp; freq[num+<span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; freq[num+<span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// need[num+3]++;</span></span><br><span class="line">                freq[num]--;</span><br><span class="line">                freq[num+<span class="number">1</span>]--;</span><br><span class="line">                freq[num+<span class="number">2</span>]--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 构建顺子序列</span></span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seq&#123;num, num+<span class="number">1</span>, num+<span class="number">2</span>&#125;;</span><br><span class="line">                need[num+<span class="number">3</span>].emplace_back(seq);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;kv:need) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;seq:kv.second) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num:seq) &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="网易吃葡萄"><a href="#网易吃葡萄" class="headerlink" title="网易吃葡萄"></a>网易吃葡萄</h2><p>有三种葡萄，每种分别有 a, b, c 颗，现在有三个人，第一个人只吃第一种和第二种葡萄，第二个人只吃第二种和第三种葡萄，第三个人只吃第一种和第三种葡萄。</p><p>现在给你输入 a, b, c 三个值，请你适当安排，让三个人吃完所有的葡萄，算法返回吃的最多的人最少要吃多少颗葡萄。</p><p>第一行数字T，表示数据组数。<br>接下来T行，每行三个数a,b,c<br>1≤a,b,c≤10^18  1≤T≤10</p><p>输入<br>2<br>1 2 3<br>1 2 6<br>输出<br>2<br>3</p><p>吃的最多的人是指当然可以把所吃的两种葡萄全部吃完，比如说第一个人全部吃完a+b，第二个人吃完c，最后一个人不吃，假设a+b&gt;c，此时第一个人吃的最多，但是还有个条件这个人最少要吃多少颗，就是说这个人吃的还是比别人多，但是可能就比别人多一颗或者几颗或者0颗，上述安排方式显然不能满足，此时，如果安排三个人尽量平均地吃，再把葡萄数向上取整(<code>m/n</code>是向下取整，改为<code>(m+n-1)/n</code>则是向上取整)，那么就能满足上述条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">eatGrapes</span><span class="params">(<span class="keyword">long</span> a, <span class="keyword">long</span> b, <span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; nums&#123;a, b, c&#125;;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">long</span> sum = accumulate(nums.begin(), nums.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果能构成三角形</span></span><br><span class="line">    <span class="keyword">if</span> (a + b &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> (sum+<span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不能构成三角形并且长边大于两倍的短边之和，那么平分长边</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="number">2</span>*(a+b) &lt; c)) &#123;</span><br><span class="line">        <span class="keyword">return</span> (nums[<span class="number">2</span>]+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sum+<span class="number">2</span>) / <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; res;</span><br><span class="line">    <span class="keyword">long</span> a, b, c;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; T; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="keyword">long</span> r = eatGrapes(a, b, c);</span><br><span class="line">        res.emplace_back(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num:res) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><h3 id="煎饼排序"><a href="#煎饼排序" class="headerlink" title="煎饼排序"></a>煎饼排序</h3><p>给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。<br>一次煎饼翻转的执行过程如下：</p><p>选择一个整数 k ，1 &lt;= k &lt;= arr.length<br>反转子数组 arr[0…k-1]（下标从 0 开始）<br>例如，arr = [3,2,1,4] ，选择 k = 3 进行一次煎饼翻转，反转子数组 [3,2,1] ，得到 arr = [1,2,3,4] 。<br>以数组形式返回能使 arr 有序的煎饼翻转操作所对应的 k 值序列。任何将数组排序且翻转次数在 10 * arr.length 范围内的有效答案都将被判断为正确。</p><p>输入：[3,2,4,1]<br>输出：[4,2,4,3]<br>解释：<br>我们执行 4 次煎饼翻转，k 值分别为 4，2，4，和 3。<br>初始状态 arr = [3, 2, 4, 1]<br>第一次翻转后（k = 4）：arr = [1, 4, 2, 3]<br>第二次翻转后（k = 2）：arr = [4, 1, 2, 3]<br>第三次翻转后（k = 4）：arr = [3, 2, 1, 4]<br>第四次翻转后（k = 3）：arr = [1, 2, 3, 4]，此时已完成排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 煎饼排序——递归思路</span></span><br><span class="line"><span class="comment">// 1、当序列长度为`n`时，找到`0~n-1`序列长度的最大值`maxValue`以及其下标`maxIndex`；</span></span><br><span class="line"><span class="comment">// 2、翻转`0~maxIndex`的序列，把最大值翻到第一个位置；</span></span><br><span class="line"><span class="comment">// 3、再翻转`0~n`的序列，把最大值翻到第`n`个位置；</span></span><br><span class="line"><span class="comment">// 4、此时已得到一个最大值在序列的末尾；</span></span><br><span class="line"><span class="comment">// 5、令`n`减1再递归上述过程，得到有序序列。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pancakeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    onceSort(arr, arr.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onceSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> maxIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValue = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = arr[i];</span><br><span class="line">            maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(arr, <span class="number">0</span>, maxIndex);</span><br><span class="line">    res.emplace_back(maxIndex + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    reverse(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    res.emplace_back(n);</span><br><span class="line"></span><br><span class="line">    onceSort(arr, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">        arr[j] = arr[i];</span><br><span class="line">        arr[i] = temp;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串相乘"><a href="#字符串相乘" class="headerlink" title="字符串相乘"></a>字符串相乘</h2><p>给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。<br>注意：不能使用任何内置的 BigInteger 库或直接将输入转换为整数。</p><p>输入: num1 = “123”, num2 = “456”<br>输出: “56088”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = num1.size(), n = num2.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(m + n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> mul = (num1[j] - <span class="string">&#x27;0&#x27;</span>) * (num2[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">int</span> sum = mul + res[i + j + <span class="number">1</span>];</span><br><span class="line">            res[i + j + <span class="number">1</span>] = sum % <span class="number">10</span>;</span><br><span class="line">            res[i + j] += sum / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; res.size() &amp;&amp; res[start] == <span class="number">0</span>) &#123;</span><br><span class="line">        start++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> res_final;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; res.size(); i++) &#123;</span><br><span class="line">        res_final += (res[i] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res_final.size() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span>:res_final;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h2><p>给定一个条形图，问该条形图能接多少水？<br>输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出：6<br>解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。</p><h3 id="备忘录法"><a href="#备忘录法" class="headerlink" title="备忘录法"></a>备忘录法</h3><p>记录每个位置<code>i</code>的能接的雨水=之前的最高柱子高度-当前柱子高度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 定义备忘录</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; l_max;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; r_max;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> len = height.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    l_max.resize(len);</span><br><span class="line">    r_max.resize(len);</span><br><span class="line">    l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">    r_max[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化备忘录</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        l_max[i] = max(l_max[i - <span class="number">1</span>], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        r_max[i] = max(r_max[i + <span class="number">1</span>], height[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        ans += (min(l_max[i], r_max[i]) - height[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p><code>l_max</code>代表<code>height[0...left]</code>的最高柱子，<code>r_max</code>代表<code>height[right...end]</code>的最高柱子，只要<code>l_max &lt; r_max</code>，就能以<code>l_max</code>为主接雨水了，否则以<code>r_max</code>为主接雨水。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 一开始确定左右边界，遇到更高的更新边界，遇到更矮的求和</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = height.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> l_max = <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        l_max = max(l_max, height[left]);</span><br><span class="line">        r_max = max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">            ans += (l_max - height[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans += (r_max - height[right]);</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="交叉应用"><a href="#交叉应用" class="headerlink" title="交叉应用"></a>交叉应用</h1><h2 id="BFS-DP"><a href="#BFS-DP" class="headerlink" title="BFS+DP"></a>BFS+DP</h2><h3 id="最小跳跃次数"><a href="#最小跳跃次数" class="headerlink" title="最小跳跃次数"></a>最小跳跃次数</h3><p>为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]&gt;=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。<br>为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。</p><p>示例 1：<br>输入：jump = [2, 5, 1, 1, 1, 1]<br>输出：3<br>解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -&gt; 2 -&gt; 1 -&gt; 6，最终小球弹出了机器。</p><p>限制：<br>1 &lt;= jump.length &lt;= 10^6<br>1 &lt;= jump[i] &lt;= 10000</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(dp[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">// 1、到达终点</span></span><br><span class="line">        <span class="keyword">if</span> (cur + nums[cur] &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[cur] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、小球第一次到达右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dp[cur + nums[cur]] == INT_MAX) &#123;</span><br><span class="line">            q.push(cur + nums[cur]);</span><br><span class="line">            dp[cur + nums[cur]] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">   <span class="comment">// 3、小球往左边走，每次从left出发则不会超时</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[left] == INT_MAX) &#123;</span><br><span class="line">                dp[left] = dp[cur] + <span class="number">1</span>;</span><br><span class="line">                q.push(left);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=len<span class="number">-2</span>; j&gt;=i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j]&lt;a[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp=a[j];</span><br><span class="line">                a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">21</span>,<span class="number">566</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    printArr(arr, n);</span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line">    printArr(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    swap(arr[low], arr[low + rand()%(high-low+<span class="number">1</span>)]);</span><br><span class="line">    <span class="keyword">int</span> v=arr[low];</span><br><span class="line">    <span class="keyword">int</span> i=low+<span class="number">1</span>, j=high;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=high &amp;&amp; arr[i]&lt;v) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=low+<span class="number">1</span> &amp;&amp; arr[j]&gt;v) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        swap(arr[i], arr[j]);</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[low], arr[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> pivot=partition(arr, low, high);</span><br><span class="line">        quickSort(arr, low, pivot<span class="number">-1</span>);</span><br><span class="line">        quickSort(arr, pivot+<span class="number">1</span>, high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">10</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    quickSort(arr, <span class="number">0</span>, N<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1) 取出待调整的结点i元素</span></span><br><span class="line">    <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">2</span>*i+<span class="number">1</span>; k &lt; len; k++) &#123;</span><br><span class="line">        <span class="comment">// 2) 找到左孩子(2*i+1)和右孩子(2*i+2)中最大记录的下标；</span></span><br><span class="line">        <span class="keyword">if</span> ((k + <span class="number">1</span> &lt; len) &amp;&amp; (arr[k] &lt; arr[k + <span class="number">1</span>])) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3) 若孩子结点最大记录大于i结点的元素，将两者值进行交换。完成一次非叶结点堆的调整</span></span><br><span class="line">        <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            i = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4) 最后给待调整元素赋值</span></span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、构建堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        heapAdjust(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2、调整堆</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        heapAdjust(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *arr);</span><br><span class="line">        arr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line">    heapSort(arr, len);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *arr);</span><br><span class="line">        arr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_selection_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[min])    min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i != min)</span><br><span class="line">            swap(arr[i], arr[min]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line"></span><br><span class="line">    simple_selection_sort(arr, len);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">straightInsertionSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            <span class="keyword">for</span> (j = i - <span class="number">1</span>; (j &gt;= <span class="number">0</span>) &amp;&amp; (arr[j] &gt; temp); j--) &#123;</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">            arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *arr);</span><br><span class="line">        arr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line">    straightInsertionSort(arr, len);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1、初始化增量为gap，每次循环增量gap减小为原来的一半；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 2、从第gap个元素开始，分组中待插入的元素和距离为前一个gap的元素进行比较，看是否需要插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[gap] &lt; arr[i - gap]) &#123;</span><br><span class="line">                <span class="comment">// 3、带插入的元素称为哨兵，将哨兵从后往前，按照gap的距离，依次和顺序表的元素进行比较</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="comment">// 4、比哨兵大则往后挪一位，循环结束时在相应位置插入哨兵</span></span><br><span class="line">                <span class="keyword">for</span> (j = i - gap; j &gt;=<span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j-= gap) &#123;</span><br><span class="line">                    arr[j + gap] = arr[j];</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j + gap] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *arr);</span><br><span class="line">        arr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>] = &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line">    shell_sort(arr, len);</span><br><span class="line">    printArr(arr, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> middle, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> help[right - left + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> p1 = left, p2 = middle + <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= middle &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[p1] &lt;= arr[p2]) &#123;</span><br><span class="line">            help[i]=arr[p1];</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            help[i]=arr[p2];</span><br><span class="line">            p2++;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= middle) &#123;</span><br><span class="line">        help[i] = arr[p1];</span><br><span class="line">        p1++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">        help[i] = arr[p2]; </span><br><span class="line">        p2++;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">        arr[left + j] = help[j]; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> middle = left +((right - left) / <span class="number">2</span>);</span><br><span class="line">    mergeSort(arr, left, middle);</span><br><span class="line">    mergeSort(arr, middle + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">    merge(arr, left, middle, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">21</span>,<span class="number">566</span>,<span class="number">2</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    printArr(arr, n);</span><br><span class="line">    mergeSort(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    printArr(arr, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM47-寻找第K大"><a href="#BM47-寻找第K大" class="headerlink" title="BM47 寻找第K大"></a>BM47 寻找第K大</h2><p>有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。<br>给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。<br>数据范围：$0≤n≤10^5, 1≤K≤n$，数组中每个元素满足$0≤val≤10^9$<br>输入：[1,3,5,2,2],5,3<br>返回值：2</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    swap(a[low], a[low + (rand()%(high-low+<span class="number">1</span>))]);</span><br><span class="line">    <span class="keyword">int</span> v=a[low];</span><br><span class="line">    <span class="keyword">int</span> i=low+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=high;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j&gt;=low+<span class="number">1</span> &amp;&amp; a[j]&lt;v)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=high &amp;&amp; a[i]&gt;v)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a[i], a[j]);</span><br><span class="line"></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a[low], a[j]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// j是从0开始的</span></span><br><span class="line">    <span class="keyword">if</span> (K == j+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a[j];</span><br><span class="line">    <span class="comment">// j+1小，说明第K大值在右边</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (K &gt; j+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> partition(a, j+<span class="number">1</span>, high, K);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// j+1大，说明第K大值在左边</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> partition(a, low, j<span class="number">-1</span>, K);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> n, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> partition(a, <span class="number">0</span>, n<span class="number">-1</span>, K);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-把输入转为字符串"><a href="#C-把输入转为字符串" class="headerlink" title="C++把输入转为字符串"></a>C++把输入转为字符串</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = <span class="built_in">cin</span>.get();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s += c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s-&gt;&quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C-把字符串处理成数组"><a href="#C-把字符串处理成数组" class="headerlink" title="C++把字符串处理成数组"></a>C++把字符串处理成数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于C++处理输入处理成数组，小记一手</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dealInput</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="built_in">string</span> cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i]==<span class="string">&#x27;,&#x27;</span> || i==n) &#123;</span><br><span class="line">            nums.push_back(stoi(cur));</span><br><span class="line">            cur=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.push_back(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;num:nums) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*test</span></span><br><span class="line"><span class="comment">-1,2,-3,4,-5</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">int</span> target;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = dealInput(s);</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; target;</span><br><span class="line">    printArr(nums);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 喵喵笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SVM</title>
      <link href="/academic_research/machine_learning/SVM/"/>
      <url>/academic_research/machine_learning/SVM/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="SVM简介？"><a href="#SVM简介？" class="headerlink" title="SVM简介？"></a>SVM简介？</h2><ul><li>支持向量机(Support Vector Machine)是一个二分类模型，它的<b>基本模型</b>是定义在特征空间上<b>间隔最大</b>的线性分类器，由于间隔最大使得它和感知机不同；</li><li>并且SVM还包括<b>核技巧</b>，这使得它成为一个非线性分类器；</li><li>SVM的学习策略是<b>间隔最大化</b>，该策略可形式化为求解凸二次规划问题，也等价于合页损失函数最小化的问题。</li></ul><span id="more"></span><h2 id="SVM的原理？"><a href="#SVM的原理？" class="headerlink" title="SVM的原理？"></a>SVM的原理？</h2><ul><li>SVM的<a href="https://zhuanlan.zhihu.com/p/31886934">基本想法</a>是最大化离超平面最近的点到该平面的距离。</li><li>对于线性可分的数据集来说，可分离的超平面有无数个，但是几何间隔最大的超平面只有一个；</li><li>对于线性可分的数据集，可以把问题转化为凸优化问题，再使用<b>拉格朗日乘子法简化</b>求解；</li><li>对于线性不可分的数据集，可以使用核函数将<b>样本映射到高维空间</b>中，使它变成线性可分的数据再求解。</li></ul><h2 id="SVM推导"><a href="#SVM推导" class="headerlink" title="SVM推导"></a>SVM推导</h2><p>强推：<a href="https://mp.weixin.qq.com/s/tj_O8H3S_kdag30jivBy6g">svm原理从头到尾详细推导</a></p><p>大致过程：</p><ul><li>SVM要求解的问题是最大化离超平面最近点到超平面的距离。即优化如下问题：<br>$$\underset{\omega,b}{max}(\underset{x_i}{min}\frac{y_i(\omega ^Tx_i+b)}{||\omega||})$$</li><li>为了简化计算，假设最近点离超平面的距离为1，此时其他点的函数距离$y_i(\omega^T x_i+b)&gt;1$。问题转化为在$y_i(\omega^T x_i+b)≥1$的不等式约束下关于$\omega$的最小化问题：<br>$$\underset{\omega,b}{max}\frac{1}{||\omega||}=&gt;\underset{\omega,b}{min}\frac{1}{2}||\omega||^2 \quad\quad\quad s.t.\quad y_i(\omega^T x_i+b)≥1$$</li><li>为了方便求解上式，需要把不等式约束问题转化为无约束的极小极大值问题，并且该优化结果满足kkt条件(拉格朗日乘子法的泛化)，所以可以进一步把不等式的约束问题转化为它的对偶问题(极小极大值问题)。再利用kkt条件求导可以求解最终参数结果。   </li><li>为了防止由于标签标记错误(离群点)对模型性能产生影响，此时会对离群点引入松弛因子$\beta_i$，加入后的损失函数为<br>$$\underset{\omega,b,\beta}{min}(\frac{1}{2}||\omega||^2+C\overset{m}{\underset{i=1}{\sum}}\beta_i)\quad\quad\quad s.t.\quad y_i(\omega^T x_i+b)≥1-\beta_i\beta_i≥0$$<br>$\beta$表示超平面两侧离群点之间的距离，$C$表示对离群点的重视程度。当$\beta_i$固定时，$C=0$表示可以忽略这些离群点，$C=+\infty$表示离群点非常重要，此时会导致模型线性不可分(可以借助核函数映射到线性空间)。增大惩罚因子$C$，模型的泛化能力会变弱，$C=+\infty$时，模型退化为<a href="https://zhuanlan.zhihu.com/p/81890745">线性可分的SVM(硬间隔)</a>，减小惩罚因子，模型的泛化能力变好。</li></ul><h2 id="SVM如何防止过拟合？"><a href="#SVM如何防止过拟合？" class="headerlink" title="SVM如何防止过拟合？"></a>SVM如何防止过拟合？</h2><p>对离群点引入松弛因子$\beta_i$，SVM希望通过引入松弛因子$\beta_i$和惩罚因子$C$来容忍离群点的存在，$C$越大，表示越重视离群点，$C$越小，表示可以忽略该离群点的存在。</p><h2 id="LR和SVM的联系和区别？"><a href="#LR和SVM的联系和区别？" class="headerlink" title="LR和SVM的联系和区别？"></a>LR和SVM的联系和区别？</h2><p><a href="https://blog.csdn.net/julyedu_7/article/details/121836689">参考</a></p><ul><li><p>联系：</p><ul><li>一般都用来处理二分类问题；</li><li>都是线性分类器，本质上都是求一个最佳的分类超平面；</li><li>都是监督学习算法；</li><li>都是判别模型，判别模型不关注数据的生成，只关注数据之间的差别。</li></ul></li><li><p>区别：</p><ul><li>LR是参数模型(假设输出服从二项分布)，SVM是非参数模型；</li><li>解决非线性问题时，SVM采用核函数，LR一般不采用；(因为LR考虑所有的样本，SVM只依赖于决策面附近的支持向量，计算量不一样)</li><li>SVM的损失函数自带正则化，而LR需要在损失函数之外另外加入(如下)；</li><li>从损失函数上看，LR的损失函数是交叉熵，是基于概率分类的，如下：<br>$$J(\theta)=-\frac{1}{m}[\overset{m}{\underset{i=1}{\sum}}y^{(i)}logh_\theta(x^{(i)})+(1-y^{(i)})log(1-h_\theta(x^{(i)}))]$$<br>SVM的损失函数是合页损失函数，是基于几何间隔最大化的原理，是基于几何距离进行分类的，如下：<br>$$L(\omega,b,\alpha)=\frac{1}{2}||w||^2-\overset{m}{\underset{i=1}{\sum}}\alpha_i(y_i(\omega^Tx_i+b)-1)$$</li></ul></li></ul><p>[注]</p><ul><li>常见的判别模型有LR，KNN，SVM，常见的生成模型有朴素贝叶斯，隐马尔可夫模型；</li><li>参数模型是指假设数据总体服从某个分布，这个分布可以由具体数量的参数确定<font color='red'>(参数确定，模型就确定了)</font>；非参数模型是指数据分布未知，无法得到分布的相关参数，只有在给定一些样本的条件下，通过非参数估计的方法推断。</li></ul><h2 id="特征数量与LR和SVM的关系？"><a href="#特征数量与LR和SVM的关系？" class="headerlink" title="特征数量与LR和SVM的关系？"></a>特征数量与LR和SVM的关系？</h2><p><a href="https://zhuanlan.zhihu.com/p/46943307">参考</a></p><ul><li>如果特征数量很大，和样本数量差不多，选用LR或者线性核的SVM；</li><li>如果特征数量比较少，样本数量不多不少，选择RBF核(高斯核)的SVM；</li><li>如果特征数量比较少，样本数量很多，需要手动添加特征再选用线性核的SVM。</li></ul><h2 id="为什么SVM对缺失数据敏感？"><a href="#为什么SVM对缺失数据敏感？" class="headerlink" title="为什么SVM对缺失数据敏感？"></a>为什么SVM对缺失数据敏感？</h2><p><a href="https://zhuanlan.zhihu.com/p/81890745">参考</a></p><p>一般的缺失数据指数据的特征不完整，<b>SVM没有处理缺失值的策略</b>。而且SVM希望样本在特征空间中是线性可分的，所以特征空间的好坏会影响SVM的性能，缺失某些数据的特征会影响训练的结果。</p><h2 id="为什么要将求解SVM的原始问题转换为其对偶问题？"><a href="#为什么要将求解SVM的原始问题转换为其对偶问题？" class="headerlink" title="为什么要将求解SVM的原始问题转换为其对偶问题？"></a>为什么要将求解SVM的原始问题转换为其对偶问题？</h2><p><a href="https://mp.weixin.qq.com/s/tj_O8H3S_kdag30jivBy6g">参考</a></p><ul><li>因为原问题是个带有不等式约束的问题，为了方便求解，可以把目标函数和约束全部融入拉格朗日函数，再求解其对偶问题，把原问题转化为无约束的极小极大值问题，利用kkt条件求解；</li><li>转化为对偶问题可以自然地引入核函数，进而推广到非线性问题。</li></ul><h2 id="SVM如何选择核函数？"><a href="#SVM如何选择核函数？" class="headerlink" title="SVM如何选择核函数？"></a>SVM如何选择核函数？</h2><p><a href="https://zhuanlan.zhihu.com/p/81890745">参考</a></p><ul><li>当特征维度较大，样本数很小时(文本分类)，使用线性核；</li><li>当特征维度较小，样本数不大不小时，使用高斯核(RBF核)；</li><li>当特征维度较小，样本数较多时，此时SVM的性能不如神经网络。</li></ul><h2 id="SVM的优缺点？"><a href="#SVM的优缺点？" class="headerlink" title="SVM的优缺点？"></a>SVM的优缺点？</h2><p><a href="https://zhuanlan.zhihu.com/p/81890745">参考</a></p><ul><li>优点<ul><li>SVM是个凸优化问题，所以求得的解是一个全部最优而不是局部最优解；</li><li>不仅适用于线性问题，使用核技巧后还能处理非线性问题；</li><li>对于高维样本空间的数据也能使用，因为数据集的复杂度只取决于支持向量而不是数据集的维度，可以避免“维度灾难”。</li></ul></li><li>缺点<ul><li>二次规划问题求解设计$m$阶矩阵的计算($m$为样本数)，所以SVM不适合超大数据集(SMO算法可缓解这个问题)；</li><li>样本数量比较多，效果不如神经网络。</li></ul></li></ul><h2 id="SVM是否可以使用随机梯度下降算法？"><a href="#SVM是否可以使用随机梯度下降算法？" class="headerlink" title="SVM是否可以使用随机梯度下降算法？"></a>SVM是否可以使用随机梯度下降算法？</h2><p><a href="https://www.zhihu.com/question/265751466/answer/1215966308">参考</a></p><p>SVM的求解本质上是个带约束的二次规划问题，可以通过拉格朗日乘子法或$Hinge Loss$转化为无约束的优化问题。$Hinge Loss$是个凸函数，可以使用随机梯度下降优化，只是使用拉格朗日乘子法对SVM优化有个好处，如果SVM有使用到核技巧，使用SMO算法直接求解比使用随机梯度下降更高效。</p>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k近邻算法</title>
      <link href="/academic_research/machine_learning/KNN/"/>
      <url>/academic_research/machine_learning/KNN/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>关于KNN的<a href="https://www.nowcoder.com/discuss/681294">问题</a>整理。</p><h2 id="KNN简介？"><a href="#KNN简介？" class="headerlink" title="KNN简介？"></a>KNN简介？</h2><p><a href="https://blog.csdn.net/zhangkkit/article/details/106173651">k近邻算法</a>(k-nearest neighbor)是一种有监督的分类算法，是通过测量不同特征向量之间的距离来进行分类的。它的思想是<b>如果一个样本在特征空间中最邻近的k个样本大多数属于某个类别，则该样本也属于这个类别。</b>算法过程为</p><ul><li>计算测试样本特征向量和其他每个样本的特征向量之间的距离；</li><li>对距离进行递增排序，选择距离最小的k个点；</li><li>确定这k个点所在类别出现频率；</li><li>返回这k个点出现频率最高的类别作为当前测试样本的预测类别。</li></ul><span id="more"></span><h2 id="KNN数据需要归一化么？"><a href="#KNN数据需要归一化么？" class="headerlink" title="KNN数据需要归一化么？"></a>KNN数据需要归一化么？</h2><p>数据是否归一化取决于模型是关注<b>变量的取值还是变量之间的分布</b>。KNN中有计算两个特征向量的距离操作，因此<font color='red'>需要进行数据归一化，来削弱不同特征之间数量级的差异性</font>。</p><h2 id="KNN优缺点？"><a href="#KNN优缺点？" class="headerlink" title="KNN优缺点？"></a>KNN优缺点？</h2><ul><li><a href="https://blog.csdn.net/zhangkkit/article/details/106173651">优点</a>：<ul><li>思想简单，既可以做分类，也可以做回归；</li><li>可用于非线性的分类；</li><li>适用于样本容量比较大的类域进行分类。</li></ul></li><li>缺点：<ul><li>当特征空间中样本数量和样本特征维度比较大时，计算量大，分类速度慢；</li><li>k值难以确定，一般多次交叉验证实验调整k值；</li><li>对不均衡的样本集敏感，当少数类的样本进行测试时，由于k近邻的样本属于多数类而导致分类错误。  </li></ul></li></ul><h2 id="KNN的k值怎么选？"><a href="#KNN的k值怎么选？" class="headerlink" title="KNN的k值怎么选？"></a>KNN的k值怎么选？</h2><p>一般通过多次实验以交叉验证的方式给k值打分，寻找分数最高的k值。</p><h2 id="KNN中k值的设置对模型有什么影响？"><a href="#KNN中k值的设置对模型有什么影响？" class="headerlink" title="KNN中k值的设置对模型有什么影响？"></a>KNN中k值的设置对模型有什么影响？</h2><ul><li>如果k值设置过小，会导致结果对近邻的样本点非常敏感，此时如果有噪声(样本打错标签)的影响，会导致预测错误，过小的k值会使得模型变复杂，容易过拟合到噪声；</li><li>如果k值设置过大，会导致某些其他类别的样本点也贡献了作用，会导致预测错误，过大的k值会使得模型变简单，容易欠拟合，模式倾向于输出类别数多的类；</li><li>如果k值设置等于样本数，此时无论测试输入是什么，模型只会输出类别数最多的类。</li></ul><h2 id="KNN三要素？"><a href="#KNN三要素？" class="headerlink" title="KNN三要素？"></a>KNN三要素？</h2><ul><li>距离度量：可以使用欧氏距离或者曼哈顿距离($L_p$距离的特例)进行度量；</li><li>k值的选择：一般通过多次交叉验证选择最优的k值；</li><li>分类决策规则：常用的是多数表决的规则。</li></ul><h2 id="在K-means或KNN中，用欧氏距离和曼哈顿距离度量有什么区别？"><a href="#在K-means或KNN中，用欧氏距离和曼哈顿距离度量有什么区别？" class="headerlink" title="在K-means或KNN中，用欧氏距离和曼哈顿距离度量有什么区别？"></a>在K-means或KNN中，用欧氏距离和曼哈顿距离度量有什么区别？</h2><p>曼哈顿距离和欧式距离的用途不一样。<br>对于$(x_1, y_1), (x_2, y_2)$，</p><p>欧式距离定义为<br>$$d(x,y):=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2}$$</p><p>曼哈顿距离定义为<br>$$d(x,y):=|x_1-y_1|+|x_2-y_2|$$</p><p>曼哈顿距离是在直接坐标系中两点所形成的线段对坐标轴的投影。曼哈顿距离只能计算水平或垂直的距离，有维度限制。而欧式距离可用于任何空间距离的计算。一般来说，数据点会存在于任何空间中，用欧氏距离更好点。</p><h2 id="kd树的结构？kd树的构建？KNN如何使用kd树？"><a href="#kd树的结构？kd树的构建？KNN如何使用kd树？" class="headerlink" title="kd树的结构？kd树的构建？KNN如何使用kd树？"></a>kd树的结构？kd树的构建？KNN如何使用kd树？</h2><p>关于kd树的<a href="https://zhuanlan.zhihu.com/p/23966698">详解</a>。</p><ul><li><p>kd树的结构是一个<b>二叉树</b>的结构，它的每一个节点<b>记录【特征坐标，切分轴，指向左孩子的指针，指向右孩子的指针】</b>，特征坐标是在线性空间$\R^n$中的一个点$(x_1,x_2,…,x_n)$，切分轴是指沿着第$r$轴$(1≤r≤n)$的一次切分，左右孩子仍是kd树，并且左孩子的特征点在特征空间上在根节点的左边，右孩子的特征点在根节点的右边。</p></li><li><p>kd树的构建，给定数据集$S\subseteq \R^n$和切分轴$r$，使用递归算法构建一个基于数据集的二叉树；</p><ul><li>如果集合$S$中的元素个数大于1，那么将所有点按第$r$个坐标进行排序，然后选出中位元素作为当前点的特征坐标(即切分为止)，并记录切分轴$r$；</li><li>再对中位元素之前的子集合$S_L$和之后的子集合$S_R$，更新$r$轴($r \leftarrow(r+1)\mod n$)，以第$r$轴为切分轴递归创建kd子树；</li><li>如果集合$S$中的元素个数等于1，那么当前特征点就是该处节点的特征数据。</li></ul></li><li><p>kd树的使用。任务是寻找距离测试点$p$最近的$k$个样本，记录在长度为$k$的列表$L$中。</p><ul><li>从根节点出发，根据$p$在第$r$轴的坐标值与当前特征节点的相应坐标值的大小比较，小于则会往左枝向下遍历，否则往右枝向下遍历；</li><li>到达叶节点后，如果$L$不满，把当前叶节点的特征坐标加入$L$，如果满了，计算当前叶节点和$p$的欧氏距离，同时找到$L$中的距离$p$最长的节点，如果当前距离小于最长距离，则当前节点替换最长距离节点，同时标记为已访问。</li><li>从叶节点向上回溯访问未访问过的节点，如果$L$不满，把当前节点的特征坐标加入$L$，如果满了，计算距离看是否进行节点的替换。<font color='grey'>(可通过计算$p$和切分面的距离看是否需要剪掉右子树，提升遍历效率)</font></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归和逻辑回归</title>
      <link href="/academic_research/machine_learning/Linear_and_Logistic_Regression/"/>
      <url>/academic_research/machine_learning/Linear_and_Logistic_Regression/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>关于线性回归和逻辑回归的<a href="https://www.nowcoder.com/discuss/681294">问题</a>整理。</p><h2 id="为什么逻辑斯蒂回归的输出值可以作为概率？"><a href="#为什么逻辑斯蒂回归的输出值可以作为概率？" class="headerlink" title="为什么逻辑斯蒂回归的输出值可以作为概率？"></a>为什么逻辑斯蒂回归的输出值可以作为概率？</h2><p>因为<a href="https://zhuanlan.zhihu.com/p/441128484">逻辑回归</a>使用的sigmoid函数可以<b>将线性函数映射到伯努利分布的期望</b>中，并且sigmoid函数是符合广义线性模型的伯努利分布规范的联系函数的反函数。</p><ul><li>联系函数：函数的反函数能够将线性方程映射到某个广义线性模型的期望；</li><li>广义线性模型：模型可以通过某些变换转化为线性模型。<span id="more"></span></li></ul><h2 id="LR推导目标函数和梯度。"><a href="#LR推导目标函数和梯度。" class="headerlink" title="LR推导目标函数和梯度。"></a>LR推导目标函数和梯度。</h2><p>LR(逻辑斯蒂回归)：从几率的概念构建线性回归模型。<br>$$几率=\frac{事件A发生的概率}{事件A不发生的概率}\in[0,+\infin)$$<br>几率缩写是odds，对数的取值是$R$。<br>二项逻辑斯蒂回归的条件概率分布$P$为<br>$$P(Y=1|x)=\frac{1}{1+e^{-{(\omega^Tx+b)}}}$$<br>$$P(Y=0|x)=\frac{e^{-{(\omega^Tx+b)}}}{1+e^{-{(\omega^Tx+b)}}}$$<br>$\omega^Tx+b$可令成列向量$\omega=[\omega,b]^T,x=[x,1]^T$，令$\pi(x)=P(Y=1|x)$，则有<br>$$\pi(x)=\frac{1}{1+e^{-\omega^Tx}}$$<br>$$1-\pi(x)=\frac{e^{-\omega^Tx}}{1+e^{-\omega^Tx}}$$<br>通过极大似然法估计$\omega$可得LR目标函数为<br>$$L(\omega)=\sum_{i=1}^N[y_ilog\pi(x_i)+(1-y_i)log(1-\pi(x_i))]$$ $$=\sum_{i=1}^N[y_ilog\pi(x_i)+log(1-\pi(x_i))-y_ilog(1-\pi(x_i))]$$ $$=\sum_{i=1}^N[y_ilog\frac{\pi(x_i)}{1-\pi(x_i)}+log(1-\pi(x_i))$$<br>将$\pi(x)=\frac{1}{1+e^{-\omega^Tx}}$带入上式，得到<b><font color='red'>目标函数</font></b>为<br>$$L(\omega)=\sum_{i=1}^N[y_i\omega^Tx_i-log(1+e^{\omega^Tx})]$$</p><p>对应的<b><font color='red'>梯度</font></b>为</p><p>$$\frac{\mathrm{d} L}{\mathrm{d} \omega}=yx-\frac{xe^{\omega^Tx}}{e^{\omega^Tx}+1}=x(y-\pi(x))$$</p><p>再利用梯度下降算法求解即可。</p><h2 id="分类问题和回归问题的区别？"><a href="#分类问题和回归问题的区别？" class="headerlink" title="分类问题和回归问题的区别？"></a>分类问题和回归问题的区别？</h2><ul><li>两者预测的目标变量类型不一样，分类问题的因变量是离散变量，回归问题的因变量是连续变量；<a href="https://blog.csdn.net/qq_43741312/article/details/98062287">参考</a></li><li>分类问题是定性问题，回归问题是定量问题；</li><li>它们的根本区别是输出空间<a href="https://blog.csdn.net/mipikun6449/article/details/119153488">是否为一个度量空间</a>。回归问题的输出空间定义了一个度量去预测输出值和真实值的误差；而分类问题不能来度量，只能具体分为某个类别。</li></ul><h2 id="逻辑回归模型是否需要归一化？"><a href="#逻辑回归模型是否需要归一化？" class="headerlink" title="逻辑回归模型是否需要归一化？"></a>逻辑回归模型是否需要归一化？</h2><ul><li><a href="https://blog.csdn.net/qq_38147421/article/details/120155996">需要。</a> 从梯度反向传播过程来看，逻辑回归模型的参数优化一般采用随机梯度下降算法，<b>如果不对特征进行归一化，可能会使得损失函数值的等高线呈椭球形，这样会花费更多的迭代步数才能到达最优解</b>；</li><li>从损失函数的角度看，逻辑回归的损失函数一般会加入正则化项，这会使得模型参数的大小会影响损失函数的值，而特征是否归一化又会影响模型的参数。所以有必要进行特征归一化。</li></ul><h2 id="逻辑回归和线性回归的异同？"><a href="#逻辑回归和线性回归的异同？" class="headerlink" title="逻辑回归和线性回归的异同？"></a>逻辑回归和线性回归的异同？</h2><ul><li>异：<ul><li>逻辑回归处理的是分类问题，线性回归处理的是回归问题。逻辑回归因变量的取值是一个二项分布，而线性回归输出是近似项。</li><li>逻辑回归的因变量是离散的，线性回归的因变量是连续的。</li></ul></li><li>同：<ul><li>二者都使用极大似然估计进行建模，假设逻辑回归的因变量$y$服从二项分布，则逻辑回归可看成广义的线性模型，可以使用对数似然函数求解参数，假设线性回归模型的<a href="https://blog.csdn.net/u010462995/article/details/70847146">因变量$y$服从正态分布</a>，可以使用最小二乘法求解参数。</li></ul></li></ul><h2 id="什么样的模型需要特征归一化？"><a href="#什么样的模型需要特征归一化？" class="headerlink" title="什么样的模型需要特征归一化？"></a>什么样的模型需要特征归一化？</h2><p><a href="https://blog.csdn.net/qq_38147421/article/details/120155996">是否需要归一化</a>要看<b>模型是关注变量的取值，还是关注变量的分布以及变量之间的关系</b>。</p><ul><li>SVM，线性回归等最优化问题需要归一化，模型更关注变量的取值；</li><li>像决策树和xgboost等概率模型是不需要进行归一化，模型更关注变量之间的关系；</li><li>神经网络一般是需要标准化(均值方差标准化或者最大最小值标准化)，这样做是为了弱化某些变量取值较大对模型产生影响。</li></ul><h2 id="如何提升逻辑回归的模型性能？"><a href="#如何提升逻辑回归的模型性能？" class="headerlink" title="如何提升逻辑回归的模型性能？"></a>如何提升逻辑回归的模型性能？</h2><p>逻辑回归是通过假设数据服从<b>伯努利分布</b>，通过极大似然估计的方法，利用梯度下降来求解参数，来到达将数据进行二分类的目的。</p><p><a href="https://zhuanlan.zhihu.com/p/46591702">提升性能</a>的方法有<b>特征离散化、特征交叉、使用正则化，调参(学习率或者正则化参数)，GBDT提取高阶特征</b>。</p><h2 id="最小二乘法什么条件下与极大似然估计等价？"><a href="#最小二乘法什么条件下与极大似然估计等价？" class="headerlink" title="最小二乘法什么条件下与极大似然估计等价？"></a>最小二乘法什么条件下与极大似然估计等价？</h2><p><b>当测量误差服从均值为0的正态分布时，二者等价。</b><br><a href="https://www.zhihu.com/question/20447622/answer/25186207">推导如下</a>:</p><p>线性回归模型为：<br>$$f(x)=\sum_{j=1}^dx_j\omega_j+ \epsilon=x\omega^T+\epsilon$$</p><p>其中$x\in\R^{1×d}，\omega\in\R^{1×d},\epsilon\in\R$。令$X={x_1,x_2,…,x_n} \in R^{n×d},y\in\R^{n×1}$，有<br>$$f(x)=X\omega^T+\epsilon$$<br>假设$\epsilon_i\sim(0,\sigma^2)$，则有$y_i\sim N(x_i\omega^T, \sigma^2)$，极大似然估计推导如下：<br>$$\underset {\omega} {\operatorname {argmax}} L(\omega)=ln \overset{n}{\underset{i=1}{\Pi}}\frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(y_i-x_i\omega^T)^2}{2\sigma^2}}=-nln\sqrt{2\pi}\sigma-\overset{n}{\underset{i=1}{\sum}}\frac{(y_i-x_i\omega^T)^2}{2\sigma^2}$$<br>上式等价于<br>$$\underset {\omega} {\operatorname {argmin}} L(\omega)=\overset{n}{\underset{i=1}{\sum}}(y_i-x_i\omega^T)^2$$<br>即最小二乘法。</p><h2 id="逻辑回归为什么要做特征离散化？"><a href="#逻辑回归为什么要做特征离散化？" class="headerlink" title="逻辑回归为什么要做特征离散化？"></a>逻辑回归为什么要做特征离散化？</h2><ul><li><a href="https://blog.csdn.net/yang090510118/article/details/39478033">离散化</a>后稀疏向量的内积<b>乘法运算速度快</b>，计算简单；</li><li>离散化后的特征能使得对异常数据的值具有<b>较强的鲁棒性</b>；</li><li>逻辑回归属于广义线性模型，表达能力有限，进行特征离散化后相当于<b>为模型引入了非线性</b>，能增强模型的泛化能力。</li></ul><h2 id="逻辑回归怎么实现多分类？"><a href="#逻辑回归怎么实现多分类？" class="headerlink" title="逻辑回归怎么实现多分类？"></a>逻辑回归怎么实现多分类？</h2><ul><li>根据<b>每个类别构建一个二分类器</b>，本类别的样本标签定义为1，其他类别定义为0，有多少个类别就构建多少个二分类器。</li><li>也可以<b>使用softmax损失函数实现多分类</b>，softmax的输出是每个样本对应各个类别的概率，最后的预测类型是输出概率最高的类别。</li><li>若所有类别之间有明显的互斥关系，则使用softmax分类器，若所有类别之间不互斥并且有交叉，则考虑构建类别数个逻辑回归分类器。</li></ul><h2 id="逻辑回归为什么不用平方损失函数？"><a href="#逻辑回归为什么不用平方损失函数？" class="headerlink" title="逻辑回归为什么不用平方损失函数？"></a>逻辑回归为什么不用平方损失函数？</h2><p><a href="https://zhuanlan.zhihu.com/p/46591702">不使用平方损失</a>，因为逻辑回归使用Sigmoid函数作为样本概率输出时，<b>使用平方损失会使得构造出来的损失函数是非凸的，不容易求解，并且参数容易陷入局部最优解</b>。而使用极大似然估计，目标函数是对数似然函数，该函数时未知参数的高阶连续可导的凸函数，便于求解全局最优解。</p>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评价指标的那些事儿</title>
      <link href="/academic_research/machine_learning/PR_and_F_and_ROC/"/>
      <url>/academic_research/machine_learning/PR_and_F_and_ROC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>关于机器学习中的<a href="https://www.nowcoder.com/discuss/681294">评价指标概念</a>的问答。</p><span id="more"></span><h2 id="分类模型常用的评价指标有？-分类模型的评价指标"><a href="#分类模型常用的评价指标有？-分类模型的评价指标" class="headerlink" title="分类模型常用的评价指标有？(分类模型的评价指标)"></a>分类模型常用的评价指标有？(分类模型的评价指标)</h2><p><a href="https://zhuanlan.zhihu.com/p/258596465">评价指标</a>有</p><ul><li><p><b>混淆矩阵</b></p><table><thead><tr><th align="center">真实结果</th><th align="center">预测为正例</th><th align="center">预测为反例</th></tr></thead><tbody><tr><td align="center">正例</td><td align="center">TP（真正例）</td><td align="center">FN（假反例）</td></tr><tr><td align="center">反例</td><td align="center">FP（假正例）</td><td align="center">TN（真反例）</td></tr></tbody></table><p>矩阵的非对角线元素为0得到完美分类器。</p></li><li><p><b>准确率(Accuracy)和错误率(Error Rate)</b></p><ul><li>ACC：所有样本中预测正确样本的比例；</li><li>Error Rate：所有样本中预测错误样本的比例。<br>$$ACC=\frac{TP+TN}{TP+TN+FP+FN}$$<br>$$Error Rate=\frac{FP+FN}{TP+TN+FP+FN}=1-ACC$$<br>ACC和Error Rate缺点：测试类别极度不均衡时，无法反映算法的性能。</li></ul></li><li><p><b>精确率(Precision)和召回率(Recall)</b></p><ul><li>精确率(precision)：预测为真时，正确的结果占<b>预测结果</b>的比例。<br></li><li>召回率(recall)：预测为真时，正确的结果占<b>真实结果</b>的比例。<br></li></ul><p>$$P=\frac{TP}{TP+FP}$$<br>$TP+FN$表示该类真实的样本数，查全率为<br>$$R=\frac{TP}{TP+FN}$$</p></li><li><p><b>F1-score</b><br>当P和R出现矛盾，需要综合考虑时，可以使用<i>F-Measure(F-Score)</i>，它是P和R<font color='red'>调和平均</font>的结果，公式如下。<br>$$\frac{1}{F_\beta}=\frac{1}{\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})$$<br><font color='red'>当$\beta=1$时，也就是常见的$F1$度量，当$F1$越高，模型的性能越好。</font>查准率和查全率的调和平均，比算术平均（求和除以2）和几何平均（平方再相乘开方）更重视较小值。</p></li><li><p><b>ROC曲线</b><br>受试者操作特征曲线(Receiver Operating Characteristic curve, ROC)是以”假正例率”(False Positive Rate，FPR)为横坐标，”真正例率”(True Positive Rate, TPR)为纵坐标的曲线，其中TPR只和正例样本数据有关，FPR只和负例样本数据有关。所以ROC曲线不受正负样本比例的影响。<br>$$TPR=\frac{TP}{TP+FN}$$<br>$$FPR=\frac{FP}{FP+TN}$$<br>且FPR低的同时能有高的TPR(曲线越靠近左上角且越陡峭，模型越理想)。</p></li><li><p><b>AUC(一般指ROC下的面积，也有PR_AUC)</b><br> 曲线下的面积越大，模型性能越理想。</p></li><li><p><b>KS曲线</b><br>FPR表示模型对于负样本误判的程度，而TPR表示模型对正样本召回的程度。KS曲线是TPR曲线和FPR曲线的最大间隔距离。<br>$$KS=max(TPR-FPR)\in[0,1]$$</p></li><li><p><b>P-R曲线</b></p></li><li><p><b>宏平均和微平均</b></p></li></ul><h2 id="介绍下查准率-查全率-F1？"><a href="#介绍下查准率-查全率-F1？" class="headerlink" title="介绍下查准率/查全率/F1？"></a>介绍下查准率/查全率/F1？</h2><p>二分类问题在正反例类别不均衡时，acc作为评价指标则失去意义。此时可以考虑查准率和查全率。<br><br>查准率(precision)：预测为真时，正确的结果占<b>预测结果</b>的比例。<br><br>查全率(recall)：预测为真时，正确的结果占<b>真实结果</b>的比例。<br><br>举例：70张猫和30张狗的图像，经过某个分类器判断，得到50张猫和50张狗的输出。预测的50张狗的图像假设有30张是狗。此时总的准确率为$(50+30)/100=80%$，狗的精确率为$30/50=0.6$，召回率为$30/30=1$</p><p>用混淆矩阵表示如下：</p><table><thead><tr><th align="center">真实结果</th><th align="center">预测为正例</th><th align="center">预测为反例</th></tr></thead><tbody><tr><td align="center">正例</td><td align="center">TP（真正例）</td><td align="center">FN（假反例）</td></tr><tr><td align="center">反例</td><td align="center">FP（假正例）</td><td align="center">TN（真反例）</td></tr></tbody></table><p>准确率定义为<br>$$ACC=\frac{TP+TN}{TP+TN+FP+FN}$$<br>查准率为<br>$$P=\frac{TP}{TP+FP}$$<br>$TP+FN$表示该类真实的样本数，查全率为<br>$$R=\frac{TP}{TP+FN}$$</p><p><b>当P和R出现矛盾，需要综合考虑时，可以使用<i>F-Measure(F-Score)</i>，它是P和R<font color='red'>调和平均</font>的结果</b>，公式如下。<br>$$\frac{1}{F_\beta}=\frac{1}{\beta^2}(\frac{1}{P}+\frac{\beta^2}{R})$$<br><font color='red'>当$\beta=1$时，也就是常见的$F1$度量，当$F1$越高，模型的性能越好。</font>查准率和查全率的调和平均，比算术平均（求和除以2）和几何平均（平方再相乘开方）更重视较小值。</p><h2 id="介绍下P-R曲线？"><a href="#介绍下P-R曲线？" class="headerlink" title="介绍下P-R曲线？"></a>介绍下P-R曲线？<br></h2><p><a href="https://zhuanlan.zhihu.com/p/404798546">P-R曲线</a>描述的是查准率-查全率变化的曲线。</p><p>假设模型只输出正例的预测概率，对测试样本的预测结果进行降序排列，按降序的结果把每个预测概率作为区分正反例的阈值，以查全率为横坐标。查准率为纵坐标，从最小阈值和<code>recall=1</code>开始，从右往左绘制曲线，可得下图。<br><img src="https://s1.ax1x.com/2022/04/13/LKDo3q.png"/ loading="lazy"></p><p>P-R曲线对模型性能的评估，一般可以通过<b>P-R曲线下的面积</b>大小(Area Under Curve, AUC)来估算，如果曲线有交叠，也可以通过<b>“平衡点”</b>(Break-Event Point, BEP)来估算。即当P=R时，平衡点的取值越高，模型性能越好。</p><h2 id="如何理解宏平均和微平均？"><a href="#如何理解宏平均和微平均？" class="headerlink" title="如何理解宏平均和微平均？"></a>如何理解宏平均和微平均？<br></h2><ul><li>宏平均(macro average)：将每个类别的P、R、F单独计算，然后所有类别的指标直接取平均。</li><li>微平均(micro average)：把所有类别都考虑进来，统计计算P、R、F。<br>如二分类中，<br>$$micro-P=\frac{TP1+TP2}{TP1+FP1+TP2+FP2}$$</li></ul><p>在多分类的类别不均衡问题中，使用微平均的更关注少数类别。宏平均和微平均公式如下。</p><img src="https://s1.ax1x.com/2022/04/13/LKIh9K.png" / loading="lazy"><h2 id="ROC曲线有什么优点？"><a href="#ROC曲线有什么优点？" class="headerlink" title="ROC曲线有什么优点？"></a>ROC曲线有什么优点？<br></h2><p>PR曲线和ROC(Receiver Operating Characteristics)曲线对不平衡数据的<a href="https://blog.csdn.net/j05073094/article/details/119985348?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3">表现不同</a>。接受者操作特征曲线是根据混淆矩阵得到的。</p><ul><li>PR曲线对数据不平衡是敏感的，正反例的比例变化会使得PR曲线发生很大变化；因为P和R的计算依赖于不同类别。</li><li>ROC曲线是以”假正例率”(False Positive Rate，FPR)为横坐标，”真正例率”(True Positive Rate, TPR)为纵坐标的，FPR和TPR的计算只依赖于统一类别数据内部。故ROC曲线对数据不平衡并不敏感。</li></ul><h2 id="AUC是什么？AUC是否对正负样本比例敏感？"><a href="#AUC是什么？AUC是否对正负样本比例敏感？" class="headerlink" title="AUC是什么？AUC是否对正负样本比例敏感？"></a>AUC是什么？AUC是否对正负样本比例敏感？<br></h2><p>PR曲线也存在AUC，但是一般所说的<a href="https://zhuanlan.zhihu.com/p/79698237">AUC</a>(Area Under Curve)是指ROC曲线下的面积，<font color='red'><b>ROC曲线的横坐标是FPR，FPR只关注负样本，与正样本无关，TPR只关注正样本，与负样本无关</b></font>，所以对横纵轴进行积分当然也不会对正负样本比例敏感。<br>$$AUC=\int_{t=\infty}^{\infty}y(t)dx(t)$$</p><h2 id="AUC的意义以及两种计算方式？"><a href="#AUC的意义以及两种计算方式？" class="headerlink" title="AUC的意义以及两种计算方式？"></a>AUC的意义以及两种计算方式？<br></h2><ul><li><a href="https://zhuanlan.zhihu.com/p/54707294">意义</a>：正例预测为正的概率值大于反例预测为负的概率值的可能性。</li><li>计算方法：<ul><li>绘制ROC曲线，计算ROC曲线下的面积；</li><li>计算样本中正例预测为正样本的概率值大于反例预测成负样本的概率值的个数，累加计数再除以总样本数。</li></ul></li></ul><h2 id="AB-test的原理？"><a href="#AB-test的原理？" class="headerlink" title="AB test的原理？"></a>AB test的原理？<br></h2><p>《百面机器学习》</p><p>AB Test是为了验证新模型、新产品或者新算法是否有提升的测试方法。  </p><ul><li>离散评估无法完全消除模型过拟合的影响；</li><li>离散评估无法还原线上的工程环境；</li><li>线上系统的某些商业指标在离线评估中无法使用。<br>AB Test的主要方法是对用户进行分桶，分为对照组和实验组，分桶的过程中要保证桶内样本的独立性和采样方式的无偏性。对实验组的用户实施新模型，对对照组的用户实施旧模型。根据检验指标判断AB两个模型对象哪个方案效果更好。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次对比选择编码(HCSC)</title>
      <link href="/academic_research/self_supervised_contrastive_learning/HCSC/"/>
      <url>/academic_research/self_supervised_contrastive_learning/HCSC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>论文题目：HCSC: Hierarchical Contrastive Selective Coding<br><br>code：<a href="https://github.com/gyfastas/HCSC">https://github.com/gyfastas/HCSC</a></p><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>1、对于Instance-wise的对比学习方法(SimCLR, MoCo, SigSiam等)，它们过度关注到实例特征之间的关系，却忽略了整个数据集的语义结构。<br><br>2、对于原型对比学习方法，它们更多是在单个层级上做聚类，没有考虑到数据集的多层级的特性。<br></p><span id="more"></span><p>如下图所示，Instance-wise的对比学习方法更关注的是某个狗的样本和其增扩之间的关系，原型对比学习方法关注的是狗这一类别单个层级的聚类关系，但是实际上狗的类别还能在细分层级，层级下也有对应的原型。</p><img src="https://s1.ax1x.com/2022/03/12/bHhmZQ.png"/ loading="lazy"><h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><p>1、针对于原型对比学习，本文提出使用分层级的原型来获得数据集的不同层级的语义结构；<br><br>2、针对于实例级别对比学习和原型对比学习，根据不同层级的原型在训练时，制定更合适的样本选择和原型选择的策略。在训练时，对于样本的选择，该策略旨在从样本队列中，寻找当前样本所属的原型，和该原型距离最远的<font color='red'>相同层级的其他原型群组</font>的样本作为负样本。对于原型的选择，该策略旨在从原型队列中，选择和<font color='red'>当前样本所属原型的父亲原型</font>距离最远的原型作为负原型。<br></p><h1 id="问题建模"><a href="#问题建模" class="headerlink" title="问题建模"></a>问题建模</h1><blockquote><p>怎么进行分层级原型的聚类呢？</p></blockquote><p>给定无标签图像$X= \{x_1,x_2,…,x_N \}$，图像经过backbone提取的特征为$Z= \{z_1,z_2…,z_N \}$，其中$x_i\in X$，$z_i \in R^{\delta}$，$i=1,2,…,N$。对于整个数据集，可分为$L$个分级原型，每个分级原型由$M_l$个小原型$c_i$组成，每个小原型$c_i \in R^{\delta}$，$L$个分级原型的集合可定义为$C= [ {\{c_i^l\}_{i=1}^{M_l}} ]_{l=1}^L$。</p><p>文中实验是设置$L=3$，每个分级原型的小原型数量分别是$M_1=3000, M_2=2000, M_3=1000$，聚类后原型空间中个数小于10个样本的原型被丢弃。具体可参考下图。<br></p><img src="https://s1.ax1x.com/2022/03/21/qmIj0J.jpg"/ loading="lazy"><h2 id="分层的语义表示"><a href="#分层的语义表示" class="headerlink" title="分层的语义表示"></a>分层的语义表示</h2><p>文中利用<a href="https://blog.csdn.net/jwh_bupt/article/details/7685809">层次聚类算法(Hierarchical K-Means)</a>对$Z=\{z_1,z_2…,z_N\}$来进行分层级聚类。最后利用无向图$Z$将节点连接成树形结构。</p><img src="https://s1.ax1x.com/2022/03/21/qmo0jU.jpg"/ loading="lazy"><p>语义表示的结构结果展示如下。<br><br><img src="https://s1.ax1x.com/2022/03/21/qmT4Gq.jpg"/ loading="lazy"></p><h2 id="负样本和负原型的选择"><a href="#负样本和负原型的选择" class="headerlink" title="负样本和负原型的选择"></a>负样本和负原型的选择</h2><p>特征表示$z$和原型$c$的距离定义为</p><img src="https://s1.ax1x.com/2022/03/21/qm7v7Q.jpg"/ loading="lazy"><h3 id="负样本的选择"><a href="#负样本的选择" class="headerlink" title="负样本的选择"></a>负样本的选择</h3><p>在相同的层级$l$下，寻找和当前样本$z$所属的原型$c^l(z)$，和该原型距离最远的<font color='red'>其他原型群组</font>的样本作为负样本。在队列中的样本$z_j$选择的概率为</p><img src="https://s1.ax1x.com/2022/03/21/qmbP5d.jpg"/ loading="lazy"><p>再将上述概率在伯努利分布下进行采样，有下式：<br></p><img src="https://s1.ax1x.com/2022/03/21/qnGrsH.jpg"/ loading="lazy"><p>将上述结果带入InfoNCE loss可得下式：</p><img src="https://s1.ax1x.com/2022/03/21/qnGDQe.png"/ loading="lazy"><h3 id="负原型的选择"><a href="#负原型的选择" class="headerlink" title="负原型的选择"></a>负原型的选择</h3><p>从原型队列中，选择和<font color='red'>当前样本所属原型的父亲原型</font>距离最远的原型作为负原型。<br>举例来说，对于同一层级下有萨摩耶，贵宾和拉布拉多，萨摩耶和这两类狗的距离更近，和其他父亲原型（猫类）的子原型（波斯猫等）距离更远。所以负原型应该从其他父亲原型的子原型中选择。在队列中的原型$c_j$被选择的概率为<br></p><img src="https://s1.ax1x.com/2022/03/21/qnNOHJ.jpg"/ loading="lazy"><p>再将上述概率在伯努利分布下进行采样，有下式：<br><br><img src="https://s1.ax1x.com/2022/03/21/qnNLB4.jpg"/ loading="lazy"></p><p>将上述结果带入ProtoNCE loss可得下式：</p><img src="https://s1.ax1x.com/2022/03/21/qnaVLF.jpg"/ loading="lazy"><p>通过上述两种负样本和负原型的选择策略，得到如下结果。<br></p><img src="https://s1.ax1x.com/2022/03/21/qnary8.jpg"/ loading="lazy"><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>1、对于数据集的所分的层级是敏感的；<br><br>2、对于原型的数量也是敏感的。<br></p>]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self_supervised_contrastive_learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型对比学习（PCL）</title>
      <link href="/academic_research/self_supervised_contrastive_learning/PCL/"/>
      <url>/academic_research/self_supervised_contrastive_learning/PCL/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>论文题目：Prototypical Contrastive Learning of Unsupervised Representations<br><br>code: <a href="https://github.com/salesforce/PCL">https://github.com/salesforce/PCL</a></p><h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><p>如今自监督对比学习的经典做法离不开数据增扩和对比损失，针对于对比损失而言，在batch里面划分正负样本的做法会忽视数据的语义结构表示，许多具有相似语义结构的负样本实例在特征空间其实不希望被拉开距离，但是对比损失会放大他们之间的差距。</p><span id="more"></span><h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><p>1、在自监督对比学习的特征空间引入聚类，聚类希望语义相似的负样本实例约束在同一个原型群组中，不会因为对比损失而拉大差距；<br><br>2、提出原型的概念，一个原型是指相似语义结构的特征表示聚在一个群组（图中的圆）中的embedding；即使是负样本，语义结构相似的应该属于同一群组（同一个圆内）。<br><br>3、为了估计每个原型群组中的特征分布，文章把泛化InfoNCE loss为ProtoNCE loss；<br><br>4、将整个数据集的图像分配给不同粒度的多个原型群组。<br></p><p>图中绿框表示粗粒度的原型群组，原型是绿点，只要是有马都归在这个原型群组中，人马也属于该原型群组中的一个细粒度的原型群组(图中左边的蓝框)。</p><p>图中两个蓝框表示在细粒度的原型群组中，负样本会给约束在原型空间中，而不是单纯被InfoNCE loss拉远。</p><img src="https://s1.ax1x.com/2022/03/12/b7SYVI.md.png"/ loading="lazy"><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><h2 id="极大似然估计"><a href="#极大似然估计" class="headerlink" title="极大似然估计"></a>极大似然估计</h2><p>多数情况下我们是根据输入样本和模型参数来推算结果，而极大似然估计是已知输入样本及其服从的分布，然后寻求使该结果出现的可能性最大的条件，以此来估计参数。附上<a href="https://www.cnblogs.com/coshaho/p/9573367.html">极大似然估计讲解</a>。</p><h2 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h2><p>EM算法主要解决在极大似然估计中，输入数据的概率分布未知的问题，通过引入隐变量$𝒛$的分布，方便对参数$\theta$进行极大似然估计。<br>附上<a href="https://blog.csdn.net/v_july_v/article/details/81708386">EM算法讲解</a>。</p><ul><li>E Step：隐变量的条件概率分布的期望的求解——根据当前的模型参数$\theta^{(i)}$和观测数据$X$求得隐变量的条件概率分布期望$Q(z^{(i)})$；</li><li>M Step：参数的求解——根据$Q(z^{(i)})$求参数$\theta^{(i)}$的似然函数，通过取对数求导，令导数等于0得到模型参数$\theta^{(i+1)}$。<br>重复上述操作。直到$\theta$收敛。</li></ul><p>训练过程如下：<br>采用MoCo的架构，把原型的embedding当成隐变量$C=\{c_i\}_{i=1}^k$，通过E step可得到$Q(c_i) = p(c_i;x_i,\theta)$，通过M step求得网络参数$\theta^\star$，整个训练的损失函数为</p><p>$$L_{ProtoNCE}=L_{infoNCE} + L_{Proto}$$</p><h2 id="网络参数具体求解"><a href="#网络参数具体求解" class="headerlink" title="网络参数具体求解"></a>网络参数具体求解</h2><p>建议看完<a href="https://www.cnblogs.com/coshaho/p/9573367.html">极大似然估计讲解</a>再往下看。<br>给定训练集$X={x_1,x_2,…,x_n}$，之前对比学习的做法是将$X$映射到$V={v_1,v_2,…,v_n}$，再使用如下对比损失进行优化求参数。<br><img src="https://s1.ax1x.com/2022/03/12/b7S3KH.png" / loading="lazy"></p><p>在原型对比学习中，用原型$c$当成隐变量，代替特征$v^{\prime}$，温度系数被替换成为原型浓度估计$\phi$。<br>$n$张图像的极大似然估计为</p><img src="https://s1.ax1x.com/2022/03/12/b7Slxe.png"/ loading="lazy"><p>引入隐变量$C=\{c_i\}_{i=1}^k$，有</p><img src="https://s1.ax1x.com/2022/03/12/b7S0xg.png"/ loading="lazy"><p>假设$Q(c_i)$是原型$c$的分布，上式经过Jensen不等式和丢弃常数项的操作后可优化为<br></p><img src="https://s1.ax1x.com/2022/03/12/b7SQ2D.png"/ loading="lazy"><h3 id="E-step"><a href="#E-step" class="headerlink" title="E step"></a>E step</h3><p>目的是得到$p(c_i,x_i;\theta)$的期望。Momentum encoder输出特征$v_i^{\prime}=f_{\theta^\prime}(x_i)$在$p(c_i,x_i;\theta)$的分布下使用K-means算法，可以得到$k$个聚类中心。$x_i\in c_i$输出1，否则0。</p><h3 id="M-step"><a href="#M-step" class="headerlink" title="M step"></a>M step</h3><p>目的是求解参数$\theta$。<br>当且仅当$Q(c_i)=p(x_i,c_i;\theta)$时，(6)式有最大下界。可得下式。</p><img src="https://s1.ax1x.com/2022/03/12/b7S8rd.png"/ loading="lazy"><p>假设聚类的质心是均匀的，有下式。</p><img src="https://s1.ax1x.com/2022/03/12/b7Stat.png"/ loading="lazy"><p>为求解参数，再假设每个原型的分布是各项均匀的高斯分布，有</p><img src="https://s1.ax1x.com/2022/03/12/b7SNIP.png"/ loading="lazy"><p>可解得网络参数为</p><img src="https://s1.ax1x.com/2022/03/12/b7SaPf.png"/ loading="lazy"><p>上述是聚类算法的网络参数解法。联合对比学习损失函数可得下式。</p><img src="https://s1.ax1x.com/2022/03/12/b7SwRS.png"/ loading="lazy"><h3 id="浓度系数估计"><a href="#浓度系数估计" class="headerlink" title="浓度系数估计"></a>浓度系数估计</h3><p>系数$\phi$反映原型群组聚集的紧密程度，$\phi$越小表示群组越小，且聚合度高。用于衡量特征$v_z^\prime$和对应原型$c$之间的相似度。定义为</p><img src="https://s1.ax1x.com/2022/03/12/b7SdG8.png"/ loading="lazy"><p>momentum编码器的输出特征为$\{v_z^{\prime}\}_{z=1}^Z$。</p><h1 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h1><h2 id="TSNE图"><a href="#TSNE图" class="headerlink" title="TSNE图"></a>TSNE图</h2><p>在ImageNet上训练前40类的TSNE图。</p><img src="https://s1.ax1x.com/2022/03/12/b7Srrj.png"/ loading="lazy"><h2 id="粗细粒度分类展示"><a href="#粗细粒度分类展示" class="headerlink" title="粗细粒度分类展示"></a>粗细粒度分类展示</h2><p>绿框和黄框表示聚类结果（粗粒度的原型），绿框属于聚类结果中更细粒度的原型。像在马的粗粒度原型中，人和马就是细粒度的原型。换句话说，在马的类别，含有人马之间的图像距离更近。</p><img src="https://s1.ax1x.com/2022/03/12/b7Ssqs.png"/ loading="lazy">]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> self_supervised_contrastive_learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流形简介</title>
      <link href="/academic_research/manifold_learning/manifold_learning_introduction/"/>
      <url>/academic_research/manifold_learning/manifold_learning_introduction/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>最近导师D说D项目可能可以考虑下流形学习。因此特地去了解下。</p><h1 id="流形学习的假设"><a href="#流形学习的假设" class="headerlink" title="流形学习的假设"></a>流形学习的假设</h1><ul><li>所观测到的数据是高维的，高维数据受数据特征的限制会存在冗余信息，实际上用某个低维向量就能得到唯一表示；</li><li>高维空间的表示有冗余，映射到低维空间的表示没有冗余，低维空间称为“流形空间”。<span id="more"></span></li></ul><h1 id="举例：在地球仪上计算北京到上海"><a href="#举例：在地球仪上计算北京到上海" class="headerlink" title="举例：在地球仪上计算北京到上海"></a>举例：在地球仪上计算北京到上海</h1><ul><li><p>我们关注地表的距离，而不是三维空间的欧氏距离；</p></li><li><p>从高维空间上看，北京的坐标是$(x_1,y_1,z_1)$，上海的坐标是$(x_2,y_2,z_2)$，采用空间欧式距离两个点之间的距离是$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$，但是这种方式度量两个城市之间的距离不准确；</p></li><li><p>把三维的地球展成二维平面，二维平面就是合适的流形空间，此时北京的坐标是$(x_1,y_1)$，上海的坐标是$(x_2,y_2)$，采用空间欧式距离两个点之间的距离是$\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$，此时使用欧式距离度量才有意义。</p></li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>1、只有流形空间上使用欧式距离才有意义；</p><p>2、$m$维流形所展开的$n$维空间$(m&lt;n)$不适合使用欧氏距离。</p><h1 id="图解二维流形——瑞士卷"><a href="#图解二维流形——瑞士卷" class="headerlink" title="图解二维流形——瑞士卷"></a>图解二维流形——瑞士卷</h1><p>假设观测的数据是三维的，在流形空间比在三维空间上做欧氏距离更有意义。<br><img src="https://s1.ax1x.com/2022/03/06/brrYEF.jpg"/ loading="lazy"></p><h1 id="流形学习研究内容"><a href="#流形学习研究内容" class="headerlink" title="流形学习研究内容"></a>流形学习研究内容</h1><ul><li>在得到模型有效的高维特征表示后，如何实现高维到低维空间的非线性降维，这种降维既能保证能合理使用欧式距离，也能考虑到数据的拓扑结构；</li><li>如何保证映射的低维空间是流形空间。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1、<a href="https://www.zhihu.com/question/24015486/answer/194284643">https://www.zhihu.com/question/24015486/answer/194284643</a></p><p>2、<a href="https://blog.pluskid.org/archives/533">https://blog.pluskid.org/archives/533</a></p>]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> manifold_learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年阅读摘抄</title>
      <link href="/reading/2020/"/>
      <url>/reading/2020/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a><b>写在前面</b></h2><p>&emsp;&emsp;三月份开学一直在忙些科研的事情，异常检测实验和声源定位实验暂时告一段落。五一放假了(●ˇ∀ˇ●)，终于有心思整理下去年在微信读书的一些阅读摘抄。其实读书做摘抄是为了改日方便回味这本书之前自己喜欢的部分，毕竟自己做整理，也算没白过此书。而且看看用这种方式能不能鞭笞自己多看点书，二话少说，来回顾下吧~</p><img src="https://z3.ax1x.com/2021/05/04/gukARU.png" alt="gukARU.png" border="0" zoom="60%"/ loading="lazy"><span id="more"></span><h2 id="《你的孩子不是你的孩子》"><a href="#《你的孩子不是你的孩子》" class="headerlink" title="《你的孩子不是你的孩子》"></a><b>《你的孩子不是你的孩子》</b></h2><img src="https://z3.ax1x.com/2021/05/04/gukYsH.jpg" alt="gukYsH.jpg"/ loading="lazy"><p>简介：这本书作者是台湾作家吴晓乐。我记得作者好像是作为一个补习家教的视角去审视各种家长对自己孩子所谓的“爱”，每章由一个个故事串联组成。</p><h3 id="第五章-人子与猫的孩子"><a href="#第五章-人子与猫的孩子" class="headerlink" title="第五章 人子与猫的孩子"></a>第五章 人子与猫的孩子</h3><ol><li>“老师打我，是我的错，我没有把题目做好。我跟妈妈说，妈妈只会更生气，搞不好也会打我一顿。”我不禁怀疑：眼镜仔不是笨，也不是迟钝。他不过是个吓坏的孩子。</li><li>小圆妈是家庭主妇，又不喜外出，也不热衷社交，她能说心事的伙伴就那么两三个。她的存在价值，是肯定，还是否定，主要交由丈夫来决定。然而丈夫给的期望太沉重，她一个人难以承受，只得分流给眼镜仔，分流给我这个一周不过出现五小时的外人。<i><font color='blue'>(喵语：职位为大经理的丈夫应酬交谈儿女话题被同事比下去，将孩子不挣气的气撒在平时一周抽空见不到几个小时的妻子身上，妻子夙兴夜寐，拳打语踢，让孩子的自信心碾为尘土，只为让孩子成绩超过台北市90%初中生。这或许从一开始就错了。)</font></i></li></ol><h3 id="第六章-一脉不相承"><a href="#第六章-一脉不相承" class="headerlink" title="第六章 一脉不相承"></a>第六章 一脉不相承</h3><ol start="3"><li>小叶出生后，我们都很辛苦，我有我的压力，她有她的。小叶一天一天长大，外界对她的期待越来越多，我不能置之不管，只好勉强她去迎合他们的眼光。有时候，我会想，是不是世界上没有别人，只剩下我们两个，我才能好好爱她？</li><li>丈夫的父爱是有条件的，他只在小叶考了第三名那次才像个父亲。会不会有一个可能，永信的父母也是这样告诉他的，只有成功的小孩才能获得被爱的资格？</li></ol><h3 id="第十章-天赋"><a href="#第十章-天赋" class="headerlink" title="第十章 天赋"></a>第十章 天赋</h3><ol start="5"><li>也是在这个时刻，我初探教育的本质。教育的存在，不是让每个孩子都拿到很高的分数，而是要让每个孩子的天赋都能伸展到极限，并且尊重他最终的成果。</li></ol><h3 id="第十章-怪兽都聚在一起了"><a href="#第十章-怪兽都聚在一起了" class="headerlink" title="第十章 怪兽都聚在一起了"></a>第十章 怪兽都聚在一起了</h3><ol start="6"><li>少子化所衍生的负面效应，一般人往往从世代更替、抚养比的角度出发，在我看来，他们少提了一个很重要的层面：少子化制造出一对自以为是的学生与刁钻的家长。</li></ol><h3 id="第十三章-高材生的独白"><a href="#第十三章-高材生的独白" class="headerlink" title="第十三章 高材生的独白"></a>第十三章 高材生的独白</h3><ol start="7"><li>母亲对于“成功”的认知太狭隘了，她定义中的成功，就是在学术上、职业上取得稳定、可供辨识的成就。至于美感、人与人之间的情感、生活中那些琐碎而美好的小事，母亲觉得这些都是次要的，花太多时间就是浪费生命。</li></ol><h3 id="第十四章-后记：莫失莫忘"><a href="#第十四章-后记：莫失莫忘" class="headerlink" title="第十四章 后记：莫失莫忘"></a>第十四章 后记：莫失莫忘</h3><ol start="8"><li>每一个小孩，或者该说每一个人，有其存在的独特性。有太多父母执意要小孩去临摹其他人的行为，复制类似的成功经验，去追求他们眼中的理想人生，圆满他们年轻时未竟的梦，甚至驱策小孩成为“第二个自己”。仿佛一个生命的诞生，是为了满足、成就另一个生命。就小孩的立场来说，“为了达成某个目的，自己才被生下来”，也是很可悲的一件事。</li></ol><h2 id="《谁动了我的奶酪》"><a href="#《谁动了我的奶酪》" class="headerlink" title="《谁动了我的奶酪》"></a><b>《谁动了我的奶酪》</b></h2><img src="https://z3.ax1x.com/2021/05/04/gunn10.jpg" alt="gunn10.jpg" border="0" / loading="lazy"><p>简介：这本书作者是斯宾塞·约翰逊。大概阐述一个“生于忧患，死于安乐”的道理，勇于跳出自己的舒适区，道理确实不错，但是书中的两个小矮人也挣扎了好久。</p><h3 id="芝加哥的同学聚会"><a href="#芝加哥的同学聚会" class="headerlink" title="芝加哥的同学聚会"></a>芝加哥的同学聚会</h3><ol><li>他们突然意识到，虽然大家现在所从事的职业各不相同，有的是自由职业者，有的是公司经理，但都有同样的感受——害怕变化，于是不禁笑了起来。<i><font color='blue'>(喵语：人们害怕去改变，往往所处的场景是相对安逸舒适的，改变后的情况如何如果不能得到预知，便会处于迷茫和无动于衷。)</font></i></li></ol><h3 id="故事正文"><a href="#故事正文" class="headerlink" title="故事正文"></a>故事正文</h3><ol start="2"><li>他曾经以为迷宫里不会再有奶酪，或者自己永远找不到它们。正是这种担心和恐惧阻止他走进迷宫探险。</li></ol><h3 id="下午茶时的讨论"><a href="#下午茶时的讨论" class="headerlink" title="下午茶时的讨论"></a>下午茶时的讨论</h3><ol start="3"><li>我们都希望能够一直待在自己熟悉的领域。事实是，我不想应对变化，甚至根本就不想面对它。<i><font color='blue'>(喵语：安于稳定，固守己见，很多人在自己专研的领域内有所成就后，都希望它会一直被认可。但是随着时间的流逝，没有什么知识是一成不变的，曾经的渊博也会成为常识，只因始终不想踏出那一步。)</font></i></li></ol><h2 id="《致我们终将逝去的青春》"><a href="#《致我们终将逝去的青春》" class="headerlink" title="《致我们终将逝去的青春》"></a><b>《致我们终将逝去的青春》</b></h2><p>简介：此书作者是辛夷坞，讲述的是高中考上大学的郑微由校园爱情的凄美最后走向现实的婚姻，校园爱人却已迥成路人，有些人注定走不到永远。<br><img src="https://z3.ax1x.com/2021/05/04/gulPoD.jpg" alt="gulPoD.jpg" border="0" / loading="lazy"></a></p><h3 id="第一章-大学的新鲜时光"><a href="#第一章-大学的新鲜时光" class="headerlink" title="第一章 大学的新鲜时光"></a>第一章 大学的新鲜时光</h3><ol><li>几个男生争先恐后地问着话，把她的姓名、系别、专业、原籍通通打听了个遍，并不失时机地每个人都进行了详细的自我介绍。最绝的堪称老张，他塞给郑微一张早已准备好的自制名片，上面姓名、专业、联系电话、宿舍门牌一应俱全，居然连血型和兴趣爱好都有，堪称浓缩而精辟。</li><li>你等着吧，我说考得上就考得上，等到到G大报到的时候，我会去找你哦，到时你不准耍赖！”她看着他，一双大眼睛亮闪闪的。</li></ol><h3 id="第三章-再见，林静"><a href="#第三章-再见，林静" class="headerlink" title="第三章 再见，林静"></a>第三章 再见，林静</h3><ol start="3"><li>几个人闲着就在电脑前大看特看小影碟店出租的肥皂剧，韩剧、日剧、港剧、美剧、国产剧、台湾偶像剧，荤素不忌，有时看得忘我，就连吃饭都是下课回来的阮阮给打包回来。</li></ol><h3 id="第十三章-醉笑陪依三万场，不诉离殇"><a href="#第十三章-醉笑陪依三万场，不诉离殇" class="headerlink" title="第十三章 醉笑陪依三万场，不诉离殇"></a>第十三章 醉笑陪依三万场，不诉离殇</h3><ol start="4"><li>阮阮不是没有伤心过，然而她依然原谅了这个她第一个爱上的男孩，她没有办法放弃S市的工作，在赵世永从父母家搬出来之后，每逢闲暇，她都从S市赶过去看他。</li></ol><h3 id="第十五章-就当我是个陌生人"><a href="#第十五章-就当我是个陌生人" class="headerlink" title="第十五章 就当我是个陌生人"></a>第十五章 就当我是个陌生人</h3><ol start="5"><li>她就快要把G市的青年才俊一网打尽，这些人里有些喜欢她但是她不喜欢的，有她觉得不错但对方无动于衷的，更多的是相看两相忘。</li><li>爱情可以唯美唯心，相亲就是一场交易，大家把最现实的要求摆到台面上来，合适就好，不合适也罢，你何苦气不过，非要恶搞他一轮？</li><li>爱着的时候，以为那个人就是自己的一生，谁料到一朝梦醒，就站在了另一个人的身边。</li><li>我知道你会这么想。微微，其实我没有你勇敢——很多人都像我一样，远远没有你的勇气。我们害怕解决不了的纠葛，害怕付出后得不到回报，害怕不可预知的事情，更害怕自己得不到在乎的东西。</li></ol><h3 id="第十六章-郑秘书和陈助理"><a href="#第十六章-郑秘书和陈助理" class="headerlink" title="第十六章 郑秘书和陈助理"></a>第十六章 郑秘书和陈助理</h3><ol start="9"><li>如果说林静给了我最懵懂的爱情的梦想，那陈孝正才是真正给了我爱的启蒙的那个人，我是因为他才学着怎么去对一个人好，学着怎么千方百计地去爱，我学会了，他也走了。</li></ol><h3 id="番外篇"><a href="#番外篇" class="headerlink" title="番外篇"></a>番外篇</h3><ol start="10"><li>他还是那样冷冷淡淡听不出情绪波澜的语调，“你知道她是怎么发病的？春节回家的时候我和她大吵了一场，把家里能砸的东西都砸了。她让我要争气，我说我一直很争气，可争气会有幸福吗？我的幸福去哪了？她在我砸东西的时候一直流眼泪，我觉得很解气，好像这些年来是她逼得我成了这样，然后我心里就轻松了很多，虽然我明知道不是这样。郑微你……”</li></ol>]]></content>
      
      
      <categories>
          
          <category> 喵语摘抄 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STAD</title>
      <link href="/academic_research/anomaly_detection/STAD/"/>
      <url>/academic_research/anomaly_detection/STAD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><p><a href="https://arxiv.org/pdf/1911.02357.pdf">Uninformed Students: Student-Teacher Anomaly Detection with Discriminative Latent Embeddings</a></p><p>&emsp;&emsp;该文是发表在CVPR 2020的文章，文章主要通过ensemble的学生和pretrained的老师来进行无监督的异常检测。该文的<font color="red"><b>新意</b></font>不但在于用师生网络进行异常检测，还使用了判别式嵌入而非重建的方法，并且实现了精确到像素级的分割。</p><span id="more"></span><br><h2 id="Motivations"><a href="#Motivations" class="headerlink" title="Motivations"></a>Motivations</h2><p><b>1.目前无监督异常分割较为依赖于生成模型</b></p><p>&emsp;&emsp;目前无监督异常分割的主流方法依赖于生成方法居多，像GAN以及AE重建的思想。基于这种思想，异常检测是通过逐像素去重建或是根据数据概率分布的估计去重建，重建像素如果比较复杂有可能会导致错误的重建。</p><p><b>2.目前无监督领域判别式嵌入的方法有待挖掘</b></p><p>&emsp;&emsp;在迁移学习中，从预训练模型得到的判别式嵌入提高了有监督领域迁移的性能。作者发现在无监督领域使用判别式嵌入的方法泛化性能比深度生成模型要好。</p><p><b>3.判别式的有些方法有时会过度依赖于下采样</b></p><p>&emsp;&emsp;对于复杂的高维数据集，使用判别式嵌入的方法需要降维，因为判别式方法是属于浅层方法，它们建模特征空间的容量不足以支撑庞大数据的复杂分布。</p><br><h2 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h2><p><b>1.在无监督异常检测领域使用师生框架</b></p><p>&emsp;&emsp;文章在无监督异常检测领域结合见过正负样本的预训练的老师和只见过正样本的学生，利用判别式嵌入的思想来做异常检测。</p><p><b>2.融合了集成学习的思想</b></p><p>&emsp;&emsp;对于集成的学生，是利用老师与学生之间预测的差异以及学生与学生之间的差异来获得异常图。</p><p><b>3.分割方法新颖</b></p><p>&emsp;&emsp;分割方法新颖，分割异常采用的是输入不同大小的图像块进行多尺度的方法。</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><h3 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h3><img src="https://s3.ax1x.com/2021/01/16/sBjh5R.png" alt="sBjh5R.png" border="0" / loading="lazy"><p>&emsp;&emsp;本文提出的判别式嵌入的师生框架，可分为三个部分，第一部分是经过<b>预训练的教师网络</b>和<b>M个随机初始化产生的ensemble的学生网络</b>，其中教师网络有利用到<font color='red'><b>正常数据和异常数据</b></font>的图像块去pretrain，第二部分是两个网络对于同一输入的<b>判别式描述</b>，第三部分是<b>多尺度分割模块</b>组成。整个框架训练是采用的是<font color='red'><b>正常的数据集</b></font>的图像块。训练时是通过教师网络的输出的embedding(注意看上图中红色Teacher descriptors)去教导学生如何embed正常的样本（注意看上图中黄色Student predictions），学生网络是通过回归误差和预测的方差去学习的。最后通过3个异常图的加权平均分割出异常。</p><p>&emsp;&emsp;教师网络使用正常和异常的数据来预训练，学生网络只使用正常的数据来训练。采用上述训练方法有两个的好处。</p><p>（1）在测试时遇到异常样本时，由于教师没有教导学生什么是异常样本，但教师知道什么是异常样本，所以学生网络输出会和教师网络输出差异较大；</p><p>（2）在测试时遇到异常样本时，由于几个ensemble的学生都没见过异常样本，所以在学生之间输出会比较不一致。</p><br><h3 id="教师网络的训练"><a href="#教师网络的训练" class="headerlink" title="教师网络的训练"></a>教师网络的训练</h3> <img src="https://s3.ax1x.com/2021/01/16/sDputJ.png" alt="sDputJ.png" border="0" / loading="lazy"><p>&emsp;&emsp;教师网络的训练主要分为<b>度量学习</b>和<b>知识蒸馏</b>两部分。这里度量学习是学习到三个距离$\delta$，$\delta^+$，$\delta^-$来完成对正负样本的差异性的判断。给定三元组（$p,p^+,p^-$），判别式嵌入要做的事情是让$p$和$p^+$的距离最小，$p$和$p^+$距离$p^-$的距离尽量大。公式如下。<br>$$ \delta^+ = \vert\vert \hat T(p)-\hat T(p^+)\vert\vert^2 $$</p><p>$$ \delta^- = min\lbrace\vert\vert \hat T(p)-\hat T(p^-)\vert\vert^2 ,\vert\vert \hat T(p^+)-\hat T(p^-)\vert\vert^2\rbrace $$<br>度量学习的loss为<br>$$ L_m(\hat T)=max\lbrace0,\delta+\delta^+-\delta^-\rbrace $$<br>&emsp;&emsp;通过度量学习得到学习正负样本的差异性。对于右边的知识蒸馏模块，它是用一个已经可以分类正负样本的Resnet-18网络$P$对判别式的输出embedding用蒸馏的方法得到网络$\hat T$。知识蒸馏这块的loss为<br>$$ L_k(\hat T)=\vert\vert D(\hat T(p))-P(p)\vert\vert^2 $$<br>为了去除输入图像块之间的冗余信息，用$c_{ij}$来表示输入图像块$P$之间的协方差矩阵，得到去冗余度的loss如下。<br>$$ L_c(\hat T)=\sum_{i\neq j}c_{ij} $$<br><br></p><h3 id="学生网络的训练"><a href="#学生网络的训练" class="headerlink" title="学生网络的训练"></a>学生网络的训练</h3><p>&emsp;&emsp;在文中，对于文中每一张图像块，学生网络输出假设是服从高斯分布的，它的训练主要依赖于<b>学生与老师之间的<font color='red'>回归误差</font>以及学生与学生之间的<font color='red'>预测不确定度</font></b>，回归误差指的是M个学生$S_i$在第$r$行和第$c$列上的点预测的均值减去老师描述的二范数的平方。</p><p>&emsp;&emsp;预测的不确定度是指M个学生$S_i$在第$r$行和第$c$列上预测点的均值$\mu_{(r,c)}^{S_i}$的二范数的<b>平方求平均</b>减去预测点的均值$\mu_{(r,c)}^{S_i}$<b>求平均</b>的二范数的<b>平方</b>。总的loss是回归误差和预测不确定度的归一化操作。</p><img src="https://s3.ax1x.com/2021/01/17/sr7xnH.png" alt="sr7xnH.png" border="0" / loading="lazy"><p>&emsp;&emsp;举例子来说，在MNIST数据集上，用0作为正常样本，其他数字为异常样本，可以得到如下关于正常样本和异常样本的正态的数据分布图。教师网络是用0-9所有的数据去训练的，学生网络只用正常样本去回归和预测，很明显教师知道什么是正常和什么是异常，学生只知道正常的。所以学生预测出的结果如上所示，对于正常的样本，学生回归误差和预测的方差都偏小，对于异常样本，回归误差和预测方差都偏大。</p><img src="https://s3.ax1x.com/2021/01/16/sDpk60.png" alt="sDpk60.png" border="0" / loading="lazy"><h3 id="多尺度分割"><a href="#多尺度分割" class="headerlink" title="多尺度分割"></a>多尺度分割</h3><p>&emsp;&emsp;利用输入多个不同大小的图像块得到的学生网络回归误差和预测的不确定度的异常map进行加权平均，可得到如下结果。</p><img src="https://s3.ax1x.com/2021/01/17/srL9E9.png" alt="srL9E9.png" border="0" / loading="lazy"><p>可得<b>多尺度分割结论</b>：对于不同异常的分割，分割性能的大小与P的size有关，P太大，小块的异常会被当成正常，P太小，大块的异常被当作正常。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.多尺度的方法过于粗糙，文章中仅仅是使用三个异常map的加权平均，其实可以改为更多的map；</p><p>2.分割性能的大小与输入图像块的size有关，size太大，小块的异常会被当成正常，size太小，大块的异常被当作正常，不知道能不能让输入图像块的大小在某个范围内具有自适应性调整。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>1.MVTec Anormal Detection Dataset: <a href="https://www.mvtec.com/company/research/datasets/mvtec-ad">https://www.mvtec.com/company/research/datasets/mvtec-ad</a></p><p>2.MNIST: <a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a></p><p>3.CIFAR-10: <a href="https://www.cs.toronto.edu/~kriz/cifar.html">https://www.cs.toronto.edu/~kriz/cifar.html</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/265526970">https://zhuanlan.zhihu.com/p/265526970</a></p>]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anomaly_detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MNAD</title>
      <link href="/academic_research/anomaly_detection/MNAD/"/>
      <url>/academic_research/anomaly_detection/MNAD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><p><a href="https://openaccess.thecvf.com/content_CVPR_2020/papers/Park_Learning_Memory-Guided_Normality_for_Anomaly_Detection_CVPR_2020_paper.pdf">Learning Memory-guided Normality for Anomaly Detection</a></p><p>&emsp;&emsp;该文是发表在CVPR 2020的文章，MNAD指Memory-guided Normality for Anomaly Detection。文章相当于是MemAE的改进版，该文章主要在无监督异常检测领域<b>考虑了异常情况在某种场景下不一定是异常的问题和CNN的表示能力过强导致信息过多丢失的问题</b>。</p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><b>1.之前重建异常的方法没有考虑到多种场景的异常检测问题</b></p><p>&emsp;&emsp;异常并不总是在所有情况下都是异常，比如说在公园拿着刀检测为异常，在厨房拿着刀就不会。并且异常数据往往是小样本，场景具有较大的不确定性。所以说<font color='red'>异常是根据场景的不同来确定是否是异常的</font>。</p><p><b>2.之前的方法由于CNN特征提取过度导致重建模糊</b></p><p>&emsp;&emsp;之前的方法（AE，MemAE等）由于是直接利用encoder的embedding进行，没有考虑输入同类型的正常之间的变化，也没有解决对于CNN通道容量太大导致的重建模糊问题。</p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p><b>1.增加了attention机制的更新模块</b></p><p>&emsp;&emsp;与MemAE一样，本文使用了记忆项来存储多个多种典型的场景，与MemAE不同的是，本文对Memory中的项与项之间进行了seperate的操作，并且在重建时对输入embedding和记忆项输出embedding进行拼接。</p><p><b>2.实现异常在多样性场景的区分</b></p><p>&emsp;&emsp;文章中引入了feature compactness loss和feature separateness loss去实现异常在多样性场景中的区分。</p><p><b>3.解决了重建图像的模糊问题</b></p><p>&emsp;&emsp;在MemAE中没有考虑输入同类型的正常场景之间的变化问题和CNN通道容量太大导致的重建模糊问题。本文通过输入的embedding和Memory中所有的embedding进行compact（即输入相似的场景尽量归为同一个项）来解决。</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><img src="https://s3.ax1x.com/2020/12/27/r56nhQ.png" alt="r56nhQ.png" border="0" / loading="lazy"><p>&emsp;&emsp;本文提出MNAD模型，该模型由三个主要部分组成，<b>编码器</b>（用于编码输入和生成查询），<b>解码器</b>（用于重建）和<b>记忆模块</b>（包括场相似场景的记忆以及多样性场景之间的区分）。如上图所示，训练时，将正常样本图像经过编码器生成embedding存于Memory中，通过Memory Read和Memory Update生成的embedding和输入的embedding拼接传给decoder进行重建输出。</p><img src="https://s3.ax1x.com/2020/12/27/r56mtg.png" alt="r56mtg.png" border="0" / loading="lazy"><p>&emsp;&emsp;如上图所示，在Memory Read时，当再次输入正常样本时，将输入的某个embedding的向量 $q_t^k$与所有Memory的所有embedding ($p_1,…,p_M$)进行转置和Softmax操作更新权重更新记忆项$\hat p_t^k$，即通过权重更新可使得记忆项中的embedding尽量接近输入的embedding；（主要通过feature compactness loss反映）</p><p>feature compactness loss为<br>$$ L_{compact}=\sum_t^T\sum_k^K\vert\vert q_t^k-p_p\vert\vert_2 $$</p><p>该式子表明对于输入图像的embedding $q_t^k$，在记忆项中找到一个$p_p$，使得它们距离越近越好。该loss保证了记忆项中的embedding和输入embedding的一致性。</p><p>&emsp;&emsp;在Memory Update时，将输入的所有embedding（$q_t^1,…,q_t^K$）与某个Memory中的embedding $p_m$进行转置和Softmax操作更新权重更新记忆，即对于同一个输入embedding，权重可反映记忆项之间的差异性，差异性可决定场景的不同。（主要通过feature separateness loss反映）</p><p>feature separateness loss为<br>$$ L_{separate}=\sum_t^T\sum_k^K[\vert\vert q_t^k-p_p\vert\vert_2-\vert\vert q_t^k-p_n\vert\vert_2+\alpha]_+ $$</p><p>该式子表明对于输入图像的embedding $q_t^k$，在记忆项中找到距离最近的embedding $p_p$的同时找到距离第二近的$p_n$，从而让输入接近最$p_p$，拉大与$p_n$之间的距离。该loss保证了记忆项中embedding之间的差异应该得拉大，这样做可以增强不同场景的区分和判别能力。</p><p>总的训练的loss是<br>$$ L=L_{rec}+\lambda_cL_{compact}+\lambda_sL_{separate} $$<br>重构的loss为<br>$$ L_{rec}=\sum_t^T\vert\vert \hat I_t-I_t\vert\vert_2 $$<br>其中$T$为视频序列长度，loss为输入与输出的$L_2$距离。</p><p>当输入异常时，文中通过函数$P$计算输入帧和重建帧的PSNR值和通过函数$D$输入embedding和Memory的embedding的差距作为异常分数$S_t$来检测异常。用离差标准化$g$的表示形式如下。<br>$$ S_t=\lambda(1-g(P(\hat I_t,I_t)))+(1-\lambda)g(D(q_t,p)) $$</p><h2 id="缺点和问题"><a href="#缺点和问题" class="headerlink" title="缺点和问题"></a>缺点和问题</h2><p>1.在<b>异常分割和定位</b>方面，该文章能涉及异常区域的定位，却没有对定位区域实现分割；</p><p>2.在<b>模型泛化性能</b>方面，文中对模型的训练使用的都是视频帧，说明网络时也是用前4帧来预测第5帧，当MNAD遇到前后关联性不大的数据集时性能仍是未知。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>1.UCSD-Ped2: <a href="http://www.svcl.ucsd.edu/projects/anomaly/dataset.htm">http://www.svcl.ucsd.edu/projects/anomaly/dataset.htm</a></p><p>2.CUHK Avenue: <a href="http://www.cse.cuhk.edu.hk/leojia/projects/detectabnormal/dataset.html">http://www.cse.cuhk.edu.hk/leojia/projects/detectabnormal/dataset.html</a></p><p>3.ShanghaiTech: <a href="https://svip-lab.github.io/dataset/campus_dataset.html">https://svip-lab.github.io/dataset/campus_dataset.html</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/264887767">https://zhuanlan.zhihu.com/p/264887767</a></p>]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> anomaly_detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MemAE</title>
      <link href="/academic_research/anomaly_detection/MemAE/"/>
      <url>/academic_research/anomaly_detection/MemAE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="论文题目"><a href="#论文题目" class="headerlink" title="论文题目"></a>论文题目</h2><p><a href="https://openaccess.thecvf.com/content_ICCV_2019/papers/Gong_Memorizing_Normality_to_Detect_Anomaly_Memory-Augmented_Deep_Autoencoder_for_Unsupervised_ICCV_2019_paper.pdf">Memorizing normality to detect anomaly: Memory-augmented deep autoencoder for unsupervised anomaly detection</a></p><p>&emsp;&emsp;该文是发表在ICCV 2019的文章，文章标题是通过无监督的方法对自编码器进行记忆增强，让自编码器记住更多正常模式，从而检测输入是否异常。文章解决了什么无监督异常检测的问题呢？</p><span id="more"></span><h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p><b>1.传统的深度自编码器泛化能力过强</b></p><p>&emsp;&emsp;我们知道，深度自编码器（Deep Auto-Encoder）是由一个从输入获得<font color='red'>压缩编码</font>的编码器和一个可以从编码中<font color='red'>重建数据</font>的解码器组成。<b>编码压缩的本质上是一个迫使网络提取高维数据</b>的信息瓶颈。在无监督异常检测时，通常通过最小化正常数据上的重建误差来训练AE，然后将重建误差用作异常指示。由于正常输入的重建误差接近训练数据，因此重建误差将较低，而异常输入重建后误差则变得较高。</p><p>&emsp;&emsp;然而，如果某些异常输入与正常训练数据共享共同的成分模式（例如，图像中的局部边缘相似），或者解码器“太强”而无法很好地解码某些异常编码，则AE非常有可能很好地重建异常。换言之，传统的AE（Auto-Encoder）的泛化能力较强，从而导致了输入异常模式时，重构输出后也可能得到长得像正常的异常模式，在检测时会被误分类。</p><p><b>2.缺乏可靠机制拉大对异常的重建</b></p><p>&emsp;&emsp;重建的思想是在正常的数据上学习模型，异常不能得到很好的编码与重建。但现有的许多方法（深度自编码器，稀疏表示等）缺乏可靠的机制来鼓励模型不很好地重建异常，即模型不能使得异常有着较大的重建误差。</p><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><p><b>1.对自编码器引入attention机制</b></p><p>&emsp;&emsp;为了抑制自编码器的泛化能力过强使得异常得到很好的重建这件事，文中的解决方法有两个，一个是在整个框架中加入Memory模块使得编码器记住更多正常的特征，一个是在Memory模块中引入硬收缩的稀疏寻址来防止记忆项的相关性太强导致异常得到很好的重建。</p><p><b>2.开山之作</b></p><p>&emsp;&emsp;经查阅资料，该文是第一篇将attention机制引入无监督异常检测的文章，后续仍具有研究价值。</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><img src="https://s3.ax1x.com/2020/12/27/r5ycSs.png" alt="r5ycSs.png" border="0" / loading="lazy"><p>&emsp;&emsp;本文提出MemAE模型，该模型由三个主要部分组成，<b>编码器</b>（用于编码输入和生成查询），<b>解码器</b>（用于重构）和<b>记忆模块</b>（带有内存和相关的内存寻址运算符）。如上图所示，训练时，将正常样本图像经过编码器生成embedding存于Meomory中，当再次输入正常样本时，将输入的embedding与Memory中的embedding进行相似度计算（文中采用余弦相似度），再用相似度的Softmax作为权重，用加权求和去更新Memory中的embedding，<b>加入attention机制的目的是让存储器更新时以记录更多正常数据的正常特征</b>，该embedding经解码器后输出重建图像与输出图像进行MSE loss。</p><p>&emsp;&emsp;在记忆模块中，文章发现Memory中如果embedding过多可能会使得模型的泛化能力提高，这会使得异常会得到很好地重建，因此，文章提出硬收缩的稀疏寻址（Hard Shrinkage for Sparse Addressing）来解决这个问题，该方法保证了寻址权重具有一定的稀疏性。如下公式所示。</p><p>$$ \hat\omega_i=\frac{max(w_i-\lambda,0)\cdot\omega_i}{\vert\omega_i-\lambda\vert+\epsilon} $$</p><p>给定收缩阈值$\lambda$，当权值大于收缩阈值时，再对权重进行更新。</p><p>整个编码器$e$和解码器$d$的loss由重建loss $R$和权重的交叉熵$E$组成。<br>$$ L(\theta_e,\theta_d,M)=\frac{1}{T}\sum_{t=1}^T(R(x^t,\hat x^t)+\alpha E(\hat\omega^t)) $$</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1.在<b>异常检测</b>方面，据参考资料的总结，文中重建图像比较模糊。可能是因为编码时由于下采样导致部分信息丢失。</p><p>2.在<b>异常分割和定位</b>方面，该文章并没有涉及，文中只能区分正常与异常而已。</p><p>3.文中对应<b>多场景的异常检测</b>（都是拿着一把刀，在教室里拿着检测为异常，厨房里拿着检测为正常）也没有涉及。</p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>1.MNIST: <a href="http://yann.lecun.com/exdb/mnist/">http://yann.lecun.com/exdb/mnist/</a></p><p>2.UCSD-Ped2: <a href="http://www.svcl.ucsd.edu/projects/anomaly/dataset.htm">http://www.svcl.ucsd.edu/projects/anomaly/dataset.htm</a></p><p>3.CUHK Avenue: <a href="http://www.cse.cuhk.edu.hk/leojia/projects/detectabnormal/dataset.html">http://www.cse.cuhk.edu.hk/leojia/projects/detectabnormal/dataset.html</a></p><p>4.ShanghaiTech: <a href="https://svip-lab.github.io/dataset/campus_dataset.html">https://svip-lab.github.io/dataset/campus_dataset.html</a></p><p>5.KD-DCUP99</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://zhuanlan.zhihu.com/p/264887767">https://zhuanlan.zhihu.com/p/264887767</a></p><p>2.<a href="https://zhuanlan.zhihu.com/p/260651151">https://zhuanlan.zhihu.com/p/260651151</a></p>]]></content>
      
      
      <categories>
          
          <category> 喵喵科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> academic_research </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Logistic Regression</title>
      <link href="/academic_research/machine_learning/logistic_regression/"/>
      <url>/academic_research/machine_learning/logistic_regression/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>&emsp;&emsp;这应该是李宏毅机器学习入门基础概念的最后一篇了，后面就因为<del>偷懒◑﹏◐</del>开学去读论文，学习经典的深度学习模型就没写了。其实逻辑回归是构成深度学习神经元的激活函数，虽然说为了防止梯度爆炸和梯度消失，现在普遍使用的是Relu，但其重要性还是无与伦比。</p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><b>概述</b></h2><p>&emsp;&emsp;虽然逻辑回归（Logistic Regression）被称为回归，但它一般用于解决分类问题。为什么叫逻辑回归呢？因为在整个方法中对输入$x$我们采用线性模型$z=\omega^Tx+b$，线性模型可以进行回归学习，如果处理的是二分类问题，我们规定输出$z={0,1}$，所以叫逻辑回归。</p><h2 id="逻辑回归实现过程"><a href="#逻辑回归实现过程" class="headerlink" title="逻辑回归实现过程"></a><b>逻辑回归实现过程</b></h2><p>&emsp;&emsp;由概述我们已知知道逻辑回归是采用线性模型，假设我们现在要解决二分类问题。那怎么将模型$z=\omega^Tx+b$映射到输出$z={0,1}$呢？这时候就要利用我们在Classification最后由贝叶斯公式推导出来的$P_{\omega,b}(C_1|x)=$Sigmoid函数$\sigma(z)=\frac1{1+e^{-z} }$，具体做法如下。</p><h3 id="建模（找未定参函数）"><a href="#建模（找未定参函数）" class="headerlink" title="建模（找未定参函数）"></a><b>建模（找未定参函数）</b></h3><p>&emsp;&emsp;建模的过程就是找出一系列参数未定的函数列。对于二分类问题，我们的想法是通过与$\sigma(z)$函数相等的后验概率$P_{\omega,b}(C_1|x)$来进行判别，如果后验概率$P_{\omega,b}(C_1|x)$大于0.5，则属于类别$C_1$，小于0.5则属于类别$C_2$。所以整个模型表达式为<br>$$ f_{\omega,b}(x)=P_{\omega,b}(C_1|x)=\sigma(z) $$<br>由在Classification中的描述可知，$z=\omega\cdot x+b$（$\omega, x$都是列向量），所以对于上式，$\omega,b$是未定的参数。$f_{\omega,b}(x)$是由这两个未定参数组成的函数列。</p><p>&emsp;&emsp;如果我们把整个模型画出可视化图的形式，结果如下所示。</p><img src="https://s1.ax1x.com/2020/08/16/dE0Lp6.jpg" alt="dE0Lp6.jpg" border="0" / loading="lazy"><h3 id="找评价函数"><a href="#找评价函数" class="headerlink" title="找评价函数"></a><b>找评价函数</b></h3><p>&emsp;&emsp;确定模型后，我们需要定义一个判断模型好坏的评价标准，目前为止的评价函数有损失函数和似然函数。目前只有定义了<b>损失函数(Loss Function)或者似然函数(Likelihood Function)</b>，我们才能用各种求最优解的方法去求出使得损失最小或者似然函数最大的参数。</p><p>&emsp;&emsp;在逻辑回归中，不妨我们先用似然函数去作为评价标准。假设现在我们现在处理二分类问题，训练集是已知分类的$N$个样本点，利用上述模型和独立事件的最大似然估计的方法，我们可以得到似然函数$L(\omega,b)$的表达式如下。</p><img src="https://s1.ax1x.com/2020/08/16/dE0Ht1.jpg" alt="dE0Ht1.jpg" border="0" / loading="lazy"><p>其中设$\omega^*,b^*$是使得似然函数值最大的参数，解函数为$\omega^*,b^*= \underset{\omega,b}{\operatorname{arg,max}L(\omega,b)}$，直接求最大解不好求，我们可以改成求最小值的形式为$\omega^*,b^*= \underset{\omega,b}{\operatorname{arg,min}}-lnL(\omega,b)$，类别$C_1$我们用1标注，类别$C_2$我们用0标注。则似然函数$L(\omega,b)$的每一项都可以化成下面的结果。</p><img src="https://s1.ax1x.com/2020/08/16/dE05m4.jpg" alt="dE05m4.jpg" border="0" / loading="lazy"><p>（注：图中右上角的标注错误，应该是$\hat y_1=1,\hat y_2=1,\hat y_3=0$）</p><h4 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a><b>交叉熵</b></h4><p>&emsp;&emsp;那为什么我们要转化成对数加负号求最小值的形式计算解函数？因为取对数加负号后，可以转化为《信息论》中常见的量——<b>熵（entropy）</b>。为什么要转化为熵呢？因为熵是用来系统的混乱程度，熵值越大，代表系统越混乱，系统里所含的样本种类数越多；熵值越小，系统越纯，系统里面的样本种类数越单一。</p><p>&emsp;&emsp;熵的数学定义为$H(x)=−∑_{i=1}^np(x_i)log(p(x_i))$；其中，$p(x_i)$为事件$X=x_i$的概率，$−log(p(x_i))$为事件$X=x_i$信息量。</p><h5 id="交叉熵的定义"><a href="#交叉熵的定义" class="headerlink" title="交叉熵的定义"></a><b>交叉熵的定义</b></h5><p>&emsp;&emsp;根据熵的定义我们知道熵可以通过自身的概率分布，衡量自身的混乱程度。那对于两个不同的分布$p,q$，使用熵的定义去衡量它们之间的混乱程度，也就是它们之间的差异，可得到交叉熵的定义为<br>$$ H(p,q)=-\sum_x p(x)ln(q(x)) $$<br>其中交叉熵值越大，代表两个分布差异很大，交叉熵值越小，代表两个分布越相似。</p><img src="https://s1.ax1x.com/2020/08/18/dnvj0I.jpg" alt="dnvj0I.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;对应到机器学习中，可以用<font color='red'><b>交叉熵作为损失函数</b></font>，假设分布$p$表示真实的分布，分布$q$表示训练后的模型预测标记分布，此时交叉熵可以衡量二者的差异性，交叉熵值越小，去负号去指数得到的似然函数的值越大，可求得最优解。</p><p>&emsp;&emsp;上图中划蓝线的式子代表的是两个伯努利分布（二项分布）的交叉熵。</p><h3 id="找评价最好的函数"><a href="#找评价最好的函数" class="headerlink" title="找评价最好的函数"></a><b>找评价最好的函数</b></h3><p>&emsp;&emsp;我们已经知道可以用两个不同分布的交叉熵去作为损失函数去衡量函数好坏。所以我们的任务是求出使得交叉熵的值最小的$\omega,b$，以下使用梯度下降的方法求解。（梯度下降具体的做法参照Regression）</p><p>&emsp;&emsp;下图是$lnf_{\omega,b}(x^n)$对$\omega_i$求偏导的过程。</p><img src="https://s1.ax1x.com/2020/08/16/dE0jXD.jpg" alt="dE0jXD.jpg" border="0" / loading="lazy"><p>以下是$ln(1-f_{\omega,b}(x^n))$对$\omega_i$求偏导的过程。</p><img src="https://s1.ax1x.com/2020/08/16/dE0z0H.jpg" alt="dE0z0H.jpg" border="0" / loading="lazy"><p>将两项求偏导的结果加起来化简如下。</p><img src="https://s1.ax1x.com/2020/08/16/dEBS7d.jpg" alt="dEBS7d.jpg" border="0" / loading="lazy"><p>可以得到$\omega_i$更新为$\omega_i-\eta\sum_n-(\hat y^n-f_{\omega,b}(x^n)x_i^n)$。其中$\eta$为学习率。</p><h2 id="逻辑回归和线性回归作比较"><a href="#逻辑回归和线性回归作比较" class="headerlink" title="逻辑回归和线性回归作比较"></a><b>逻辑回归和线性回归作比较</b></h2><p>&emsp;&emsp;两者的对比图如下所示。</p><img src="https://s1.ax1x.com/2020/08/16/dEB9AA.jpg" alt="dEB9AA.jpg" border="0" / loading="lazy"><p>可以看出，两种回归的$\omega_i$的更新是一样的，不同的是，线性回归的目标函数可以是任意值，输出也可以是任意值，逻辑回归的目标函数是0或1，输出是介于0到1的值。并且线性回归的损失函数采用的是平方误差，而逻辑回归采用的是交叉熵。那为什么逻辑回归不采用平方误差作为损失函数呢？</p><p>&emsp;&emsp;其实损失函数只是个人为定义评价模型好坏的标准而已。不同的标准各有优劣，但是并不冲突，所以逻辑回归当然可以利用平方误差得到损失函数。但是可能存在以下问题。如果从分类问题的角度去解释，由下图可知，如果我们分类的目标值$\hat y^n=1$，当我们的预测值在距离目标很近（$f_{\omega,b}(x^n)=1$）或是很远（$f_{\omega,b}(x^n)=0）$时，似然函数$L$关于$\omega_i$的偏导都是0，换言之，<b>当预测值在距离目标值很远的地方时，可能陷入局部最优解而不进行参数的更新或者更新很慢。</b></p><img src="https://s1.ax1x.com/2020/08/16/dEBPht.jpg" alt="dEBPht.jpg" border="0" / loading="lazy"><p>如果我们分类的目标值$\hat y^n=0$，同样会存在上述问题，具体过程如下。</p><img src="https://s1.ax1x.com/2020/08/16/dEBF9P.jpg" alt="dEBF9P.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;如果从数学的角度解释，是因为通过最小二乘法得到的平方损失函数是非凸的，而对数似然函数是凸函数。二者的图像如下所示。</p><img src="https://s1.ax1x.com/2020/08/16/dEBm7j.jpg" alt="dEBm7j.jpg" border="0" / loading="lazy"><p>可见如果是交叉熵，在预测值距离目标越远，微分值就缩小，就可以做到距离目标越远，更新参数越快。而平方误差在距离目标很远的时候，微分值也可能非常小，这会造成移动的速度非常慢，效果较差。</p><p>&emsp;&emsp;还记得为什么在线性回归中我们不用担心陷入局部最优解的问题而选择平方误差作为损失函数吗？<font color='red'>因为线性回归中，我们的损失函数$L$根本没有局部最优解。（因为无论是单变量还是多变量的线性回归，损失函数$L$都是凸函数。）</font></p><h2 id="判别模型和生成模型作比较"><a href="#判别模型和生成模型作比较" class="headerlink" title="判别模型和生成模型作比较"></a><b>判别模型和生成模型作比较</b></h2><p>&emsp;&emsp;逻辑回归的方法就属于判别模型，就是通过$\sigma(z)$函数建模，通过构造对数似然函数作为评价函数，再利用梯度下降的方法直接求解最好的$\omega,b$。如果是生成模型，要已知或者先假设训练数据服从某一分布（像上节在Classification中的概率生成模型中假设原数据服从高斯分布），再通过最大似然估计求出最好的参数（高斯分布的参数是$\mu^1,\mu^2,\Sigma$，再通过训练分类样本数$N_1,N_2$等参数求解得到最好的$w,b$。）所以对于判别模型和生成模型，它们得到的最好的$\omega,b$显然是不一样的。</p><img src="https://s1.ax1x.com/2020/08/16/dEBk1f.jpg" alt="dEBk1f.jpg" border="0" / loading="lazy"><p>如果我们使用逻辑回归对宝可梦的水系和一般系的作分类，只用两个特征的话，和之前生成模型的方法对比，效果如下。</p><img src="https://s1.ax1x.com/2020/08/16/dEBAc8.jpg" alt="dEBAc8.jpg" border="0" / loading="lazy"><p>只考虑两个特征效果确实也不怎么好，如果我们考虑了所有的7个特征，准确率由73%提高到了79%。所以判别模型的效果比生成模型的要好。那判别模型的方法一定会比生成模型要好呢？</p><p>&emsp;&emsp;以下举个例子来说明，下图中有13组数据，除了（1,1)是类别1外，其他都是类别2。</p><img src="https://s1.ax1x.com/2020/08/16/dEBEjS.jpg" alt="dEBEjS.jpg" border="0" / loading="lazy"><p>然后如果我们新来个测试数据（1,1），毫无意外我们都认为是类别1，但是如果我们选用生成模型——<b>朴素贝叶斯分类器（Naive Bayes Classifier）</b>（假设问题的输入有$K$个特征，并且它们之间都是统计独立，最终先验概率的求解为各个特征的概率相乘。）进行判别，结果会怎样呢？</p><p>&emsp;&emsp;为使用贝叶斯公式，我们先求出贝叶斯公式的四个先验概率，再带入贝叶斯公式，求得的结果$P(C_1|x)$是小于0.5，所以分类器将它判断为类别2，这和我们的判断恰好相反。为什么使用生成模型会造成这种结果呢？</p><p>&emsp;&emsp;因为生成模型在进行判断前对我们的数据做了假设，假设它来自于某个概率模型（本例就是朴素贝叶斯分类器），在数据量不大的情况下进行“脑补”，当“脑补”这个模型的基础上产生足够多的数据的话，（1,1）属于类别2的概率更大，之所以我们看到（1,1）属于类别1，是因为训练的数据不够多。</p><img src="https://s1.ax1x.com/2020/08/16/dEBuAs.jpg" alt="dEBuAs.jpg" border="0" / loading="lazy"><p>那生成模型中的“脑补”算是一件好事吗？在数据量不多的情况下，“脑补”确实是必要的。那生成模型的优点有哪些呢？</p><p>&emsp;&emsp;<b>对于训练数据很少或者训练集中含有噪声点时，使用生成模型往往更好，因为判别模型没有自己的假设，受数据影响较大。当数据量越来越多时，使用判别模型的$Error$会越来越小。使用生成模型还可以将先验和类相关的概率从不同的来源估计。</b>比如说语音识别，我们可能直观会认为现在的语音识别大都使用神经网络来进行处理，是属于判别模型；但实际上整个语音识别是生成模型。所以还是需要算一个先验概率——某句话被说出来的概率，但我们估计某句话被说出来的概率不需要声音数据，只需要网络上爬很多的句子，就能计算某句话出现的几率。</p><h2 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a><b>Softmax回归</b></h2><p>&emsp;&emsp;普通的逻辑回归只能解决二分类问题，对于多分类问题，我们对逻辑回归进行改进提出了Softmax回归。关于Softmax回归的原理，可参考《Pattern Recognition and Machine Learning》Christopher M. Bishop 著 ，P209-210。以下我们只介绍Softmax回归的用法。</p><p>&emsp;&emsp;假设我们现在有三个类别$C_1,C_2,C_3$（记为$    C_i(i=1,2,3)$），它们被预测时都有回归中最好的权值$w_i$和偏置$b_i$，假设现在有测试样本$x$测试集输入模型后对应的输出是$z_i(i=1,2,3)$，而Softmax要做的是利用以下公式计算样本$x$的后验概率$y_i=P(C_i|x)(i=1,2,3)$。后验概率的计算使用公式<br>$$ y_i= \frac{e^{z_1}} {\sum_{j=1}^3 e^{z_j}} $$<br>具体的计算过程如下。Softmax回归的过程简单描述为将样本$x$输入到各个判别器得到<font color='red'>输出$z$作<b>指数化（exponential）</b></font>，但由于指数化的结果可以是任意值，所以还要各个判别器<font color='red'>指数化结果的<b>归一化（Normalization）</b></font>。</p><img src="https://s1.ax1x.com/2020/08/16/dEB3cT.jpg" alt="dEB3cT.jpg" border="0" / loading="lazy"><p>假设我们输入样本$x$经过线性回归模型后三个输出为$z_1=3,z_2=1.z_3=-3$，再经过Softmax回归处理，得到的结果是$y_1=0.88,y_2=0.12,y_3=0$，换句话说，<font color='red'>Softmax回归的输出可以当作后验概率</font>。</p><p>&emsp;&emsp;那为什么我们可以把Softmax回归的输出可以当作后验概率呢？</p><p>&emsp;&emsp;<font color='green'>首先，我们可以像在Classification中一样，假设多个类别都服从高斯分布，然后让它们共享协方差矩阵$\Sigma$，再用最大似然估计的方法求得$\mu_1,\mu_2,\mu_3$，最后也能求得$y_1,y_2,y_3$。其次，在《信息论》中有个叫“最大熵”的概念，一样能推导出Softmax。（参考：指数簇分布的最大熵等价于其指数形式的最大似然界。二项式的最大熵解等价于二项式指数形式(sigmoid)的最大似然，多项式分布的最大熵等价于多项式分布指数形式(softmax)的最大似然，因此为什么用sigmoid函数，那是因为指数簇分布最大熵的特性的必然性。）</font></p><p>&emsp;&emsp;如下图所示，最后为避免使用数值1，2，3进行分类我们采用矩阵表示，再用多个变量的交叉熵作为损失函数去衡量目标值和预测值的差距。</p><img src="https://s1.ax1x.com/2020/08/16/dEBl90.jpg" alt="dEBl90.jpg" border="0" / loading="lazy"><h2 id="逻辑回归的局限"><a href="#逻辑回归的局限" class="headerlink" title="逻辑回归的局限"></a><b>逻辑回归的局限</b></h2><p>&emsp;&emsp;其实逻辑回归处理分类问题有个非常强的局限，就是它根本没有办法将异或问题分类，如下图所示。</p><img src="https://s1.ax1x.com/2020/08/16/dEBtHJ.jpg" alt="dEBtHJ.jpg" border="0" / loading="lazy"><p>无论我们怎样去调整模型的权重$w_i$还是偏置$b$，模型仍是一条不能将二者区分开来的直线，如下图所示。</p><img src="https://s1.ax1x.com/2020/08/16/dEBaNR.jpg" alt="dEBaNR.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;那我们应该怎么解决这个问题呢？</p><h3 id="特征转换"><a href="#特征转换" class="headerlink" title="特征转换"></a><b>特征转换</b></h3><p>&emsp;&emsp;异或问题难以分类的原因是分类的特征实在过于特殊，如果我们对原始特征进行<b><font color='red'>特征转换（Feature Transformation）</font></b>就能解决这个问题。特征转换的方法有很多种，对于上述01异或问题，可以将两个特征组成的平面$[x_1,x_2]^T$转化为新特征的平面$[x_1^\prime,x_2^\prime]^T$，其中$x_1^\prime$代表某点距离蓝点$[0,0]^T$的距离，$x_1^\prime$代表某点距离蓝点$[1,1]^T$的距离。所以对于$[x_1^\prime,x_2^\prime]^T$，$[1,1]^T$表示在原特征$x_1,x_2$的坐标平面中距离两个蓝点的距离都是1的点，也就是两个红点；对于原来的蓝点$[0,0]$，如果$x_1^\prime=0$，则$x_2^\prime=\sqrt{2}$，对于原来的蓝点$[1,1]$，如果$x_2^\prime=0$，则$x_1^\prime=\sqrt{2}$。</p><p>&emsp;&emsp;所以可以得到新平面下的两种类别点的分布，此时可以用逻辑回归将二者区分开来。</p><img src="https://s1.ax1x.com/2020/08/23/d0ugje.jpg" alt="d0ugje.jpg" border="0" / loading="lazy"><p>以上特征转换的方法只是针对上述的问题而已，但实际上我们不一定总能像刚刚那样找出一个好的特征转换。那怎么对不好的特征值进行特征转换呢？</p><h3 id="级联逻辑回归模型"><a href="#级联逻辑回归模型" class="headerlink" title="级联逻辑回归模型"></a><b>级联逻辑回归模型</b></h3><p>&emsp;&emsp;实际上我们可以通过级联多个逻辑回归模型进行特征转换，再通过最后一个逻辑回归模型进行分类。如下图所示。</p><img src="https://s1.ax1x.com/2020/08/23/d0nFRU.jpg" alt="d0nFRU.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;下面将以异或问题为例说明具体如何操作。<b>假设我们有四个待分类异或样本，每个样本有两个特征$x_1,x_2$，我们要做的事是通过逻辑回归进行特征转换，将不利于分类的特征转换为利于分类的特征，再将利于分类的特征通过一个独立的逻辑回归进行分类。</b></p><p>&emsp;&emsp;在特征转换步骤中有$z_1=\omega_1x_1+\omega_2x_2+b_1$和$z_2=\omega_3x_1+\omega_4x_2+b_2$，得到$z_1,z_2$再输入$\sigma(z)$函数得到归一化后的新的特征$x^\prime_1$和$x^\prime_2$，我们得到的新的特征是可以通过逻辑回归进行分类的。</p><p>&emsp;&emsp;所以在分类步骤中先进行$z_3=\omega_5x_1^\prime+\omega_6x_2^\prime+b_3$，通过调整参数得到输出再输入$\sigma(z)$函数得到归一化后的输出$y$也就是后验概率，再根据后验概率是否大于0.5进行分类。如下图，通过调节权重和偏置的参数可以使得四个待分类样本的$x_1^\prime,x_2^\prime$值如下所示。</p><img src="https://s1.ax1x.com/2020/08/25/d6wpsU.jpg" alt="d6wpsU.jpg" border="0" / loading="lazy"><p>由上可见，一个逻辑回归的输入可以来自其他逻辑回归的输出，同时该逻辑回归的输出也可以作为其他逻辑回归的输入，组成的网络如下图所示。</p><img src="https://s1.ax1x.com/2020/08/23/d0nkzF.jpg" alt="d0nkzF.jpg" border="0" / loading="lazy"><p>由多个逻辑回归组成的网络称为<b><font color='red'>“类神经网络”（Neural Network）</font></b>，其中每个逻辑回归叫做<b><font color='red'>神经元（Neural）</font></b>。这就引出了以后要讲的深度学习（Deep Learning）。</p>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Classification</title>
      <link href="/academic_research/machine_learning/classification/"/>
      <url>/academic_research/machine_learning/classification/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><b>概述</b></h2><p>&emsp;&emsp;在机器学习中，分类问题是指<b>给定一个输入，当输入经过某个模型后，输出判断该输入的所属类别</b>。常见的应用有信贷评估（根据某人的收入、存款、职业、年龄等判断是否给他贷款），医学诊断（根据某人的性别、年龄和目前症状判断他患上哪一类型的疾病），手写体的识别和人脸识别。</p><span id="more"></span><h2 id="案例：划分宝可梦的种类"><a href="#案例：划分宝可梦的种类" class="headerlink" title="案例：划分宝可梦的种类"></a><b>案例：划分宝可梦的种类</b></h2><p>&emsp;&emsp;在本例中，我们已知宝可梦具有18种类型（如下图，水系，雷系，草系等等），我们的任务是找到一个模型，使得输入一个宝可梦，输出是它的所属类型。</p><img src="https://s1.ax1x.com/2020/08/13/azUv80.jpg" alt="azUv80.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;划分宝可梦分类这件事有什么意义呢？由下图可知，不同类别的宝可梦存在着相互制约的关系，当在决斗时，对手派出一个从未见过的宝可梦时，一旦我们能成功把它分对类，就可以按照下图派出能克制住它的宝可梦。从而百战不殆。</p><img src="https://s1.ax1x.com/2020/08/13/azapKU.jpg" alt="azapKU.jpg" border="0" / loading="lazy"><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a><b>输入</b></h3><p>&emsp;&emsp;明确我们的任务后，首先开始采集数据，即宝可梦的特征。如下图所示。</p><img src="https://s1.ax1x.com/2020/08/13/azUzvT.jpg" alt="azUzvT.jpg" border="0" / loading="lazy"><p>比如一只皮卡丘有7个特征(HP、Attack、Defense、SP atk、SP def等等)，这七个特征可用一个向量来描述。我们下一步要做的事是将数据输入到一个函数里，输出是某个种类的宝可梦。</p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a><b>建模</b></h3><p>&emsp;&emsp;为简单起见，本例先描述二分类问题。</p><h4 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a><b>回归模型</b></h4><p>&emsp;&emsp;能不能采用Regression的方法进行二分类呢？如下图所示，我们假设类别1 的宝可梦的目标值是1，类别2的宝可梦目标值是-1，两种类型输出越靠近目标值越好。</p><p>&emsp;&emsp;如果恰好数据分布如下图左所示，我们确实能将二者分类并且效果不错，分界线就是绿线$y=b+\omega_1x_1+\omega_2x_2$，但如果蓝色数据的分布是下图右所示，比起左图，它存在了一些目标值远大于1的样本，这个时候我们是没有办法通过Regression训练得到绿色的线，只能得到紫色的线。为什么会这样呢？因为Regression的最终目标是使得$Loss$函数最小，为了达到这个目标，它会更偏向于靠近离群点方向。它认为紫色的线才是最好的函数。</p><p>&emsp;&emsp;可见Regression和Classification的目标是不一致的，所以采用回归的方法去解决分类问题是不适用的。并且在面对多分类问题时，如果我们把类别1的目标值设定为1，类别2的目标值设定为2，目标3 的目标值设定为3，这样的话由于1、2、3数值的设定而默认了类别1和类别2有关系（因为在数值上，1和2的距离比1和3更近），但实际上种类之间是没有关系的。所以采用Regression的方法不可靠。</p><img src="https://s1.ax1x.com/2020/08/13/aza9rF.jpg" alt="aza9rF.jpg" border="0" / loading="lazy"><h4 id="概率模型"><a href="#概率模型" class="headerlink" title="概率模型"></a>概率模型</h4><p>&emsp;&emsp;既然不能采用Regression的通用方法，比较理想的做法如下。</p><img src="https://s1.ax1x.com/2020/08/13/azaFa9.jpg" alt="azaFa9.jpg" border="0" / loading="lazy"><p>其中建模时对于二分类问题，一种可能的想法是在$f(x)$中内嵌一个函数$g(x)$，根据$g(x)$的正负判断输出的类型。损失函数$L(f)$的定义为在训练集中预测分类错误的次数之和，怎么找出最小的$Loss$函数呢？由于$L(f)$不可微分，所以不能采用梯度下降的方法，可使用感知机（Perceptron）或SVM（支持向量机）。但今天主要从概率学的角度介绍另一种方法。</p><h5 id="分类原理"><a href="#分类原理" class="headerlink" title="分类原理"></a><b>分类原理</b></h5><p>&emsp;&emsp;假设有两个盒子，各装了5个球，还得知随机抽一个球，抽到的是盒子1的球的概率是 $\frac{2}{3}$，是盒子2的球的概率是$\frac{1}{3}$。从盒子中蓝色球和绿色球的分配可以得到：</p><ul><li>在盒子1中随机抽一个球，是蓝色的概率为 $\frac{4}{5}$，绿色的概率为 $\frac{1}{5}$</li><li>在盒子2中随机抽一个球，是蓝色的概率为$\frac{2}{5}$，绿色的概率为 $\frac{3}{5}$</li></ul><p>现在问抽到一个蓝球，它属于盒子1的概率？</p><img src="https://s1.ax1x.com/2020/08/13/azaiVJ.jpg" alt="azaiVJ.jpg" border="0" / loading="lazy"><p>如上图所示，我们已知盒子1条件下是蓝球的概率，盒子2条件下是蓝球的概率，盒子1和盒子2各自的选取概率。根据<b><font color='red'>贝叶斯公式可以求得后验概率（Posterior Probability）</font></b>$P(B_1|Blue)$，即抽到是蓝球条件下属于盒子1的概率。</p><h5 id="概率与分类的关系"><a href="#概率与分类的关系" class="headerlink" title="概率与分类的关系"></a><b>概率与分类的关系</b></h5><p>&emsp;&emsp;那上面的例子和分类有什么关系呢？这时我们把盒子1 换成类别$C_1$，把盒子2换成类别$C_2$，把蓝球换成我们要分类的样本$x$，同理如果我们已知下图红框的4个概率，根据<b>贝叶斯公式</b>可以求出后验概率$P(C_1|x)和$$P(C_2|x)$。</p><p>所以对于分类问题，我们的做法就是在训练集中求出图下的四个概率，再用<b>贝叶斯公式</b>某类别的后验概率。根据概率的大小判断属于某个类别。这套想法叫<b><font color='red'>生成模型（Generative Model）</font></b>，为什么叫生成模型呢？因为我们可以通过红框的四个概率计算得到$x$的全概率，也就是$x$的分布，知道分布后我们就可以生成$x$。</p><img src="https://s1.ax1x.com/2020/08/13/azak5R.jpg" alt="azak5R.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;将生成模型运用到宝可梦的案例中，这里我们以二分类问题为例子，即宝可梦是属于水系还是一般系。训练集中总共79只水系的，61只正常系的。从水系中抽取一只宝可梦的概率和从正常系中抽出一只宝可梦的概率如下。</p><img src="https://s1.ax1x.com/2020/08/13/azaCb4.jpg" alt="azaCb4.jpg" border="0" / loading="lazy"><p>那么我们现在的问题是，抓到了一只原盖海龟$x$，它属于水系的概率$P(C_1|x)$多大呢？根据贝叶斯公式，我们还差$P(x|C_1)$和$P(x|C_2)$未知，但是在原来的水系里根本就没有海龟这个样本，如果令$P(x|C_1)=0$，显然不对。</p><p>&emsp;&emsp;由于在模型中，我们的输入是宝可梦的一系列特征，这里以宝可梦的Defense和SP Defense两个特征为例，将这79只宝可梦的两个特征可视化如下图所示。由于训练集的数据往往只是冰山一角，对于新样本的预测，数据必须服从某分布才能被预测。这里计算$P(C_1|x)$的前提是<b>假设水系宝可梦的数据是服从一个高斯分布的</b>。</p><img src="https://s1.ax1x.com/2020/08/13/azaZ26.jpg" alt="azaZ26.jpg" border="0" / loading="lazy"><h5 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a><b>高斯分布</b></h5><p>&emsp;&emsp;高斯分布（Gaussian Distribution）的表达式如下所示。可知对于一个服从高斯分布的函数$f_{\mu,\Sigma}(x)$，只要确定了均值$\mu$和协方差矩阵$\Sigma$，就能够知道变量$x$的分布。（注：表达式中$D$是指向量的维度）不同均值$\mu$和协方差矩阵$\Sigma$代表的高斯分布也不同。如下两图是同一个$\Sigma$，不同$\mu$时的分布。</p><img src="https://s1.ax1x.com/2020/08/13/azaV8x.jpg" alt="azaV8x.jpg" border="0" / loading="lazy"><p>下两图是同一个$\mu$，不同$\Sigma$时的高斯分布。</p><img src="https://s1.ax1x.com/2020/08/13/azaexK.jpg" alt="azaexK.jpg" border="0" / loading="lazy"><p>其实对于宝可梦这79个样本点，任意确定均值$\mu$和协方差矩阵$\Sigma$都可以生成，只是它们生成每个点的概率大小不一样而已。如下图所示，对于靠左边的高斯分布生成这些点的可能性显然比右边的高斯分布要高。</p><img src="https://s1.ax1x.com/2020/08/13/azaQVH.jpg" alt="azaQVH.jpg" border="0" / loading="lazy"><p>所以我们的任务变成了找一个最好的$\mu$和$\Sigma$，使得它们组成的高斯分布生成的各个采样点的概率最大。</p><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a><b>最大似然估计</b></h3><p>&emsp;&emsp;完成上述任务最直接的方法就是最大似然估计（Maxium Likelihood）,具体的做法时由于每个样本点都是独立采样的，对于给定的$\mu$和$\Sigma$，它们的概率记为下图中的$L(\mu,\Sigma)$，根据独立事件的定义可以将$L(\mu,\Sigma)$表示出来。$L(\mu,\Sigma)$也被称为样本的“似然函数”，接着要求使得似然函数$L(\mu,\Sigma)$值最大的$\mu$和$\Sigma$，记为$\mu^*$和$\Sigma^*$。</p><p>&emsp;&emsp;关于$\mu^*$和$\Sigma^*$值的计算，我们可以分别对$\mu$和$\Sigma$求偏微分，令偏导等于0可以得到下图的公式和结果。</p><img src="https://s1.ax1x.com/2020/08/13/azaKqe.jpg" alt="azaKqe.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;通过最大似然估计的方法，我们可以计算出两个系高斯分布的$\mu$和$\Sigma$，得到的结果如下。</p><img src="https://s1.ax1x.com/2020/08/13/azaurD.jpg" alt="azaurD.jpg" border="0" / loading="lazy"><h3 id="分类结果"><a href="#分类结果" class="headerlink" title="分类结果"></a><b>分类结果</b></h3><p>&emsp;&emsp;回到原来的问题，新来的原盖海龟$x$，它属于水系的概率$P(C_1|x)$多大呢？这下可以计算了。根据贝叶斯公式，我们要确定$P(x|C_1)$和$P(x|C_2)   $ ，$P(C_1)$和$P(C_2)$，这四个值的大小计算如下。最后计算出结果$P(C_1|x)&gt;0.5$，那它就属于水系。</p><img src="https://s1.ax1x.com/2020/08/13/azalad.jpg" alt="azalad.jpg" border="0" / loading="lazy"><p>根据宝可梦的Defense和SP Defense两个特征的分类结果如下。</p><img src="https://s1.ax1x.com/2020/08/13/azaJRP.jpg" alt="azaJRP.jpg" border="0" / loading="lazy"><p>偏蓝部分是一般系的，偏红部分是水系的。可以看出只考虑这两个特征分类效果并不是很好，在测试集上的准确率只有47%。是不是因为我们考虑的特征太少了呢？在这里我们又把7个特征全考虑进去进行分类（当然7维空间图肯定画不出来，但计算机可以计算出来），最后在测试集上的准确度是54%，结果坏掉了。</p><p>&emsp;最后归结原因为可能一般系和水系根本就没办法通过特征区分出来。或者是因为我们生成的协方差矩阵是$\Sigma^1$和$\Sigma^2$，协方差矩阵是和输入特征大小的平方成正比，所以当特征很大时，协方差矩阵是可以增长很快的。<b>也就是模型的参数过多，这容易造成”过拟合”。</b></p><h3 id="模型改进"><a href="#模型改进" class="headerlink" title="模型改进"></a><b>模型改进</b></h3><h4 id="改进方法"><a href="#改进方法" class="headerlink" title="改进方法"></a><b>改进方法</b></h4><p>&emsp;&emsp;针对上述“过拟合”问题，我们对模型进行改进。思路是减少模型的参数，想法是共享两个高斯分布的协方差矩阵$\Sigma$。如下图所示。对于“水系”宝可梦，编码是1～79，服从的高斯分布均值为$\mu_1$；对于“一般系”的宝可梦，编码是80~140，服从的高斯分布均为$\mu_2$，它们的协方差矩阵都是$\Sigma$。</p><p>&emsp;&emsp;接着我们的任务是使用<b><font color='red'>最大似然估计</font></b>的方法计算使得似然函数$L(\mu_1,\mu_2,\Sigma)$最大的$\mu_1,\mu_2,\Sigma$。其中$\mu_1,\mu_2$的做法是和原来一样，而$\Sigma$的计算是原来$\Sigma^1,\Sigma^2$的加权平均。</p><img src="https://s1.ax1x.com/2020/08/13/aza8PI.jpg" alt="aza8PI.jpg" border="0" / loading="lazy"><h4 id="改进结果"><a href="#改进结果" class="headerlink" title="改进结果"></a><b>改进结果</b></h4><p>&emsp;&emsp;改进的结果如下所示。如果只考虑两个特征——SP Defense和Defense，输入空间是二维的。在我们从没有共享两个不同系的高斯分布协方差到共享它们的协方差矩阵，可以看出分界线也从曲线变成了直线。这种分类也称为“线性模型”。</p><p>&emsp;&emsp;但分类结果并不是很好（由于是二维空间，人眼就能看出分类）。如果考虑所有的7个特征，即输入空间是七维的。分类准确率从原来的54%提升到73%。所以说机器学习迷人的地方还在于它能处理高维度且人类无法直观想象的事情。</p><img src="https://s1.ax1x.com/2020/08/13/azaGGt.jpg" alt="azaGGt.jpg" border="0" / loading="lazy"><h3 id="分类问题建模总结"><a href="#分类问题建模总结" class="headerlink" title="分类问题建模总结"></a><b>分类问题建模总结</b></h3><p>&emsp;&emsp;&emsp;在本例中，已经确定了使用概率模型和假设样本服从高斯分布。所以总结步骤如下。</p><ol><li>四个先验概率通过贝叶斯公式计算出某一个样本的后验概率，根据概率值是否大于0.5进行分类；（建模）</li><li>如果遇到数据集中没有的样本$x$，我们可以假设所有的样本服从某一个分布，本例使用高斯分布，列出似然函数的式子；（找一个评价函数）</li><li>将已有数据通过最大似然估计法计算出最好的$\mu$和$\Sigma$，再求出样本$x$的四个先验概率进行分类。（选出最好的函数）</li></ol><img src="https://s1.ax1x.com/2020/08/13/azaYxf.jpg" alt="azaYxf.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;<b><font color='red'>关于要怎样选择服从分布的问题</font></b>，这主要依靠人去调节，具体问题具体分析。如果是二分类问题（判断宝可梦是不是神兽），此时可以选用<b>二项分布（Bernouli Distribution）</b>。如果恰好问题的各个特征之间都是统计独立的，此时可以使用<b>朴素贝叶斯分类（Naive Bayes Classifier）</b>。朴素贝叶斯分类的计算方法如下，假设问题的输入有$K$个特征，并且它们之间都是统计独立的服从一维高斯分布，最终先验概率的求解为各个特征的概率相乘。</p><img src="https://s1.ax1x.com/2020/08/13/azaUsS.jpg" alt="azaUsS.jpg" border="0" / loading="lazy"><h2 id="Sigmoid函数的推导"><a href="#Sigmoid函数的推导" class="headerlink" title="Sigmoid函数的推导"></a><b>Sigmoid函数的推导</b></h2><p>&emsp;&emsp;为什么会突然讲到Sigmoid函数的推导呢？因为在上述讲概率模型时讲到了贝叶斯公式，而由贝叶斯公式得到的后验概率$P(C_1|x)$经过推导后，发现就是Sigmoid函数$\sigma(z)$，推导过程如下。</p><img src="https://s1.ax1x.com/2020/08/13/azaNM8.jpg" alt="azaNM8.jpg" border="0" / loading="lazy"><p>$\sigma(z)=\frac1{1+e^{-z} }$的$z$取值$(-\infty,+\infty)$的图像如上所示。当$z$趋于$-\infty$时，函数值趋于0，当$z$趋于$+\infty$时，函数值趋于1。</p><p>那$z$的图像应该长什么样子呢？这里我们还是以二分类问题为例，假设生成两个类别的数据服从高斯分布，可得到以下式子：</p><img src="https://s1.ax1x.com/2020/08/13/aza0aj.jpg" alt="aza0aj.jpg" border="0" / loading="lazy"><p>其中$N_1$和$N_2$各表示各自类别样本个数。</p><img src="https://s1.ax1x.com/2020/08/16/dEaNWT.jpg" alt="dEaNWT.jpg" border="0" / loading="lazy"><img src="https://s1.ax1x.com/2020/08/16/dEaaSU.jpg" alt="dEaaSU.jpg" border="0" / loading="lazy"><p>由于为了防止模型参数过多而造成过拟合问题，我们还假设了两个类别服从的高斯分布的协方差矩阵都是$\Sigma$。</p><img src="https://s1.ax1x.com/2020/08/16/dEatYV.jpg" alt="dEatYV.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;经过一系列运算，我们得到$P(C_1|x)=\sigma(w\cdot x+b)$，（$z$的结果中$x$前面的系数记为$\omega^T$，后三项的结果记为常数$b$，写成$w\cdot x$是因为$\omega$和$x$都是列向量，$\omega\cdot x=（\omega^T）*x$）。</p><p>&emsp;&emsp;根据这个结果，就可以解释为什么在模型改进时我们共用了协方差矩阵后的分界线是线性的。直观上我们通过计算$N_1,N_2,\mu^1,\mu^2,\Sigma$确实可以算出$z$。但太麻烦了，在Logistic Regression中我们还有别的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bias and Variance</title>
      <link href="/academic_research/machine_learning/bias_and_variance/"/>
      <url>/academic_research/machine_learning/bias_and_variance/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>&emsp;&emsp;关于机器学习的入门课，个人感觉没太多新东西，只是当时有空就顺便写下哈哈哈，其实这些基础概念知乎博客应该比比皆是，但是我既然写过了不放上博客感觉自己好像白写了，呜呜呜。放上面有时候自己看看也有点小成就感(￣︶￣*))</p><span id="more"></span><h1 id="机器学习拟合的误差来源"><a href="#机器学习拟合的误差来源" class="headerlink" title="机器学习拟合的误差来源"></a><strong>机器学习拟合的误差来源</strong></h1><h2 id="误差来源"><a href="#误差来源" class="headerlink" title="误差来源"></a><strong>误差来源</strong></h2><p>&emsp;&emsp;为什么我们要了解机器学习拟合的误差的来源呢？因为只有从源头上把握误差的产生，我们才能更好的调整模型参数，进一步从训练集中找到一个估测函数$f^*$，使它无限接近于原问题的目标函数$\hat f$。然而使得<b>估测函数$f^*$与目标函数$\hat f$存在<font color='red'>差距的来源是偏差（bias）和方差（variance）</font></b>。</p><h2 id="偏差和方差"><a href="#偏差和方差" class="headerlink" title="偏差和方差"></a><b>偏差和方差</b></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><b>概念</b></h3><p>&emsp;&emsp;偏差（bias）描述的是<b>在测试集上拟合出来的模型输出的均值与样本真实期望的距离</b>。简言之。就是拟合出来的模型在测试集上表现好不好。方差（variance）描述的是模型每次输出结果与输出期望之间的误差，简言之，就是<b>测试数据在模型上的离散程度</b>。</p><p>&emsp;&emsp;如下图所示。如果以射靶为例子的话，样本的真实结果就是你瞄准的红心（目标函数$f^*$）,像第四个图，偏差就表示模型输出结果的期望和真实结果之间的距离，偏差越大，表示输出数据整体上远离目标函数，就根本没有瞄准靶心打（像第三和第四个图）；偏差越小，表示输出数据靠近目标函数，是瞄准靶心打的。方差越大，表示输出的结果相对于输出结果的均值很分散，方差越小，表示输出结果相对于输出结果的均值较为集中。</p><p>&emsp;&emsp;所以就会出现以下四种情况——瞄准了打的也很集中，瞄准了但可能由于手不稳定打的很分散，根本没瞄准但手稳定打的也很集中，根本没瞄准且手也不稳定打的很分散。</p><img src="https://s1.ax1x.com/2020/08/08/a5Z4ts.jpg" alt="a5Z4ts.jpg" border="0" style="zoom:50%"/ loading="lazy"><h3 id="均值和方差的估算"><a href="#均值和方差的估算" class="headerlink" title="均值和方差的估算"></a><b>均值和方差的估算</b></h3><p>&emsp;&emsp;讨论方差的估算可以理解，那为什么要讨论均值的估算呢？因为只有先估算出采样数据的均值，我们才能更好地计算偏差（数据均值和目标函数期望值的距离）。</p><p>&emsp;&emsp;假设变量$x$的均值为$\mu$，方差为$\sigma^2$。为了估算出这两个值，我们对变量$x$进行了$N$次采样，计算$N$次的平均值$m$其实并不等于$\mu$（除非进行无限点的划分），$m$的值会$\mu$上下波动，但是我们可以通过这$N$个点的期望去计算出$\mu$。这种估计叫<b>无偏估计（unbiased estimator）</b>。</p><img src="https://s1.ax1x.com/2020/08/08/a5Zspt.jpg" alt="a5Zspt.jpg" border="0" / loading="lazy"><p>那我们怎么衡量$N$个采样点对于均值$\mu$的离散情况呢？可以采用以下公式计算$var[m]$，其中可见$N$值越大代表数据越集中，越小代表数据越分散。</p><img src="https://s1.ax1x.com/2020/08/08/a5Zy1P.jpg" alt="a5Zy1P.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;以上就是均值的估算，方差的估计可以采用以下公式。通过$N$次有限次采样的值可计算得到一个$s^2$，我们可以使用$s^2$去估计$\sigma^2$，通过计算$E(s^2)$我们发现并不恰好等于$\sigma^2$，这种估计叫<b>有偏估计(biased estimator)</b>。</p><p>&emsp;&emsp;&emsp;可以看出，采样次数$N$越大，$s^2$与$\sigma^2$之间估测的差距会减小。</p><img src="https://s1.ax1x.com/2020/08/08/a5Zhkj.jpg" alt="a5Zhkj.jpg" border="0" / loading="lazy"><h2 id="模型复杂度的影响"><a href="#模型复杂度的影响" class="headerlink" title="模型复杂度的影响"></a><b>模型复杂度的影响</b></h2><p>&emsp;&emsp;在Regrssion宝可梦的案例中，我们只训练得到了一个函数，但是实际上我们需要得到足够多的函数再取均值才能知道偏差的大小。所以在宝可梦的案例中，我们假设有很多个平行宇宙，如下图所示，并且在这些宇宙上抓10只宝可梦去训练同一个模型，可得到不同的函数，可以求得函数的均值。但现实生活可能不存在平行宇宙，此时可理解为同时进行了多次实验，并且将实验中的数据同时用同一模型去求得不同的函数。</p><img src="https://s1.ax1x.com/2020/08/08/a5Z5hn.jpg" alt="a5Z5hn.jpg" border="0" / loading="lazy"><p>由于平行宇宙中宝可梦的数据不同，使用同一模型得到的$f^*$也不同。如下图所示。</p><img src="https://s1.ax1x.com/2020/08/08/a5ZqnU.jpg" alt="a5ZqnU.jpg" border="0" / loading="lazy"><p>为了说明模型复杂度对方差的影响，我们对于100个平行世界的数据，使用了复杂度不同的三个模型，得到结果如下。</p><img src="https://s1.ax1x.com/2020/08/08/a5ep1x.jpg" alt="a5ep1x.jpg" border="0" / loading="lazy"><h3 id="不同模型对方差的影响"><a href="#不同模型对方差的影响" class="headerlink" title="不同模型对方差的影响"></a><b>不同模型对方差的影响</b></h3><p>&emsp;&emsp;方差主要看的是训练数据在模型上的离散程度。由上图可以得出以下结论：</p><p>&emsp;&emsp;对于不同模型的方差，由一次模型的训练数据比较集中，五次模型的训练数据比较分散，可以得出<b>越简单的模型，方差是越小（因为模型越简单越不容易受训练集的影响），越复杂的模型，方差越大</b>。</p><h3 id="不同模型对偏差的影响"><a href="#不同模型对偏差的影响" class="headerlink" title="不同模型对偏差的影响"></a><b>不同模型对偏差的影响</b></h3><p>&emsp;&emsp;偏差要看的模型的均值和目标函数的期望的距离。问题来了，在宝可梦的案例中，我们无法得知具体的目标函数。所以我们的做法是假设一个最佳函数$\hat f$（如下图黑线所示），通过该函数生成一系列数据模拟宝可梦的数据，再进行采样，利用采样数据去训练模型。</p><p>为了说明模型复杂度对偏差的影响，我们对于5000个平行世界的数据，使用了复杂度不同的三个模型，得到结果如下。</p><img src="https://s1.ax1x.com/2020/08/08/a5eFBD.jpg" alt="a5eFBD.jpg" border="0" / loading="lazy"><p>由上图可以得出以下结论：</p><p>&emsp;&emsp;对于不同模型的偏差，由一次模型的均值（蓝线）和目标函数差的很多，五次模型均值（蓝线）和目标函数差的较小，可以得出<b>越简单的模型，偏差越大，越复杂的模型，偏差越小</b>。</p><h3 id="产生影响的原因"><a href="#产生影响的原因" class="headerlink" title="产生影响的原因"></a><b>产生影响的原因</b></h3><p>&emsp;&emsp;为什么不同复杂情况的模型会对方差和偏差产生这样的影响呢？</p><p>如下图所示。假设所有的解函数和目标函数都在集合中。</p><p>如果模型比较简单，解函数的集合会比较小，此时数据也比较集中，但可能解集合中不包含目标函数，此时我们看到的就是偏差大，方差小的情况。如果模型比较复杂，解函数的集合会比较大（复杂模型可通过参数设置转化为简单模型，故解函数集合较大），此时数据会比较分散，但可能解集合中一般包含目标函数，此时我们看到的就是偏差小，方差大的情况。</p><img src="https://s1.ax1x.com/2020/08/08/a5e9c6.jpg" alt="a5e9c6.jpg" border="0" / loading="lazy"><h3 id="造成影响的后果和解决方法"><a href="#造成影响的后果和解决方法" class="headerlink" title="造成影响的后果和解决方法"></a><b>造成影响的后果和解决方法</b></h3><p>&emsp;&emsp;通过以下曲线图，我们可以看出<font color='red'><b>模型越简单，意味着偏差越大，造成的后果是欠拟合</b></font>。具体表现是模型在训练集上的误差较大。解决欠拟合问题一般的思路有两个。</p><ol><li>模型增加更多的输入特征；</li><li>换一个更复杂的模型。</li></ol><p><font color='red'><b>模型越复杂，意味着方差越大，造成的后果是过拟合</b></font>。具体表现是模型在测试集上的误差较大。解决过拟合问题一般的思路也有两个。</p><ol><li>增加训练数据；（因为方差大的表现是数据分散，增加数据能相对提高集中度，但实际操作数据难获取）</li><li>采用正则化。（加个惩罚项使得输入参数的影响尽量小，曲线尽量光滑，具体做法参考Regression）</li></ol><img src="https://s1.ax1x.com/2020/08/08/a5einO.jpg" alt="a5einO.jpg" border="0" / loading="lazy"><h2 id="模型的选择"><a href="#模型的选择" class="headerlink" title="模型的选择"></a><b>模型的选择</b></h2><p>&emsp;&emsp;通过模型复杂度的影响我们可以看出，偏差和方差之间是相互制衡的，具体可通过一个模型来表现。那怎么选择出一个好的模型呢？如下图所示，我们能否简单地认为在已有的测试集上$Error$最小的模型表现一定是最好的呢？</p><img src="https://s1.ax1x.com/2020/08/08/a5eEAH.jpg" alt="a5eEAH.jpg" border="0" / loading="lazy"><p>&emsp;&emsp;其实这种想法不正确，往往在未知测试集上得到的结果是大于你之前测得的结果。<b>这个时候你总不能回头再调节模型的参数让他在测试集上表现的更好吧。回头调节的危害是相当于你把测试集当成训练集用，在测试集上表现好的同时也容易产生过拟合。当实际部署到应用时泛化能力会很差</b>。</p><p>&emsp;&emsp;就好比你今年参加高考，你可以不断地利用模拟题或往年真题去寻找知识漏洞，但是你总不能用今年的高考试题去进行知识捡漏，假设你考试前真的做到一模一样的试题，那你确实可以考得很好，但万一试题产生较大变动，可能结果会差强人意。所以<b>正确的做法是在测试前一旦确定了模型，最好不要再改动</b>。</p><h3 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a><b>交叉验证</b></h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a><b>概念</b></h4><p>&emsp;&emsp;既然不能利用测试集进行调参，那怎样做比较合理呢？俗话说“解铃还须系铃人”，我们又回到了训练集，将训练集的数据按照一定的比例分为训练集和验证集，在训练集上训练出模型，通过验证集去选择误差最小的模型。这就是<b>交叉验证（Cross Validation）</b>。换言之，将准考考试的资料（训练集）划分一部分出来当作模拟考试（验证集）用，寻找知识漏洞。这才是常规做法。而最后的高考（测试集）只有一次。（目的是检测模型的泛化能力）</p><h4 id="N折交叉验证"><a href="#N折交叉验证" class="headerlink" title="N折交叉验证"></a><b>N折交叉验证</b></h4><p>&emsp;&emsp;既然已经确定了将训练集分成训练集和验证集，那怎样的分法比较好呢？有一种方法叫<b>N折交叉验证（N-fold Cross Validation）</b>。它是指将整个训练集分为$N$份，然后最后一份作为验证集，前$N-1$份作为训练集；倒数第二份作为验证集，剩下$N-1$作为训练集；…；一直到第一份作为验证集，剩下$N-1$份作为训练集。（总共有$N$份验证集，每份验证集对应着$N-1$份训练集）再用不同模型去进行$N$次训练，最终选择一个平均误差最小的模型。下图以$N=3$为例。</p><img src="https://s1.ax1x.com/2020/08/08/a5eugP.jpg" alt="a5eugP.jpg" border="0" / loading="lazy">]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Regression</title>
      <link href="/academic_research/machine_learning/regression/"/>
      <url>/academic_research/machine_learning/regression/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>&emsp;&emsp;这是我发的第一篇博客，抱着好玩的心态基于hexo搭建属于自己的网站，这里要非常感谢<a href="https://www.yunyoujun.cn/">云游大大</a>的云主题。关于机器学习的学习，今年5月份研究生上岸后开始接触，期间跟着B站台大<a href="http://speech.ee.ntu.edu.tw/~tlkagk/courses_ML20.html">李宏毅</a>老师的课学习倒也写了四篇Markdown，后来到后面深度学习可写的东西太多了，果断不写了，学习它的思想。但是新博客还是要放点东西试试水的，空荡荡岂不很难受哈哈哈，以后更新尽量以总结性的为主。加油搬砖～<br><img src="https://s3.ax1x.com/2020/11/15/DFjqpD.jpg" alt="DFjqpD.jpg" border="0" / loading="lazy"></p><span id="more"></span><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h2><p>&emsp;&emsp;在监督学习中，应用分为<b>回归问题，分类问题和标注问题</b>。回归问题一般是对连续值的处理，像预测房价，气温，销售额等。常用<font color='red'><b>线性回归</b></font>；分类问题模型一般输出是离散值，像图像分类，垃圾邮件识别，疾病检测等。常用<font color='red'><b>softmax回归</b></font>。所以回归应用场景十分广泛。<br><br><br></p><h2 id="线性回归模型"><a href="#线性回归模型" class="headerlink" title="线性回归模型"></a><strong>线性回归模型</strong></h2><p>&emsp;&emsp;为什么我们要对宝可梦的CP值（Combat Point的简称,属于战斗点数，CP值越高，战斗力越强。）进行预测呢？做这件事的<strong>理由是</strong>如果预测的宝可梦CP值较大，我们可以用它来进化，再去打道馆；如果预测的CP值小，我们就不用它进化而是做成宝可梦糖果。预测CP值的目的是为了节约资源和培养成本。</p><p>&emsp;&emsp;了解完动机后，我们该怎么预测呢？我们进行预测的前提条件是已经拥有一定数量的宝可梦的特征（像HP，进化前的CP值，weight,height,etc.）和它进化后的CP值。然后想办法（这里指回归）根据输入是特征和输出是<b>CP值<font color='red'>找到一个函数$f$，使得$f$尽量接近生成宝可梦CP值的函数</font></b>。整个过程图形化如下图所示。</p><img src="https://s1.ax1x.com/2020/08/05/asXN1H.png" alt="asXN1H.png" border="0" style="zoom:67%;"/ loading="lazy"><p>&emsp;&emsp;那怎么去找这样一个函数$f$呢？主要分为三步(第四步是计算)：</p><p>&emsp;&emsp;本次主要采用线性回归的方法，设$y$表示宝可梦进化后的CP值，$y^n$表示第$n$只宝可梦进化后的CP值，$x_i^n$表示第$n$只宝可梦的第$i$个特征。$w$表示权重（weight），$b$表示偏差（bias）。<br><br></p><h3 id="建模"><a href="#建模" class="headerlink" title="建模"></a><strong>建模</strong></h3><p>&emsp;&emsp;如果我们只考虑进化前的CP这一个特征，则可建模为$y=b+\omega x_{cp}$，我们的任务是从一系列<strong>不同的$w$和$b$组成的函数集合</strong>找到一个最接近于目标函数（宝可梦的进化是按照某个函数来生成的）的函数$f$；</p><p>&emsp;&emsp;但是在实际求解时，我们一般还会考虑更多的特征。此时建模为$y=b+\sum w_{i}x_{i}$，（$x_i:x_{cp},x_{hp},x_w,x_h$,……）我们的任务不变，还是是从一系列<strong>不同的$w$和$b$组成的函数集合</strong>中找到一个最接近于目标函数（宝可梦的进化是按照某个函数来生成的）的函数$f$；<br><br></p><h3 id="计算损失函数"><a href="#计算损失函数" class="headerlink" title="计算损失函数"></a><strong>计算损失函数</strong></h3><p>&emsp;&emsp;设$\hat y^n$表示第$n$只宝可梦进化后的<b><font color='red'>真实CP值</font></b>，$f(x_{cp}^n)$表示第$n$只宝可梦预测进化后的CP值，$x_i^n$表示第$n$只宝可梦的第$i$个特征。$w$表示权重（weight），$b$表示偏差（bias）。</p><p>&emsp;&emsp;为简单起见，以下谈论只考虑进化前的CP值这一个特征，则可建模为$y=b+wx_{cp}$，训练集是抓到的10只宝可梦，并且它们进化后的CP值已知。以进化前的CP值为横坐标，进化后的CP值为纵坐标。绘制成图为<br><img src="https://s1.ax1x.com/2020/08/05/asXGtO.png" alt="asXGtO.png" style="zoom:70%;" / loading="lazy"></p><p>&emsp;&emsp;得到训练集数据和模型后，我们定义$Loss Function$（损失函数）为$L(f)$,它的输入是一个函数$f$，输出是判断的这个函数的好坏，其中$L$的值越小代表$f$越好。在本实例中定义为<br>$$ L(f)=\sum_{n=1}^{10}((\hat y^n-f(x_{cp}^n)))^2 $$</p><p>$w$,$b$代入，也就是<br>$$ L(w,b)=\sum_{n=1}^{10}(\hat y^n-(b+wx_{cp}^n))^2 $$</p><p>我们也可以把$b-w$的坐标轴画出来，观察下$w,b$对$L$的影响。如下所示。<br><img src="https://s1.ax1x.com/2020/08/05/asXJhD.png" alt="asXJhD.png" border="0" style="zoom:67%;"/ loading="lazy"></p><p>由图可知，红色部分$Loss$的值较大，$w$和$b$越偏蓝代表$Loss$的值越小，即函数的拟合性能越好。<br><br></p><h3 id="找出使得损失最小的输入"><a href="#找出使得损失最小的输入" class="headerlink" title="找出使得损失最小的输入"></a><strong>找出使得损失最小的输入</strong></h3><p>&emsp;&emsp;损失函数值越小，说明函数的越接近目标函数。使损失函数最小的那个$w$和$b$就是最好的函数。即求解$f^*=\underset{x}{\operatorname {arg,min}}L(f)$<br>或为$$ w^*,b^*=\underset {w,b}{\operatorname {arg,min}}L(w,b)=\underset {w,b}{\operatorname {arg,min}}\sum_{n=1}^{10}(\hat y^n-(b+wx_{cp}^n))^2 $$<br>&emsp;&emsp;简单说就是求解能让$Loss$最小的$w$和$b$。如果学过线性回归的话，其实可以用<strong>最小二乘法</strong>进行求解出来。但是在李老师的课时，选用的是<b>梯度下降（Gradient Descent)</b>的方法来求解方程<b>梯度下降的好处</b>在于，<b><font color='red'>不论损失函数$L$再复杂，只要它是可微的，都可以采用梯度下降来找到比较好的结果。</font></b></p><h4 id="梯度下降的做法"><a href="#梯度下降的做法" class="headerlink" title="梯度下降的做法"></a><strong>梯度下降的做法</strong></h4><p>&emsp;&emsp;那梯度下降具体的原理和做法是怎么的呢？本节暂时介绍做法，原理放在下一节讲。假设我们现在只考虑求解一个参数$w$的情况。</p><p>此时方程为$w^*=\underset {w}{\operatorname {arg,min}}L(w)$，假设$L(w)$的函数图像如下棕色线所示。我们的任务就变成了在一个“山峰”中找到最低点。具体做法是<br>（1）随机选取一点作为初始化的$w^0$;</p><p>​（2）计算$\frac{dL}{dw}|_{w={w^0}}$;</p><p>（3）把$w^0-\eta\frac{dL}{dw}|_{w={w^0}}$的值赋给$w^1$进行更新。</p><p>​$\eta$是人为定义的学习率，对$w$的值进行更新的目标是往$L$最小值的方向逼近，所以当计算微分值（斜率）为正时，要减小$w$的值；为负时要</p><p>增加$w$的值。并且增加量取决于微分值$\frac{dL}{dw}$和学习率$\eta$，<b><font color='red'>相同微分值的情况下增大学习率，更新幅度大；减少学习率，更新幅度小。</font></b></p><p>​（4）以上过程只走了一步，实际上想要到达最低点要不断地进行以上两步进行迭代，最后可能走到局部最优值（Local Minima）或全局最优值(Gobal Minima)。但是结果确实可能陷入局部最小值，这取决于初始化的$w^0$的位置。<br><img src="https://s1.ax1x.com/2020/08/05/asXUcd.png" alt="asXUcd.png" border="0" style="zoom:67%;"/ loading="lazy"></p><p>&emsp;&emsp;那回到原来的问题，当我们有两个参数$w,b$时，怎么进行梯度下降呢？</p><p>同理，做法雷同一个参数的情形，只不过变成了原函数对两个参数分别求偏导。具体做法如下PPT所示，在此不在叙述。<br><img src="https://s1.ax1x.com/2020/08/05/asXt9e.png" alt="asXt9e.png" style="zoom:75%;"/ loading="lazy"></p><p>由两个参数的偏导数组成的矩阵就是函数$L$梯度。</p><h4 id="梯度下降的过程可视化"><a href="#梯度下降的过程可视化" class="headerlink" title="梯度下降的过程可视化"></a><strong>梯度下降的过程可视化</strong></h4><p>&emsp;&emsp;梯度下降寻找最小值的过程如下。<br><img src="https://s1.ax1x.com/2020/08/05/asXJhD.png" alt="asXJhD.png" border="0" style="zoom: 67%;"/ loading="lazy"></p><p>其中$\frac{\partial{L}}{\partial{b}}$和$\frac{\partial{L}}{\partial{\omega}}$是曲线的法线方向，通过学习率$\eta$控制下一步走的前后方向，可见通过梯度下降，能不断在连续函数的某个区域中找到一个最小值，也就是图中的蓝色区域。</p><h4 id="梯度下降可能遇到的问题"><a href="#梯度下降可能遇到的问题" class="headerlink" title="梯度下降可能遇到的问题"></a><strong>梯度下降可能遇到的问题</strong></h4><p>&emsp;&emsp;我们已经知道梯度下降方法是不管函数多复杂，只要它是可微的，总能求解出一个极值。那我们是否可以说经过多次更新参数后，我们都能得到最优的参数使得损失函数最小呢？不妨看下图的情况。<br><img src="https://s1.ax1x.com/2020/08/05/asXBHP.png" alt="asXBHP.png" border="0" style="zoom:67%;"/ loading="lazy"></p><p>&emsp;由图可知，<b><font color='red'>经过多次更新参数后，我们不一定能得到最优的参数使得损失函数最小，因为极值点或者驻点不一定函数的最值点。换言之，梯度下降方法容易受初始值$\omega^0$的位置影响而陷入局部最小值。</font></b></p><p>&emsp;&emsp;但幸运的是，在线性回归中，我们的<b>损失函数$L$没有局部最优解</b>。（因为无论是单变量还是多变量的线性回归，损失函数$L$都是凸函数。）<br><br></p><h3 id="梯度下降法求解"><a href="#梯度下降法求解" class="headerlink" title="梯度下降法求解"></a><strong>梯度下降法求解</strong></h3><p>&emsp;&emsp;在了解完梯度下降的方法后，利用这个方法来解方程$L(w,b)=\sum_{n=1}^{10}(\hat y^n-(b+wx_{cp}^n))^2$，计算步骤如下。<br><img src="https://s1.ax1x.com/2020/08/05/asXajA.png" alt="asXajA.png" border="0" style="zoom:67%;"/ loading="lazy"></p><p>（注：对$b$求偏导最后少了一个$-1$。）</p><p>计算结果为<br><img src="https://s1.ax1x.com/2020/08/05/asXwnI.png" alt="asXwnI.png" border="0" style="zoom: 67%;"/ loading="lazy"></p><p>&emsp;&emsp;求得的解为$b=-188.4,\omega=2.7$,除此之外，在整个求解过程中我们更关心在测试集上的$Average Error=35.0$,是否可以将其降得更低？<br><br><br></p><h2 id="单特征回归模型预测"><a href="#单特征回归模型预测" class="headerlink" title="单特征回归模型预测"></a><strong>单特征回归模型预测</strong></h2><p>&emsp;&emsp;为了让测试集上的$Average Error=35.0$更好地下降，我们可以换用更复杂的模型，即回到第一步建模。将模型进行修改。模型修改后的计算结果如下。（这里补充一点：是不是能画出直线就是线性模型，各种复杂的曲线就是非线性模型？ 其实还是线性模型，因为把 $x_{cp}^1 = (x_{cp})^2$ 看作一个特征，那么 $y = b + w_1·x_{cp} + w_2·x_{cp}^1$ 其实就是线性模型。）</p><div class="main">    <img src="https://s1.ax1x.com/2020/08/05/asXy4S.png" alt="asXy4S.png" border="0" style="zoom:50%;"/ loading="lazy">    <img src="https://s1.ax1x.com/2020/08/05/asXc9g.png" alt="asXc9g.png" border="0" style="zoom:50%;"/ loading="lazy"></div><center><figure><img src="https://s1.ax1x.com/2020/08/05/asXy4S.png" alt="asXy4S.png" border="0" style="zoom:11%;"/ loading="lazy"><img src="https://s1.ax1x.com/2020/08/05/asXc9g.png" alt="asXc9g.png" border="0" style="zoom:11%;"/ loading="lazy"></figure></center>&emsp;&emsp;由图可知，换用更复杂的模型后在训练集和测试集上的$Average Error$得到了更小的值，效果也更好。那么模型是不是越复杂越好呢？这就引出了下面讨论的<b>过拟合（Overfitting）问题</b>。<br><br><h2 id="过拟合问题"><a href="#过拟合问题" class="headerlink" title="过拟合问题"></a><strong>过拟合问题</strong></h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a><strong>概念</strong></h3><p>&emsp;&emsp;由上述模型我们得到了一个更好的效果，所以继续增加更高次方的模型。结果如下图所示。</p><center><figure><img src="https://s1.ax1x.com/2020/08/05/asXc9g.png" alt="asXc9g.png" border="0" style="zoom: 50%;"/ loading="lazy"><img src="https://s3.ax1x.com/2020/11/15/DF9qG6.png" alt="DF9qG6.png" border="0" style="zoom: 50%;"/ loading="lazy"></figure></center><p>&emsp;&emsp;什么是过拟合问题呢？由上图可知，<b><font color='red'>随着模型复杂程度的增加，最终使得模型在训练集上表现的效果更好</font><strong>（训练集上的$Average Error$越来越小）</strong><font color='red'>而模型在测试集上结果坏掉的现象称为过拟合（Overfitting）。</font></b><br><br></p><h3 id="过拟合图形化解释"><a href="#过拟合图形化解释" class="headerlink" title="过拟合图形化解释"></a><strong>过拟合图形化解释</strong></h3><p>&emsp;&emsp;如下所示，假设每一个模型对应一个集合，可得出5次模型 $\supseteq$ 4次模型 $\supseteq$ 3次模型(原因是令高次项的 $w_i=0$ 可得到低次模型)。并且模型越复杂，在测试集上表现效果越好。<br><img src="https://s1.ax1x.com/2020/08/05/asXg3Q.png" alt="asXg3Q.png" border="0" style="zoom:67%;" / loading="lazy"></p><p>这5个函数在测试集上的表现如下：<br><img src="https://s1.ax1x.com/2020/08/05/asXRjs.png" alt="asXRjs.png" border="0" style="zoom:60%;"/ loading="lazy"></p><p>&emsp;&emsp;发现3次方以上的模型，已经出现了过拟合的现象，并且模型的泛化能力越来越差。所以考虑模型时要同时考虑训练集和测试集上$Average Error$。那么过拟合问题有没有办法解决呢？</p><br><h3 id="正则化解决过拟合问题"><a href="#正则化解决过拟合问题" class="headerlink" title="正则化解决过拟合问题"></a><strong>正则化解决过拟合问题</strong></h3><p>解决过拟合问题主要有两种方法，<font color='red'>法一是<strong>人工决定去掉某些特征</strong></font>（主要是针对引入特征过多造成过拟合），<font color='red'>法二是在<strong>保留原有特征同时采用正则化</strong></font>（主要针对模型复杂或引入特征过多造成过拟合）。以下主要介绍正则化解决过拟合问题。<br><br></p><h4 id="正则化概念"><a href="#正则化概念" class="headerlink" title="正则化概念"></a><strong>正则化概念</strong></h4><p>&emsp;&emsp;<b><font color='red'>正则化是指在保留原有特征的前提下，减小输入参数的幅值影响。</font></b>做法是在$Loss Function$中加入一个正则化参数$\lambda$，通过它来控制所有输入参数的权重。在本实验中的具体表达式为<br>$$ L=\sum_{n=1} (\hat y^n-(b+\omega x_{cp}^n))^2+\lambda\sum{(\omega_i^2)} $$<br><br></p><h4 id="能解决过拟合的原因"><a href="#能解决过拟合的原因" class="headerlink" title="能解决过拟合的原因"></a><strong>能解决过拟合的原因</strong></h4><p>&emsp;&emsp;过拟合产生的原因是整个模型过于依赖输入参数权值的影响。而正则化的思路是想办法降低参数权值的影响。</p><p>&emsp;&emsp;对于上述式子，$\lambda$的值可以人为调节。如果$\lambda$很小，那输出效果跟没添加一样。但是随着$\lambda$增大，在求同样的最小$Loss$的条件下，输入参数$\omega_i$的值会相对变小，从而抑制过拟合的产生。并且$\lambda$越大，$\omega_i$越小，拟合曲线越平滑，因为在直线中斜率值越小代表越不陡峭。为什么我们希望曲线越平滑越好呢？</p><p>&emsp;&emsp;假设模型为$y=b+\sum\omega_i x_i$，当输入一个微小的扰动$\Delta x_i$时，输出为$y=b+\sum\omega_i(x_i+\Delta x_i)$，此时当$\omega_i$的值足够小，则噪声点对于模型的影响就不明显了，从而降低了过拟合。但是如果$\lambda$值一直增大，会使得输出是一根近似于水平的直线，达不到拟合的要求，此时又陷入了“欠拟合”（underfitting）。<br><br></p><h4 id="正则化的效果"><a href="#正则化的效果" class="headerlink" title="正则化的效果"></a><strong>正则化的效果</strong></h4><p>&emsp;&emsp;对于同一个模型，进行正则化后调节$\lambda$在训练集和测试集的表现如下。<br><img src="https://s1.ax1x.com/2020/08/05/asXoNT.png" alt="asXoNT.png" border="0" style="zoom:67%;"/ loading="lazy"></p><p>&emsp;&emsp;可以看出，随着$\lambda$的值的增加，模型在测试集上的测试误差得到降低的同时训练误差也不会产生太大的变化。此时过拟合问题得到解决。但是当$\lambda$的值超过某一个数值后，测试误差又开始增加，此时又开始陷入了欠拟合。<br><br></p><h2 id="多特征的回归模型预测"><a href="#多特征的回归模型预测" class="headerlink" title="多特征的回归模型预测"></a><strong>多特征的回归模型预测</strong></h2><br><h3 id="加入宝可梦种类特征"><a href="#加入宝可梦种类特征" class="headerlink" title="加入宝可梦种类特征"></a><strong>加入宝可梦种类特征</strong></h3><p>&emsp;&emsp;这次我们在实验中抓取了60只宝可梦，它们的数据分布如下图所示。<br><img src="https://s3.ax1x.com/2020/11/15/DFP3tI.png" alt="DFP3tI.png" border="0" style="zoom:67%;" / loading="lazy"></p><p>此时若只考虑宝可梦的初始CP值这一个特征是远远不够的，我们猜测可能还跟宝可梦的种类有关。此时依然采用线性回归得到的模型为<br><img src="https://s1.ax1x.com/2020/08/05/asXfun.png" alt="asXfun.png" border="0" style="zoom:67%;" / loading="lazy"><br>此时又遇到一个新问题，怎样用一个函数将来表示这些不同物种的函数呢？如果你有学过信号与系统的话，就会知道有一个冲激函数$\delta(t-t_0)$，他的含义是当$t=t_0$时函数值为1，其余时刻为0。所以对应地我们这里令$t$等于各个物种即可。<br><img src="https://s1.ax1x.com/2020/08/05/asX4H0.jpg" alt="asX4H0.jpg" border="0" style="zoom: 80%;"/ loading="lazy"><br>该模型预测的结果为<br><img src="https://s1.ax1x.com/2020/08/05/asXhBq.png" alt="asXhBq.png" border="0" style="zoom: 67%;"/ loading="lazy"><br>由上图可知，宝可梦按种类划分在训练集上$Average Error$较小，而且预测的结果较为良好。<br><br></p><h3 id="加入宝可梦更多特征"><a href="#加入宝可梦更多特征" class="headerlink" title="加入宝可梦更多特征"></a><strong>加入宝可梦更多特征</strong></h3><p>&emsp;&emsp;在上图训练集中，还是有一些值在直线上上下扰动，拟合的不是很好。进化后的CP值会不会还和身高，体重和HP等特征有关呢？在不清楚的情况下，我们考虑把考虑到的特征全添加进去，重新建模如下所示。<br><img src="https://s3.ax1x.com/2020/11/15/DFi2Gt.png" alt="DFi2Gt.png" border="0" style="zoom:67%;"/ loading="lazy"><br>经过计算训练集和测试集上的$Average Error$发现又造成了过拟合,解决方法参考第四点哈哈哈。</p>]]></content>
      
      
      <categories>
          
          <category> 喵语笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
